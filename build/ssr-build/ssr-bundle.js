module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "JkW7");
/******/ })
/************************************************************************/
/******/ ({

/***/ "IIoC":
/***/ (function(module, exports, __webpack_require__) {

(function () {
  var g,
      goog = goog || {},
      k = this;function l(a) {
    return "string" == typeof a;
  }function aa() {}
  function ba(a) {
    var b = typeof a;if ("object" == b) {
      if (a) {
        if (a instanceof Array) return "array";if (a instanceof Object) return b;var c = Object.prototype.toString.call(a);if ("[object Window]" == c) return "object";if ("[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("splice")) return "array";if ("[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable("call")) return "function";
      } else return "null";
    } else if ("function" == b && "undefined" == typeof a.call) return "object";return b;
  }function n(a) {
    return "array" == ba(a);
  }function ca(a) {
    var b = ba(a);return "array" == b || "object" == b && "number" == typeof a.length;
  }function da(a) {
    return "function" == ba(a);
  }function p(a) {
    var b = typeof a;return "object" == b && null != a || "function" == b;
  }var q = "closure_uid_" + (1E9 * Math.random() >>> 0),
      ea = 0;function fa(a, b, c) {
    return a.call.apply(a.bind, arguments);
  }
  function ha(a, b, c) {
    if (!a) throw Error();if (2 < arguments.length) {
      var d = Array.prototype.slice.call(arguments, 2);return function () {
        var c = Array.prototype.slice.call(arguments);Array.prototype.unshift.apply(c, d);return a.apply(b, c);
      };
    }return function () {
      return a.apply(b, arguments);
    };
  }function r(a, b, c) {
    Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? r = fa : r = ha;return r.apply(null, arguments);
  }
  function ia(a, b) {
    var c = Array.prototype.slice.call(arguments, 1);return function () {
      var b = c.slice();b.push.apply(b, arguments);return a.apply(this, b);
    };
  }var t = Date.now || function () {
    return +new Date();
  };function u(a, b) {
    function c() {}c.prototype = b.prototype;a.L = b.prototype;a.prototype = new c();a.prototype.constructor = a;a.Ab = function (a, c, f) {
      for (var d = Array(arguments.length - 2), e = 2; e < arguments.length; e++) {
        d[e - 2] = arguments[e];
      }return b.prototype[c].apply(a, d);
    };
  };function ja(a) {
    if (Error.captureStackTrace) Error.captureStackTrace(this, ja);else {
      var b = Error().stack;b && (this.stack = b);
    }a && (this.message = String(a));
  }u(ja, Error);ja.prototype.name = "CustomError";function ka(a, b) {
    for (var c = a.split("%s"), d = "", e = Array.prototype.slice.call(arguments, 1); e.length && 1 < c.length;) {
      d += c.shift() + e.shift();
    }return d + c.join("%s");
  }var la = String.prototype.trim ? function (a) {
    return a.trim();
  } : function (a) {
    return a.replace(/^[\s\xa0]+|[\s\xa0]+$/g, "");
  };function ma(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  };function na(a, b) {
    b.unshift(a);ja.call(this, ka.apply(null, b));b.shift();
  }u(na, ja);na.prototype.name = "AssertionError";function oa(a, b) {
    throw new na("Failure" + (a ? ": " + a : ""), Array.prototype.slice.call(arguments, 1));
  };function w() {
    0 != qa && (ra[this[q] || (this[q] = ++ea)] = this);this.i = this.i;this.w = this.w;
  }var qa = 0,
      ra = {};w.prototype.i = !1;w.prototype.Z = function () {
    if (!this.i && (this.i = !0, this.A(), 0 != qa)) {
      var a = this[q] || (this[q] = ++ea);delete ra[a];
    }
  };w.prototype.A = function () {
    if (this.w) for (; this.w.length;) {
      this.w.shift()();
    }
  };var sa = Array.prototype.indexOf ? function (a, b) {
    return Array.prototype.indexOf.call(a, b, void 0);
  } : function (a, b) {
    if (l(a)) return l(b) && 1 == b.length ? a.indexOf(b, 0) : -1;for (var c = 0; c < a.length; c++) {
      if (c in a && a[c] === b) return c;
    }return -1;
  },
      ta = Array.prototype.forEach ? function (a, b, c) {
    Array.prototype.forEach.call(a, b, c);
  } : function (a, b, c) {
    for (var d = a.length, e = l(a) ? a.split("") : a, f = 0; f < d; f++) {
      f in e && b.call(c, e[f], f, a);
    }
  };
  function ua(a) {
    a: {
      var b = va;for (var c = a.length, d = l(a) ? a.split("") : a, e = 0; e < c; e++) {
        if (e in d && b.call(void 0, d[e], e, a)) {
          b = e;break a;
        }
      }b = -1;
    }return 0 > b ? null : l(a) ? a.charAt(b) : a[b];
  }function wa(a) {
    if (!n(a)) for (var b = a.length - 1; 0 <= b; b--) {
      delete a[b];
    }a.length = 0;
  }function xa(a) {
    return Array.prototype.concat.apply([], arguments);
  }function ya(a) {
    var b = a.length;if (0 < b) {
      for (var c = Array(b), d = 0; d < b; d++) {
        c[d] = a[d];
      }return c;
    }return [];
  };var x;a: {
    var za = k.navigator;if (za) {
      var Aa = za.userAgent;if (Aa) {
        x = Aa;break a;
      }
    }x = "";
  }function y(a) {
    return -1 != x.indexOf(a);
  };function Ba(a, b, c) {
    for (var d in a) {
      b.call(c, a[d], d, a);
    }
  }function Ca(a) {
    var b = [],
        c = 0,
        d;for (d in a) {
      b[c++] = a[d];
    }return b;
  }function Da(a) {
    var b = [],
        c = 0,
        d;for (d in a) {
      b[c++] = d;
    }return b;
  }function Ea(a) {
    var b = {},
        c;for (c in a) {
      b[c] = a[c];
    }return b;
  }var Fa = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
  function Ga(a, b) {
    for (var c, d, e = 1; e < arguments.length; e++) {
      d = arguments[e];for (c in d) {
        a[c] = d[c];
      }for (var f = 0; f < Fa.length; f++) {
        c = Fa[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
      }
    }
  };function Ha(a) {
    Ha[" "](a);return a;
  }Ha[" "] = aa;function Ia(a, b) {
    var c = Ja;return Object.prototype.hasOwnProperty.call(c, a) ? c[a] : c[a] = b(a);
  };var Ka = y("Opera"),
      z = y("Trident") || y("MSIE"),
      La = y("Edge"),
      Ma = y("Gecko") && !(-1 != x.toLowerCase().indexOf("webkit") && !y("Edge")) && !(y("Trident") || y("MSIE")) && !y("Edge"),
      Na = -1 != x.toLowerCase().indexOf("webkit") && !y("Edge");function Oa() {
    var a = k.document;return a ? a.documentMode : void 0;
  }var Pa;
  a: {
    var Qa = "",
        Ra = function () {
      var a = x;if (Ma) return (/rv:([^\);]+)(\)|;)/.exec(a)
      );if (La) return (/Edge\/([\d\.]+)/.exec(a)
      );if (z) return (/\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a)
      );if (Na) return (/WebKit\/(\S+)/.exec(a)
      );if (Ka) return (/(?:Version)[ \/]?(\S+)/.exec(a)
      );
    }();Ra && (Qa = Ra ? Ra[1] : "");if (z) {
      var Sa = Oa();if (null != Sa && Sa > parseFloat(Qa)) {
        Pa = String(Sa);break a;
      }
    }Pa = Qa;
  }var Ja = {};
  function Ta(a) {
    return Ia(a, function () {
      for (var b = 0, c = la(String(Pa)).split("."), d = la(String(a)).split("."), e = Math.max(c.length, d.length), f = 0; 0 == b && f < e; f++) {
        var h = c[f] || "",
            m = d[f] || "";do {
          h = /(\d*)(\D*)(.*)/.exec(h) || ["", "", "", ""];m = /(\d*)(\D*)(.*)/.exec(m) || ["", "", "", ""];if (0 == h[0].length && 0 == m[0].length) break;b = ma(0 == h[1].length ? 0 : parseInt(h[1], 10), 0 == m[1].length ? 0 : parseInt(m[1], 10)) || ma(0 == h[2].length, 0 == m[2].length) || ma(h[2], m[2]);h = h[3];m = m[3];
        } while (0 == b);
      }return 0 <= b;
    });
  }var Ua;var Va = k.document;
  Ua = Va && z ? Oa() || ("CSS1Compat" == Va.compatMode ? parseInt(Pa, 10) : 5) : void 0;var Wa = Object.freeze || function (a) {
    return a;
  };var Xa = !z || 9 <= Number(Ua),
      Ya = z && !Ta("9"),
      Za = function () {
    if (!k.addEventListener || !Object.defineProperty) return !1;var a = !1,
        b = Object.defineProperty({}, "passive", { get: function get() {
        a = !0;
      } });k.addEventListener("test", aa, b);k.removeEventListener("test", aa, b);return a;
  }();function A(a, b) {
    this.type = a;this.a = this.target = b;this.Pa = !0;
  }A.prototype.b = function () {
    this.Pa = !1;
  };function $a(a, b) {
    A.call(this, a ? a.type : "");this.relatedTarget = this.a = this.target = null;this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0;this.key = "";this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1;this.pointerId = 0;this.pointerType = "";this.c = null;if (a) {
      var c = this.type = a.type,
          d = a.changedTouches ? a.changedTouches[0] : null;this.target = a.target || a.srcElement;this.a = b;if (b = a.relatedTarget) {
        if (Ma) {
          a: {
            try {
              Ha(b.nodeName);var e = !0;break a;
            } catch (f) {}e = !1;
          }e || (b = null);
        }
      } else "mouseover" == c ? b = a.fromElement : "mouseout" == c && (b = a.toElement);this.relatedTarget = b;null === d ? (this.clientX = void 0 !== a.clientX ? a.clientX : a.pageX, this.clientY = void 0 !== a.clientY ? a.clientY : a.pageY, this.screenX = a.screenX || 0, this.screenY = a.screenY || 0) : (this.clientX = void 0 !== d.clientX ? d.clientX : d.pageX, this.clientY = void 0 !== d.clientY ? d.clientY : d.pageY, this.screenX = d.screenX || 0, this.screenY = d.screenY || 0);this.button = a.button;this.key = a.key || "";this.ctrlKey = a.ctrlKey;this.altKey = a.altKey;this.shiftKey = a.shiftKey;this.metaKey = a.metaKey;this.pointerId = a.pointerId || 0;this.pointerType = l(a.pointerType) ? a.pointerType : ab[a.pointerType] || "";this.c = a;a.defaultPrevented && this.b();
    }
  }u($a, A);var ab = Wa({ 2: "touch", 3: "pen", 4: "mouse" });$a.prototype.b = function () {
    $a.L.b.call(this);var a = this.c;if (a.preventDefault) a.preventDefault();else if (a.returnValue = !1, Ya) try {
      if (a.ctrlKey || 112 <= a.keyCode && 123 >= a.keyCode) a.keyCode = -1;
    } catch (b) {}
  };var bb = "closure_listenable_" + (1E6 * Math.random() | 0);function cb(a) {
    return !(!a || !a[bb]);
  }var db = 0;function eb(a, b, c, d, e) {
    this.listener = a;this.a = null;this.src = b;this.type = c;this.capture = !!d;this.ga = e;this.key = ++db;this.Y = this.ca = !1;
  }function fb(a) {
    a.Y = !0;a.listener = null;a.a = null;a.src = null;a.ga = null;
  };function gb(a) {
    this.src = a;this.a = {};this.b = 0;
  }gb.prototype.add = function (a, b, c, d, e) {
    var f = a.toString();a = this.a[f];a || (a = this.a[f] = [], this.b++);var h = hb(a, b, d, e);-1 < h ? (b = a[h], c || (b.ca = !1)) : (b = new eb(b, this.src, f, !!d, e), b.ca = c, a.push(b));return b;
  };function ib(a, b) {
    var c = b.type;if (c in a.a) {
      var d = a.a[c],
          e = sa(d, b),
          f;(f = 0 <= e) && Array.prototype.splice.call(d, e, 1);f && (fb(b), 0 == a.a[c].length && (delete a.a[c], a.b--));
    }
  }function jb(a, b, c, d, e) {
    a = a.a[b.toString()];b = -1;a && (b = hb(a, c, d, e));return -1 < b ? a[b] : null;
  }
  function hb(a, b, c, d) {
    for (var e = 0; e < a.length; ++e) {
      var f = a[e];if (!f.Y && f.listener == b && f.capture == !!c && f.ga == d) return e;
    }return -1;
  };var kb = "closure_lm_" + (1E6 * Math.random() | 0),
      lb = {},
      mb = 0;function nb(a, b, c, d, e) {
    if (d && d.once) return ob(a, b, c, d, e);if (n(b)) {
      for (var f = 0; f < b.length; f++) {
        nb(a, b[f], c, d, e);
      }return null;
    }c = pb(c);return cb(a) ? a.aa(b, c, p(d) ? !!d.capture : !!d, e) : qb(a, b, c, !1, d, e);
  }
  function qb(a, b, c, d, e, f) {
    if (!b) throw Error("Invalid event type");var h = p(e) ? !!e.capture : !!e,
        m = rb(a);m || (a[kb] = m = new gb(a));c = m.add(b, c, d, h, f);if (c.a) return c;d = sb();c.a = d;d.src = a;d.listener = c;if (a.addEventListener) Za || (e = h), void 0 === e && (e = !1), a.addEventListener(b.toString(), d, e);else if (a.attachEvent) a.attachEvent(tb(b.toString()), d);else if (a.addListener && a.removeListener) a.addListener(d);else throw Error("addEventListener and attachEvent are unavailable.");mb++;return c;
  }
  function sb() {
    var a = ub,
        b = Xa ? function (c) {
      return a.call(b.src, b.listener, c);
    } : function (c) {
      c = a.call(b.src, b.listener, c);if (!c) return c;
    };return b;
  }function ob(a, b, c, d, e) {
    if (n(b)) {
      for (var f = 0; f < b.length; f++) {
        ob(a, b[f], c, d, e);
      }return null;
    }c = pb(c);return cb(a) ? a.Ha(b, c, p(d) ? !!d.capture : !!d, e) : qb(a, b, c, !0, d, e);
  }function vb(a, b, c, d, e) {
    if (n(b)) for (var f = 0; f < b.length; f++) {
      vb(a, b[f], c, d, e);
    } else d = p(d) ? !!d.capture : !!d, c = pb(c), cb(a) ? a.va(b, c, d, e) : a && (a = rb(a)) && (b = jb(a, b, c, d, e)) && wb(b);
  }
  function wb(a) {
    if ("number" != typeof a && a && !a.Y) {
      var b = a.src;if (cb(b)) ib(b.c, a);else {
        var c = a.type,
            d = a.a;b.removeEventListener ? b.removeEventListener(c, d, a.capture) : b.detachEvent ? b.detachEvent(tb(c), d) : b.addListener && b.removeListener && b.removeListener(d);mb--;(c = rb(b)) ? (ib(c, a), 0 == c.b && (c.src = null, b[kb] = null)) : fb(a);
      }
    }
  }function tb(a) {
    return a in lb ? lb[a] : lb[a] = "on" + a;
  }
  function xb(a, b, c, d) {
    var e = !0;if (a = rb(a)) if (b = a.a[b.toString()]) for (b = b.concat(), a = 0; a < b.length; a++) {
      var f = b[a];f && f.capture == c && !f.Y && (f = yb(f, d), e = e && !1 !== f);
    }return e;
  }function yb(a, b) {
    var c = a.listener,
        d = a.ga || a.src;a.ca && wb(a);return c.call(d, b);
  }
  function ub(a, b) {
    if (a.Y) return !0;if (!Xa) {
      if (!b) a: {
        b = ["window", "event"];for (var c = k, d = 0; d < b.length; d++) {
          if (c = c[b[d]], null == c) {
            b = null;break a;
          }
        }b = c;
      }d = b;b = new $a(d, this);c = !0;if (!(0 > d.keyCode || void 0 != d.returnValue)) {
        a: {
          var e = !1;if (0 == d.keyCode) try {
            d.keyCode = -1;break a;
          } catch (h) {
            e = !0;
          }if (e || void 0 == d.returnValue) d.returnValue = !0;
        }d = [];for (e = b.a; e; e = e.parentNode) {
          d.push(e);
        }a = a.type;for (e = d.length - 1; 0 <= e; e--) {
          b.a = d[e];var f = xb(d[e], a, !0, b);c = c && f;
        }for (e = 0; e < d.length; e++) {
          b.a = d[e], f = xb(d[e], a, !1, b), c = c && f;
        }
      }return c;
    }return yb(a, new $a(b, this));
  }function rb(a) {
    a = a[kb];return a instanceof gb ? a : null;
  }var zb = "__closure_events_fn_" + (1E9 * Math.random() >>> 0);function pb(a) {
    if (da(a)) return a;a[zb] || (a[zb] = function (b) {
      return a.handleEvent(b);
    });return a[zb];
  };function B() {
    w.call(this);this.c = new gb(this);this.P = this;this.J = null;
  }u(B, w);B.prototype[bb] = !0;g = B.prototype;g.addEventListener = function (a, b, c, d) {
    nb(this, a, b, c, d);
  };g.removeEventListener = function (a, b, c, d) {
    vb(this, a, b, c, d);
  };
  g.dispatchEvent = function (a) {
    var b,
        c = this.J;if (c) for (b = []; c; c = c.J) {
      b.push(c);
    }c = this.P;var d = a.type || a;if (l(a)) a = new A(a, c);else if (a instanceof A) a.target = a.target || c;else {
      var e = a;a = new A(d, c);Ga(a, e);
    }e = !0;if (b) for (var f = b.length - 1; 0 <= f; f--) {
      var h = a.a = b[f];e = Ab(h, d, !0, a) && e;
    }h = a.a = c;e = Ab(h, d, !0, a) && e;e = Ab(h, d, !1, a) && e;if (b) for (f = 0; f < b.length; f++) {
      h = a.a = b[f], e = Ab(h, d, !1, a) && e;
    }return e;
  };
  g.A = function () {
    B.L.A.call(this);if (this.c) {
      var a = this.c,
          b = 0,
          c;for (c in a.a) {
        for (var d = a.a[c], e = 0; e < d.length; e++) {
          ++b, fb(d[e]);
        }delete a.a[c];a.b--;
      }
    }this.J = null;
  };g.aa = function (a, b, c, d) {
    return this.c.add(String(a), b, !1, c, d);
  };g.Ha = function (a, b, c, d) {
    return this.c.add(String(a), b, !0, c, d);
  };g.va = function (a, b, c, d) {
    var e = this.c;a = String(a).toString();if (a in e.a) {
      var f = e.a[a];b = hb(f, b, c, d);-1 < b && (fb(f[b]), Array.prototype.splice.call(f, b, 1), 0 == f.length && (delete e.a[a], e.b--));
    }
  };
  function Ab(a, b, c, d) {
    b = a.c.a[String(b)];if (!b) return !0;b = b.concat();for (var e = !0, f = 0; f < b.length; ++f) {
      var h = b[f];if (h && !h.Y && h.capture == c) {
        var m = h.listener,
            v = h.ga || h.src;h.ca && ib(a.c, h);e = !1 !== m.call(v, d) && e;
      }
    }return e && 0 != d.Pa;
  };function Bb(a) {
    return (/^\s*$/.test(a) ? !1 : /^[\],:{}\s\u2028\u2029]*$/.test(a.replace(/\\["\\\/bfnrtu]/g, "@").replace(/(?:"[^"\\\n\r\u2028\u2029\x00-\x08\x0a-\x1f]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)[\s\u2028\u2029]*(?=:|,|]|}|$)/g, "]").replace(/(?:^|:|,)(?:[\s\u2028\u2029]*\[)+/g, ""))
    );
  }function Cb(a) {
    a = String(a);if (Bb(a)) try {
      return eval("(" + a + ")");
    } catch (b) {}throw Error("Invalid JSON string: " + a);
  }function Db(a) {
    var b = [];Eb(new Fb(), a, b);return b.join("");
  }function Fb() {}
  function Eb(a, b, c) {
    if (null == b) c.push("null");else {
      if ("object" == typeof b) {
        if (n(b)) {
          var d = b;b = d.length;c.push("[");for (var e = "", f = 0; f < b; f++) {
            c.push(e), Eb(a, d[f], c), e = ",";
          }c.push("]");return;
        }if (b instanceof String || b instanceof Number || b instanceof Boolean) b = b.valueOf();else {
          c.push("{");e = "";for (d in b) {
            Object.prototype.hasOwnProperty.call(b, d) && (f = b[d], "function" != typeof f && (c.push(e), Gb(d, c), c.push(":"), Eb(a, f, c), e = ","));
          }c.push("}");return;
        }
      }switch (typeof b) {case "string":
          Gb(b, c);break;case "number":
          c.push(isFinite(b) && !isNaN(b) ? String(b) : "null");break;case "boolean":
          c.push(String(b));break;case "function":
          c.push("null");break;default:
          throw Error("Unknown type: " + typeof b);}
    }
  }var Hb = { '"': '\\"', "\\": "\\\\", "/": "\\/", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "\t": "\\t", "\x0B": "\\u000b" },
      Ib = /\uffff/.test("\uFFFF") ? /[\\"\x00-\x1f\x7f-\uffff]/g : /[\\"\x00-\x1f\x7f-\xff]/g;
  function Gb(a, b) {
    b.push('"', a.replace(Ib, function (a) {
      var b = Hb[a];b || (b = "\\u" + (a.charCodeAt(0) | 65536).toString(16).substr(1), Hb[a] = b);return b;
    }), '"');
  };function Jb(a, b) {
    this.c = a;this.f = b;this.b = 0;this.a = null;
  }Jb.prototype.get = function () {
    if (0 < this.b) {
      this.b--;var a = this.a;this.a = a.next;a.next = null;
    } else a = this.c();return a;
  };function Kb() {
    this.b = this.a = null;
  }var Nb = new Jb(function () {
    return new Lb();
  }, function (a) {
    a.reset();
  });Kb.prototype.add = function (a, b) {
    var c = Nb.get();c.set(a, b);this.b ? this.b.next = c : this.a = c;this.b = c;
  };function Ob() {
    var a = Pb,
        b = null;a.a && (b = a.a, a.a = a.a.next, a.a || (a.b = null), b.next = null);return b;
  }function Lb() {
    this.next = this.b = this.a = null;
  }Lb.prototype.set = function (a, b) {
    this.a = a;this.b = b;this.next = null;
  };Lb.prototype.reset = function () {
    this.next = this.b = this.a = null;
  };function Qb(a) {
    k.setTimeout(function () {
      throw a;
    }, 0);
  }var Rb;
  function Sb() {
    var a = k.MessageChannel;"undefined" === typeof a && "undefined" !== typeof window && window.postMessage && window.addEventListener && !y("Presto") && (a = function a() {
      var a = document.createElement("IFRAME");a.style.display = "none";a.src = "";document.documentElement.appendChild(a);var b = a.contentWindow;a = b.document;a.open();a.write("");a.close();var c = "callImmediate" + Math.random(),
          d = "file:" == b.location.protocol ? "*" : b.location.protocol + "//" + b.location.host;a = r(function (a) {
        if (("*" == d || a.origin == d) && a.data == c) this.port1.onmessage();
      }, this);b.addEventListener("message", a, !1);this.port1 = {};this.port2 = { postMessage: function postMessage() {
          b.postMessage(c, d);
        } };
    });if ("undefined" !== typeof a && !y("Trident") && !y("MSIE")) {
      var b = new a(),
          c = {},
          d = c;b.port1.onmessage = function () {
        if (void 0 !== c.next) {
          c = c.next;var a = c.za;c.za = null;a();
        }
      };return function (a) {
        d.next = { za: a };d = d.next;b.port2.postMessage(0);
      };
    }return "undefined" !== typeof document && "onreadystatechange" in document.createElement("SCRIPT") ? function (a) {
      var b = document.createElement("SCRIPT");
      b.onreadystatechange = function () {
        b.onreadystatechange = null;b.parentNode.removeChild(b);b = null;a();a = null;
      };document.documentElement.appendChild(b);
    } : function (a) {
      k.setTimeout(a, 0);
    };
  };var Tb;function Ub() {
    if (-1 != String(k.Promise).indexOf("[native code]")) {
      var a = k.Promise.resolve(void 0);Tb = function Tb() {
        a.then(Vb);
      };
    } else Tb = function Tb() {
      var a = Vb;!da(k.setImmediate) || k.Window && k.Window.prototype && !y("Edge") && k.Window.prototype.setImmediate == k.setImmediate ? (Rb || (Rb = Sb()), Rb(a)) : k.setImmediate(a);
    };
  }var Wb = !1,
      Pb = new Kb();function Vb() {
    for (var a; a = Ob();) {
      try {
        a.a.call(a.b);
      } catch (c) {
        Qb(c);
      }var b = Nb;b.f(a);100 > b.b && (b.b++, a.next = b.a, b.a = a);
    }Wb = !1;
  };function Xb(a, b) {
    B.call(this);this.b = a || 1;this.a = b || k;this.f = r(this.ib, this);this.g = t();
  }u(Xb, B);g = Xb.prototype;g.$ = !1;g.K = null;g.ib = function () {
    if (this.$) {
      var a = t() - this.g;0 < a && a < .8 * this.b ? this.K = this.a.setTimeout(this.f, this.b - a) : (this.K && (this.a.clearTimeout(this.K), this.K = null), this.dispatchEvent("tick"), this.$ && (this.K = this.a.setTimeout(this.f, this.b), this.g = t()));
    }
  };g.start = function () {
    this.$ = !0;this.K || (this.K = this.a.setTimeout(this.f, this.b), this.g = t());
  };
  function Yb(a) {
    a.$ = !1;a.K && (a.a.clearTimeout(a.K), a.K = null);
  }g.A = function () {
    Xb.L.A.call(this);Yb(this);delete this.a;
  };function Zb(a, b, c) {
    if (da(a)) c && (a = r(a, c));else if (a && "function" == typeof a.handleEvent) a = r(a.handleEvent, a);else throw Error("Invalid listener argument");return 2147483647 < Number(b) ? -1 : k.setTimeout(a, b || 0);
  };function $b(a, b, c) {
    w.call(this);this.f = null != c ? r(a, c) : a;this.c = b;this.b = r(this.bb, this);this.a = [];
  }u($b, w);g = $b.prototype;g.ha = !1;g.X = null;g.Xa = function (a) {
    this.a = arguments;this.X ? this.ha = !0 : ac(this);
  };g.A = function () {
    $b.L.A.call(this);this.X && (k.clearTimeout(this.X), this.X = null, this.ha = !1, this.a = []);
  };g.bb = function () {
    this.X = null;this.ha && (this.ha = !1, ac(this));
  };function ac(a) {
    a.X = Zb(a.b, a.c);a.f.apply(null, a.a);
  };function C(a) {
    w.call(this);this.b = a;this.a = {};
  }u(C, w);var bc = [];C.prototype.aa = function (a, b, c, d) {
    n(b) || (b && (bc[0] = b.toString()), b = bc);for (var e = 0; e < b.length; e++) {
      var f = nb(a, b[e], c || this.handleEvent, d || !1, this.b || this);if (!f) break;this.a[f.key] = f;
    }return this;
  };
  C.prototype.va = function (a, b, c, d, e) {
    if (n(b)) for (var f = 0; f < b.length; f++) {
      this.va(a, b[f], c, d, e);
    } else c = c || this.handleEvent, d = p(d) ? !!d.capture : !!d, e = e || this.b || this, c = pb(c), d = !!d, b = cb(a) ? jb(a.c, String(b), c, d, e) : a ? (a = rb(a)) ? jb(a, b, c, d, e) : null : null, b && (wb(b), delete this.a[b.key]);
  };function cc(a) {
    Ba(a.a, function (a, c) {
      this.a.hasOwnProperty(c) && wb(a);
    }, a);a.a = {};
  }C.prototype.A = function () {
    C.L.A.call(this);cc(this);
  };C.prototype.handleEvent = function () {
    throw Error("EventHandler.handleEvent not implemented");
  };function dc(a, b, c) {
    this.reset(a, b, c, void 0, void 0);
  }dc.prototype.a = null;var ec = 0;dc.prototype.reset = function (a, b, c, d, e) {
    "number" == typeof e || ec++;d || t();delete this.a;
  };function fc(a) {
    this.f = a;this.b = this.c = this.a = null;
  }function D(a, b) {
    this.name = a;this.value = b;
  }D.prototype.toString = function () {
    return this.name;
  };var gc = new D("SEVERE", 1E3),
      hc = new D("WARNING", 900),
      ic = new D("INFO", 800),
      jc = new D("CONFIG", 700),
      kc = new D("FINE", 500);function lc(a) {
    if (a.c) return a.c;if (a.a) return lc(a.a);oa("Root logger has no level set.");return null;
  }fc.prototype.log = function (a, b, c) {
    if (a.value >= lc(this).value) for (da(b) && (b = b()), a = new dc(a, String(b), this.f), c && (a.a = c), c = this; c;) {
      c = c.a;
    }
  };
  var mc = {},
      nc = null;function oc(a) {
    nc || (nc = new fc(""), mc[""] = nc, nc.c = jc);var b;if (!(b = mc[a])) {
      b = new fc(a);var c = a.lastIndexOf("."),
          d = a.substr(c + 1);c = oc(a.substr(0, c));c.b || (c.b = {});c.b[d] = b;b.a = c;mc[a] = b;
    }return b;
  };function E(a, b) {
    a && a.log(hc, b, void 0);
  }function pc(a, b) {
    a && a.log(ic, b, void 0);
  }function F(a, b) {
    a && a.log(kc, b, void 0);
  };function qc() {
    this.a = oc("goog.labs.net.webChannel.WebChannelDebug");this.b = !0;
  }qc.prototype.Ea = function () {
    this.b = !1;
  };function rc(a, b, c, d, e, f) {
    H(a, function () {
      if (a.b) {
        if (f) {
          var h = "";for (var m = f.split("&"), v = 0; v < m.length; v++) {
            var G = m[v].split("=");if (1 < G.length) {
              var Z = G[0];G = G[1];var Mb = Z.split("_");h = 2 <= Mb.length && "type" == Mb[1] ? h + (Z + "=" + G + "&") : h + (Z + "=redacted&");
            }
          }
        } else h = null;
      } else h = f;return "XMLHTTP REQ (" + d + ") [attempt " + e + "]: " + b + "\n" + c + "\n" + h;
    });
  }
  function sc(a, b, c, d, e, f, h) {
    H(a, function () {
      return "XMLHTTP RESP (" + d + ") [ attempt " + e + "]: " + b + "\n" + c + "\n" + f + " " + h;
    });
  }function tc(a, b, c, d) {
    H(a, function () {
      return "XMLHTTP TEXT (" + b + "): " + uc(a, c) + (d ? " " + d : "");
    });
  }function vc(a, b) {
    H(a, function () {
      return "TIMEOUT: " + b;
    });
  }function I(a, b) {
    F(a.a, b);
  }function wc(a, b, c) {
    (a = a.a) && a.log(gc, c || "Exception", b);
  }function H(a, b) {
    pc(a.a, b);
  }function xc(a, b) {
    (a = a.a) && a.log(gc, b, void 0);
  }
  function uc(a, b) {
    if (!a.b) return b;if (!b) return null;try {
      var c = JSON.parse(b);if (c) for (var d = 0; d < c.length; d++) {
        if (n(c[d])) {
          var e = c[d];if (!(2 > e.length)) {
            var f = e[1];if (n(f) && !(1 > f.length)) {
              var h = f[0];if ("noop" != h && "stop" != h && "close" != h) for (var m = 1; m < f.length; m++) {
                f[m] = "";
              }
            }
          }
        }
      }return Db(c);
    } catch (v) {
      return I(a, "Exception parsing expected JS array - probably was not JS"), b;
    }
  };var yc = new B();function zc(a) {
    A.call(this, "serverreachability", a);
  }u(zc, A);function Ac(a) {
    yc.dispatchEvent(new zc(yc, a));
  }function Bc(a) {
    A.call(this, "statevent", a);
  }u(Bc, A);function J(a) {
    yc.dispatchEvent(new Bc(yc, a));
  }function Cc(a) {
    A.call(this, "timingevent", a);
  }u(Cc, A);function Dc(a, b, c) {
    yc.dispatchEvent(new Cc(yc, a, b, c));
  }function Ec(a, b) {
    if (!da(a)) throw Error("Fn must not be null and must be a function");return k.setTimeout(function () {
      a();
    }, b);
  };var Fc = { NO_ERROR: 0, jb: 1, qb: 2, pb: 3, mb: 4, ob: 5, rb: 6, Ra: 7, TIMEOUT: 8, ub: 9 };var Gc = { lb: "complete", yb: "success", Sa: "error", Ra: "abort", wb: "ready", xb: "readystatechange", TIMEOUT: "timeout", sb: "incrementaldata", vb: "progress", nb: "downloadprogress", zb: "uploadprogress" };function Hc() {}Hc.prototype.a = null;function Ic(a) {
    var b;(b = a.a) || (b = {}, Jc(a) && (b[0] = !0, b[1] = !0), b = a.a = b);return b;
  };var Kc;function Lc() {}u(Lc, Hc);function Mc(a) {
    return (a = Jc(a)) ? new ActiveXObject(a) : new XMLHttpRequest();
  }function Jc(a) {
    if (!a.b && "undefined" == typeof XMLHttpRequest && "undefined" != typeof ActiveXObject) {
      for (var b = ["MSXML2.XMLHTTP.6.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP"], c = 0; c < b.length; c++) {
        var d = b[c];try {
          return new ActiveXObject(d), a.b = d;
        } catch (e) {}
      }throw Error("Could not create ActiveXObject. ActiveX might be disabled, or MSXML might not be installed");
    }return a.b;
  }Kc = new Lc();function K(a, b, c, d) {
    this.i = a;this.b = b;this.f = c;this.T = d || 1;this.N = new C(this);this.S = Nc;a = this.H = new Xb();a.b = Oc;a.K && a.$ ? (Yb(a), a.start()) : a.K && Yb(a);this.j = null;this.c = !1;this.m = this.g = this.h = this.J = this.D = this.U = this.w = null;this.s = [];this.a = null;this.F = 0;this.l = this.o = null;this.C = -1;this.B = !1;this.P = 0;this.I = null;this.M = !1;
  }var Nc = 45E3,
      Oc = 250;
  function Pc(a, b) {
    switch (a) {case 0:
        return "Non-200 return code (" + b + ")";case 1:
        return "XMLHTTP failure (no data)";case 2:
        return "HttpConnection timeout";default:
        return "Unknown error";}
  }var Qc = {},
      Rc = {};g = K.prototype;g.setTimeout = function (a) {
    this.S = a;
  };function Sc(a, b, c) {
    a.J = 1;a.h = Tc(L(b));a.m = c;a.M = !0;Uc(a, null);
  }function Vc(a, b, c, d) {
    a.J = 1;a.h = Tc(L(b));a.m = null;a.M = c;Uc(a, d);
  }
  function Uc(a, b) {
    a.D = t();Wc(a);a.g = L(a.h);Xc(a.g, "t", a.T);a.F = 0;a.a = a.i.da(a.i.ia() ? b : null);0 < a.P && (a.I = new $b(r(a.Qa, a, a.a), a.P));a.N.aa(a.a, "readystatechange", a.fb);b = a.j ? Ea(a.j) : {};a.m ? (a.o || (a.o = "POST"), b["Content-Type"] = "application/x-www-form-urlencoded", a.a.fa(a.g, a.o, a.m, b)) : (a.o = "GET", a.a.fa(a.g, a.o, null, b));Ac(1);rc(a.b, a.o, a.g, a.f, a.T, a.m);
  }g.fb = function (a) {
    a = a.target;var b = this.I;b && 3 == M(a) ? (I(this.b, "Throttling readystatechange."), b.Xa()) : this.Qa(a);
  };
  g.Qa = function (a) {
    try {
      a == this.a ? Yc(this) : E(this.b.a, "Called back with an unexpected xmlhttp");
    } catch (c) {
      if (I(this.b, "Failed call to OnXmlHttpReadyStateChanged_"), this.a && this.a.V()) {
        var b = this;wc(this.b, c, function () {
          return "ResponseText: " + b.a.V();
        });
      } else wc(this.b, c, "No response text");
    } finally {}
  };
  function Yc(a) {
    var b = M(a.a),
        c = a.a.Fa(),
        d = a.a.W();if (!(3 > b || 3 == b && !Ka && !a.a.V())) {
      a.B || 4 != b || 7 == c || (8 == c || 0 >= d ? Ac(3) : Ac(2));Zc(a);var e = a.a.W();a.C = e;(c = a.a.V()) || I(a.b, function () {
        return "No response text for uri " + a.g + " status " + e;
      });a.c = 200 == e;sc(a.b, a.o, a.g, a.f, a.T, b, e);a.c ? (a.M ? ($c(a, b, c), Ka && a.c && 3 == b && ad(a)) : (tc(a.b, a.f, c, null), bd(a, c)), 4 == b && cd(a), a.c && !a.B && (4 == b ? a.i.ua(a) : (a.c = !1, Wc(a)))) : (400 == e && 0 < c.indexOf("Unknown SID") ? (a.l = 3, J(12), E(a.b.a, "XMLHTTP Unknown SID (" + a.f + ")")) : (a.l = 0, J(13), E(a.b.a, "XMLHTTP Bad status " + e + " (" + a.f + ")")), cd(a), dd(a));
    }
  }function $c(a, b, c) {
    for (var d = !0; !a.B && a.F < c.length;) {
      var e = ed(a, c);if (e == Rc) {
        4 == b && (a.l = 4, J(14), d = !1);tc(a.b, a.f, null, "[Incomplete Response]");break;
      } else if (e == Qc) {
        a.l = 4;J(15);tc(a.b, a.f, c, "[Invalid Chunk]");d = !1;break;
      } else tc(a.b, a.f, e, null), bd(a, e);
    }4 == b && 0 == c.length && (a.l = 1, J(16), d = !1);a.c = a.c && d;d || (tc(a.b, a.f, c, "[Invalid Chunked Response]"), cd(a), dd(a));
  }
  g.eb = function () {
    var a = M(this.a),
        b = this.a.V();this.F < b.length && (Zc(this), $c(this, a, b), this.c && 4 != a && Wc(this));
  };function ad(a) {
    a.N.aa(a.H, "tick", a.eb);a.H.start();
  }function ed(a, b) {
    var c = a.F,
        d = b.indexOf("\n", c);if (-1 == d) return Rc;c = Number(b.substring(c, d));if (isNaN(c)) return Qc;d += 1;if (d + c > b.length) return Rc;b = b.substr(d, c);a.F = d + c;return b;
  }g.cancel = function () {
    this.B = !0;cd(this);
  };function Wc(a) {
    a.U = t() + a.S;fd(a, a.S);
  }
  function fd(a, b) {
    if (null != a.w) throw Error("WatchDog timer not null");a.w = Ec(r(a.cb, a), b);
  }function Zc(a) {
    a.w && (k.clearTimeout(a.w), a.w = null);
  }g.cb = function () {
    this.w = null;var a = t();0 <= a - this.U ? (this.c && xc(this.b, "Received watchdog timeout even though request loaded successfully"), vc(this.b, this.g), 2 != this.J && (Ac(3), J(17)), cd(this), this.l = 2, dd(this)) : (E(this.b.a, "WatchDog timer called too early"), fd(this, this.U - a));
  };function dd(a) {
    a.i.Ja() || a.B || a.i.ua(a);
  }
  function cd(a) {
    Zc(a);var b = a.I;b && "function" == typeof b.Z && b.Z();a.I = null;Yb(a.H);cc(a.N);a.a && (b = a.a, a.a = null, b.abort(), b.Z());
  }function bd(a, b) {
    try {
      a.i.Ma(a, b), Ac(4);
    } catch (c) {
      wc(a.b, c, "Error in httprequest callback");
    }
  };function gd(a) {
    if (a.v && "function" == typeof a.v) return a.v();if (l(a)) return a.split("");if (ca(a)) {
      for (var b = [], c = a.length, d = 0; d < c; d++) {
        b.push(a[d]);
      }return b;
    }return Ca(a);
  }
  function hd(a, b) {
    if (a.forEach && "function" == typeof a.forEach) a.forEach(b, void 0);else if (ca(a) || l(a)) ta(a, b, void 0);else {
      if (a.O && "function" == typeof a.O) var c = a.O();else if (a.v && "function" == typeof a.v) c = void 0;else if (ca(a) || l(a)) {
        c = [];for (var d = a.length, e = 0; e < d; e++) {
          c.push(e);
        }
      } else c = Da(a);d = gd(a);e = d.length;for (var f = 0; f < e; f++) {
        b.call(void 0, d[f], c && c[f], a);
      }
    }
  };function N(a, b) {
    this.b = {};this.a = [];this.c = 0;var c = arguments.length;if (1 < c) {
      if (c % 2) throw Error("Uneven number of arguments");for (var d = 0; d < c; d += 2) {
        this.set(arguments[d], arguments[d + 1]);
      }
    } else if (a) {
      a instanceof N ? (c = a.O(), d = a.v()) : (c = Da(a), d = Ca(a));for (var e = 0; e < c.length; e++) {
        this.set(c[e], d[e]);
      }
    }
  }g = N.prototype;g.u = function () {
    return this.c;
  };g.v = function () {
    id(this);for (var a = [], b = 0; b < this.a.length; b++) {
      a.push(this.b[this.a[b]]);
    }return a;
  };g.O = function () {
    id(this);return this.a.concat();
  };
  function jd(a) {
    a.b = {};a.a.length = 0;a.c = 0;
  }function kd(a, b) {
    return O(a.b, b) ? (delete a.b[b], a.c--, a.a.length > 2 * a.c && id(a), !0) : !1;
  }function id(a) {
    if (a.c != a.a.length) {
      for (var b = 0, c = 0; b < a.a.length;) {
        var d = a.a[b];O(a.b, d) && (a.a[c++] = d);b++;
      }a.a.length = c;
    }if (a.c != a.a.length) {
      var e = {};for (c = b = 0; b < a.a.length;) {
        d = a.a[b], O(e, d) || (a.a[c++] = d, e[d] = 1), b++;
      }a.a.length = c;
    }
  }g.get = function (a, b) {
    return O(this.b, a) ? this.b[a] : b;
  };g.set = function (a, b) {
    O(this.b, a) || (this.c++, this.a.push(a));this.b[a] = b;
  };
  g.forEach = function (a, b) {
    for (var c = this.O(), d = 0; d < c.length; d++) {
      var e = c[d],
          f = this.get(e);a.call(b, f, e, this);
    }
  };function O(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
  };var ld = /^(?:([^:/?#.]+):)?(?:\/\/(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;function md(a, b) {
    if (a) {
      a = a.split("&");for (var c = 0; c < a.length; c++) {
        var d = a[c].indexOf("="),
            e = null;if (0 <= d) {
          var f = a[c].substring(0, d);e = a[c].substring(d + 1);
        } else f = a[c];b(f, e ? decodeURIComponent(e.replace(/\+/g, " ")) : "");
      }
    }
  };function P(a, b) {
    this.b = this.j = this.f = "";this.i = null;this.g = this.a = "";this.h = !1;var c;a instanceof P ? (this.h = void 0 !== b ? b : a.h, nd(this, a.f), this.j = a.j, od(this, a.b), pd(this, a.i), this.a = a.a, qd(this, rd(a.c)), this.g = a.g) : a && (c = String(a).match(ld)) ? (this.h = !!b, nd(this, c[1] || "", !0), this.j = sd(c[2] || ""), od(this, c[3] || "", !0), pd(this, c[4]), this.a = sd(c[5] || "", !0), qd(this, c[6] || "", !0), this.g = sd(c[7] || "")) : (this.h = !!b, this.c = new td(null, this.h));
  }
  P.prototype.toString = function () {
    var a = [],
        b = this.f;b && a.push(ud(b, vd, !0), ":");var c = this.b;if (c || "file" == b) a.push("//"), (b = this.j) && a.push(ud(b, vd, !0), "@"), a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), c = this.i, null != c && a.push(":", String(c));if (c = this.a) this.b && "/" != c.charAt(0) && a.push("/"), a.push(ud(c, "/" == c.charAt(0) ? wd : xd, !0));(c = this.c.toString()) && a.push("?", c);(c = this.g) && a.push("#", ud(c, yd));return a.join("");
  };
  P.prototype.resolve = function (a) {
    var b = L(this),
        c = !!a.f;c ? nd(b, a.f) : c = !!a.j;c ? b.j = a.j : c = !!a.b;c ? od(b, a.b) : c = null != a.i;var d = a.a;if (c) pd(b, a.i);else if (c = !!a.a) {
      if ("/" != d.charAt(0)) if (this.b && !this.a) d = "/" + d;else {
        var e = b.a.lastIndexOf("/");-1 != e && (d = b.a.substr(0, e + 1) + d);
      }e = d;if (".." == e || "." == e) d = "";else if (-1 != e.indexOf("./") || -1 != e.indexOf("/.")) {
        d = 0 == e.lastIndexOf("/", 0);e = e.split("/");for (var f = [], h = 0; h < e.length;) {
          var m = e[h++];"." == m ? d && h == e.length && f.push("") : ".." == m ? ((1 < f.length || 1 == f.length && "" != f[0]) && f.pop(), d && h == e.length && f.push("")) : (f.push(m), d = !0);
        }d = f.join("/");
      } else d = e;
    }c ? b.a = d : c = "" !== a.c.toString();c ? qd(b, rd(a.c)) : c = !!a.g;c && (b.g = a.g);return b;
  };function L(a) {
    return new P(a);
  }function nd(a, b, c) {
    a.f = c ? sd(b, !0) : b;a.f && (a.f = a.f.replace(/:$/, ""));
  }function od(a, b, c) {
    a.b = c ? sd(b, !0) : b;
  }function pd(a, b) {
    if (b) {
      b = Number(b);if (isNaN(b) || 0 > b) throw Error("Bad port number " + b);a.i = b;
    } else a.i = null;
  }function qd(a, b, c) {
    b instanceof td ? (a.c = b, zd(a.c, a.h)) : (c || (b = ud(b, Ad)), a.c = new td(b, a.h));
  }
  function Q(a, b, c) {
    a.c.set(b, c);
  }function Xc(a, b, c) {
    n(c) || (c = [String(c)]);Bd(a.c, b, c);
  }function Tc(a) {
    Q(a, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ t()).toString(36));return a;
  }function Cd(a) {
    return a instanceof P ? L(a) : new P(a, void 0);
  }function Dd(a, b, c, d) {
    var e = new P(null, void 0);a && nd(e, a);b && od(e, b);c && pd(e, c);d && (e.a = d);return e;
  }function sd(a, b) {
    return a ? b ? decodeURI(a.replace(/%25/g, "%2525")) : decodeURIComponent(a) : "";
  }
  function ud(a, b, c) {
    return l(a) ? (a = encodeURI(a).replace(b, Ed), c && (a = a.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), a) : null;
  }function Ed(a) {
    a = a.charCodeAt(0);return "%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16);
  }var vd = /[#\/\?@]/g,
      xd = /[#\?:]/g,
      wd = /[#\?]/g,
      Ad = /[#\?@]/g,
      yd = /#/g;function td(a, b) {
    this.b = this.a = null;this.c = a || null;this.f = !!b;
  }function R(a) {
    a.a || (a.a = new N(), a.b = 0, a.c && md(a.c, function (b, c) {
      a.add(decodeURIComponent(b.replace(/\+/g, " ")), c);
    }));
  }g = td.prototype;g.u = function () {
    R(this);return this.b;
  };
  g.add = function (a, b) {
    R(this);this.c = null;a = Fd(this, a);var c = this.a.get(a);c || this.a.set(a, c = []);c.push(b);this.b += 1;return this;
  };function Gd(a, b) {
    R(a);b = Fd(a, b);O(a.a.b, b) && (a.c = null, a.b -= a.a.get(b).length, kd(a.a, b));
  }function Hd(a, b) {
    R(a);b = Fd(a, b);return O(a.a.b, b);
  }g.forEach = function (a, b) {
    R(this);this.a.forEach(function (c, d) {
      ta(c, function (c) {
        a.call(b, c, d, this);
      }, this);
    }, this);
  };
  g.O = function () {
    R(this);for (var a = this.a.v(), b = this.a.O(), c = [], d = 0; d < b.length; d++) {
      for (var e = a[d], f = 0; f < e.length; f++) {
        c.push(b[d]);
      }
    }return c;
  };g.v = function (a) {
    R(this);var b = [];if (l(a)) Hd(this, a) && (b = xa(b, this.a.get(Fd(this, a))));else {
      a = this.a.v();for (var c = 0; c < a.length; c++) {
        b = xa(b, a[c]);
      }
    }return b;
  };g.set = function (a, b) {
    R(this);this.c = null;a = Fd(this, a);Hd(this, a) && (this.b -= this.a.get(a).length);this.a.set(a, [b]);this.b += 1;return this;
  };g.get = function (a, b) {
    a = a ? this.v(a) : [];return 0 < a.length ? String(a[0]) : b;
  };
  function Bd(a, b, c) {
    Gd(a, b);0 < c.length && (a.c = null, a.a.set(Fd(a, b), ya(c)), a.b += c.length);
  }g.toString = function () {
    if (this.c) return this.c;if (!this.a) return "";for (var a = [], b = this.a.O(), c = 0; c < b.length; c++) {
      var d = b[c],
          e = encodeURIComponent(String(d));d = this.v(d);for (var f = 0; f < d.length; f++) {
        var h = e;"" !== d[f] && (h += "=" + encodeURIComponent(String(d[f])));a.push(h);
      }
    }return this.c = a.join("&");
  };function rd(a) {
    var b = new td();b.c = a.c;a.a && (b.a = new N(a.a), b.b = a.b);return b;
  }
  function Fd(a, b) {
    b = String(b);a.f && (b = b.toLowerCase());return b;
  }function zd(a, b) {
    b && !a.f && (R(a), a.c = null, a.a.forEach(function (a, b) {
      var c = b.toLowerCase();b != c && (Gd(this, b), Bd(this, c, a));
    }, a));a.f = b;
  };function Id() {
    this.a = t();
  }var Jd = null;Id.prototype.set = function (a) {
    this.a = a;
  };Id.prototype.reset = function () {
    this.set(t());
  };Id.prototype.get = function () {
    return this.a;
  };function Kd() {
    Jd || (Jd = new Id());
  }function Ld() {
    Jd || (Jd = new Id());
  }u(Ld, Kd);function Md() {}var Nd = { OPEN: "a", kb: "b", Sa: "c", tb: "d" };function Od() {
    A.call(this, "d");
  }u(Od, A);function Pd() {
    A.call(this, "c");
  }u(Pd, A);function Qd(a, b) {
    this.a = a;this.b = b;this.c = this.i = null;this.h = !1;this.l = null;this.f = -1;this.m = this.g = null;
  }g = Qd.prototype;g.R = null;
  function Rd(a) {
    I(a.b, "TestConnection: starting stage 2");var b = a.a.H.a;if (null != b) I(a.b, function () {
      return  true ? "Buffered" : "Unbuffered";
    }), J(4), b ? (J(10), Sd(a.a, a, !1)) : (J(11), Sd(a.a, a, !0));else {
      a.c = new K(a, a.b, void 0, void 0);a.c.j = a.i;var c = Td(a.a, a.g, a.l);J(4);Xc(c, "TYPE", "xmlhttp");var d = a.a.j,
          e = a.a.J;d && e && Q(c, d, e);Vc(a.c, c, !1, a.g);
    }
  }g.da = function (a) {
    return this.a.da(a);
  };g.abort = function () {
    this.c && (this.c.cancel(), this.c = null);this.f = -1;
  };
  g.Ja = function () {
    return !1;
  };
  g.Ma = function (a, b) {
    this.f = a.C;if (0 == this.R) {
      I(this.b, "TestConnection: Got data for stage 1");if (!this.a.D && (a = a.a)) {
        var c = a.a ? a.a.getResponseHeader("X-Client-Wire-Protocol") : null;this.m = c ? c : null;this.a.j && ((a = a.a ? a.a.getResponseHeader("X-HTTP-Session-Id") : null) ? this.a.J = a : E(this.b.a, "Missing X_HTTP_SESSION_ID in the handshake response"));
      }if (b) {
        try {
          var d = this.a.ma.a.parse(b);
        } catch (e) {
          wc(this.b, e);Ud(this.a, this);return;
        }this.g = d[0];
      } else I(this.b, "TestConnection: Null responseText"), Ud(this.a, this);
    } else if (1 == this.R) if (this.h) J(6);else if ("11111" == b) {
      if (J(5), this.h = !0, !z || 10 <= Number(Ua)) this.f = 200, this.c.cancel(), I(this.b, "Test connection succeeded; using streaming connection"), J(11), Sd(this.a, this, !0);
    } else J(7), this.h = !1;
  };
  g.ua = function () {
    this.f = this.c.C;this.c.c ? 0 == this.R ? (this.R = 1, I(this.b, "TestConnection: request complete for initial check"), Rd(this)) : 1 == this.R && (I(this.b, "TestConnection: request complete for stage 2"), this.h ? (I(this.b, "Test connection succeeded; using streaming connection"), J(11), Sd(this.a, this, !0)) : (I(this.b, "Test connection failed; not using streaming"), J(10), Sd(this.a, this, !1))) : (I(this.b, "TestConnection: request failed, in state " + this.R), 0 == this.R ? J(8) : 1 == this.R && J(9), Ud(this.a, this));
  };
  g.ia = function () {
    return this.a.ia();
  };g.ra = function () {
    return this.a.ra();
  };function Vd() {
    this.a = this.b = null;
  };function S() {
    this.a = new N();
  }function Wd(a) {
    var b = typeof a;return "object" == b && a || "function" == b ? "o" + (a[q] || (a[q] = ++ea)) : b.charAt(0) + a;
  }S.prototype.u = function () {
    return this.a.u();
  };S.prototype.add = function (a) {
    this.a.set(Wd(a), a);
  };S.prototype.contains = function (a) {
    a = Wd(a);return O(this.a.b, a);
  };S.prototype.v = function () {
    return this.a.v();
  };function Xd(a, b) {
    this.a = a;this.b = b;
  };function Yd(a) {
    this.g = a || Zd;this.f = k.pa && k.pa.Ka && k.pa.Ka() && k.pa.Ka().Bb ? this.g : 1;this.a = null;1 < this.f && (this.a = new S());this.b = null;this.c = [];
  }var Zd = 10;function $d(a, b) {
    a.a || -1 == b.indexOf("spdy") && -1 == b.indexOf("quic") && -1 == b.indexOf("h2") || (a.f = a.g, a.a = new S(), a.b && (ae(a, a.b), a.b = null));
  }function be(a) {
    return a.b ? !0 : a.a ? a.a.u() >= a.f : !1;
  }function ce(a, b) {
    return a.b ? a.b == b : a.a ? a.a.contains(b) : !1;
  }function ae(a, b) {
    a.a ? a.a.add(b) : a.b = b;
  }
  function de(a, b) {
    a.b && a.b == b ? a.b = null : a.a && a.a.contains(b) && kd(a.a.a, Wd(b));
  }Yd.prototype.cancel = function () {
    this.c = ee(this);this.b ? (this.b.cancel(), this.b = null) : this.a && 0 != this.a.a.c && (ta(this.a.v(), function (a) {
      a.cancel();
    }), jd(this.a.a));
  };function ee(a) {
    if (null != a.b) return a.c.concat(a.b.s);if (null != a.a && 0 != a.a.a.c) {
      var b = a.c;ta(a.a.v(), function (a) {
        b = b.concat(a.s);
      });return b;
    }return ya(a.c);
  }function fe(a, b) {
    a.c = a.c.concat(b);
  };function ge() {}ge.prototype.stringify = function (a) {
    return k.JSON.stringify(a, void 0);
  };ge.prototype.parse = function (a) {
    return k.JSON.parse(a, void 0);
  };function he() {
    this.a = new ge();
  }function ie(a, b, c) {
    var d = c || "";try {
      hd(a, function (a, c) {
        var e = a;p(a) && (e = Db(a));b.push(d + c + "=" + encodeURIComponent(e));
      });
    } catch (e) {
      throw b.push(d + "type=" + encodeURIComponent("_badmap")), e;
    }
  };function je(a, b) {
    var c = new qc();I(c, "TestLoadImage: loading " + a);var d = new Image();d.onload = ia(ke, c, d, "TestLoadImage: loaded", !0, b);d.onerror = ia(ke, c, d, "TestLoadImage: error", !1, b);d.onabort = ia(ke, c, d, "TestLoadImage: abort", !1, b);d.ontimeout = ia(ke, c, d, "TestLoadImage: timeout", !1, b);k.setTimeout(function () {
      if (d.ontimeout) d.ontimeout();
    }, 1E4);d.src = a;
  }function ke(a, b, c, d, e) {
    try {
      I(a, c), b.onload = null, b.onerror = null, b.onabort = null, b.ontimeout = null, e(d);
    } catch (f) {
      wc(a, f);
    }
  };function T(a) {
    B.call(this);this.headers = new N();this.F = a || null;this.f = !1;this.D = this.a = null;this.M = this.s = "";this.j = 0;this.g = "";this.h = this.I = this.o = this.H = !1;this.l = 0;this.B = null;this.N = le;this.C = this.m = !1;
  }u(T, B);var le = "";T.prototype.b = oc("goog.net.XhrIo");var me = /^https?$/i,
      ne = ["POST", "PUT"];g = T.prototype;
  g.fa = function (a, b, c, d) {
    if (this.a) throw Error("[goog.net.XhrIo] Object is active with another request=" + this.s + "; newUri=" + a);b = b ? b.toUpperCase() : "GET";this.s = a;this.g = "";this.j = 0;this.M = b;this.H = !1;this.f = !0;this.a = this.F ? Mc(this.F) : Mc(Kc);this.D = this.F ? Ic(this.F) : Ic(Kc);this.a.onreadystatechange = r(this.La, this);try {
      F(this.b, U(this, "Opening Xhr")), this.I = !0, this.a.open(b, String(a), !0), this.I = !1;
    } catch (f) {
      F(this.b, U(this, "Error opening Xhr: " + f.message));oe(this, f);return;
    }a = c || "";var e = new N(this.headers);
    d && hd(d, function (a, b) {
      e.set(b, a);
    });d = ua(e.O());c = k.FormData && a instanceof k.FormData;!(0 <= sa(ne, b)) || d || c || e.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");e.forEach(function (a, b) {
      this.a.setRequestHeader(b, a);
    }, this);this.N && (this.a.responseType = this.N);"withCredentials" in this.a && this.a.withCredentials !== this.m && (this.a.withCredentials = this.m);try {
      pe(this), 0 < this.l && (this.C = qe(this.a), F(this.b, U(this, "Will abort after " + this.l + "ms if incomplete, xhr2 " + this.C)), this.C ? (this.a.timeout = this.l, this.a.ontimeout = r(this.Ia, this)) : this.B = Zb(this.Ia, this.l, this)), F(this.b, U(this, "Sending request")), this.o = !0, this.a.send(a), this.o = !1;
    } catch (f) {
      F(this.b, U(this, "Send error: " + f.message)), oe(this, f);
    }
  };function qe(a) {
    return z && Ta(9) && "number" == typeof a.timeout && void 0 !== a.ontimeout;
  }function va(a) {
    return "content-type" == a.toLowerCase();
  }
  g.Ia = function () {
    "undefined" != typeof goog && this.a && (this.g = "Timed out after " + this.l + "ms, aborting", this.j = 8, F(this.b, U(this, this.g)), this.dispatchEvent("timeout"), this.abort(8));
  };function oe(a, b) {
    a.f = !1;a.a && (a.h = !0, a.a.abort(), a.h = !1);a.g = b;a.j = 5;re(a);se(a);
  }function re(a) {
    a.H || (a.H = !0, a.dispatchEvent("complete"), a.dispatchEvent("error"));
  }
  g.abort = function (a) {
    this.a && this.f && (F(this.b, U(this, "Aborting")), this.f = !1, this.h = !0, this.a.abort(), this.h = !1, this.j = a || 7, this.dispatchEvent("complete"), this.dispatchEvent("abort"), se(this));
  };g.A = function () {
    this.a && (this.f && (this.f = !1, this.h = !0, this.a.abort(), this.h = !1), se(this, !0));T.L.A.call(this);
  };g.La = function () {
    this.i || (this.I || this.o || this.h ? te(this) : this.ab());
  };g.ab = function () {
    te(this);
  };
  function te(a) {
    if (a.f && "undefined" != typeof goog) if (a.D[1] && 4 == M(a) && 2 == a.W()) F(a.b, U(a, "Local request error detected and ignored"));else if (a.o && 4 == M(a)) Zb(a.La, 0, a);else if (a.dispatchEvent("readystatechange"), 4 == M(a)) {
      F(a.b, U(a, "Request complete"));a.f = !1;try {
        var b = a.W();a: switch (b) {case 200:case 201:case 202:case 204:case 206:case 304:case 1223:
            var c = !0;break a;default:
            c = !1;}var d;if (!(d = c)) {
          var e;if (e = 0 === b) {
            var f = String(a.s).match(ld)[1] || null;if (!f && k.self && k.self.location) {
              var h = k.self.location.protocol;
              f = h.substr(0, h.length - 1);
            }e = !me.test(f ? f.toLowerCase() : "");
          }d = e;
        }d ? (a.dispatchEvent("complete"), a.dispatchEvent("success")) : (a.j = 6, a.g = a.Ga() + " [" + a.W() + "]", re(a));
      } finally {
        se(a);
      }
    }
  }function se(a, b) {
    if (a.a) {
      pe(a);var c = a.a,
          d = a.D[0] ? aa : null;a.a = null;a.D = null;b || a.dispatchEvent("ready");try {
        c.onreadystatechange = d;
      } catch (e) {
        (a = a.b) && a.log(gc, "Problem encountered resetting onreadystatechange: " + e.message, void 0);
      }
    }
  }function pe(a) {
    a.a && a.C && (a.a.ontimeout = null);a.B && (k.clearTimeout(a.B), a.B = null);
  }
  function M(a) {
    return a.a ? a.a.readyState : 0;
  }g.W = function () {
    try {
      return 2 < M(this) ? this.a.status : -1;
    } catch (a) {
      return -1;
    }
  };g.Ga = function () {
    try {
      return 2 < M(this) ? this.a.statusText : "";
    } catch (a) {
      return F(this.b, "Can not get status: " + a.message), "";
    }
  };g.V = function () {
    try {
      return this.a ? this.a.responseText : "";
    } catch (a) {
      return F(this.b, "Can not get responseText: " + a.message), "";
    }
  };
  g.Ya = function (a) {
    if (this.a) {
      var b = this.a.responseText;a && 0 == b.indexOf(a) && (b = b.substring(a.length));a: {
        a = b;if (k.JSON) try {
          var c = k.JSON.parse(a);break a;
        } catch (d) {}c = Cb(a);
      }return c;
    }
  };g.Fa = function () {
    return this.j;
  };g.Za = function () {
    return l(this.g) ? this.g : String(this.g);
  };function U(a, b) {
    return b + " [" + a.M + " " + a.s + " " + a.W() + "]";
  };function ue(a) {
    var b = "";Ba(a, function (a, d) {
      b += d;b += ":";b += a;b += "\r\n";
    });return b;
  }function ve(a, b, c) {
    a: {
      for (d in c) {
        var d = !1;break a;
      }d = !0;
    }if (d) return a;c = ue(c);if (l(a)) {
      b = encodeURIComponent(String(b));c = null != c ? "=" + encodeURIComponent(String(c)) : "";if (b += c) {
        c = a.indexOf("#");0 > c && (c = a.length);d = a.indexOf("?");if (0 > d || d > c) {
          d = c;var e = "";
        } else e = a.substring(d + 1, c);a = [a.substr(0, d), e, a.substr(c)];c = a[1];a[1] = b ? c ? c + "&" + b : b : c;a = a[0] + (a[1] ? "?" + a[1] : "") + a[2];
      }return a;
    }Q(a, b, c);return a;
  };function we(a) {
    this.ya = 0;this.g = [];this.a = new qc();this.H = new Vd();this.ja = this.wa = this.F = this.ka = this.b = this.J = this.j = this.U = this.h = this.M = this.i = null;this.Ua = this.P = 0;this.la = this.B = this.o = this.m = this.l = this.f = null;this.s = this.xa = this.N = -1;this.T = this.w = this.C = 0;this.S = a && a.supportsCrossDomainXhr || !1;this.I = "";this.c = new Yd(a && a.concurrentRequestLimit);this.ma = new he();this.D = a && void 0 !== a.backgroundChannelTest ? a.backgroundChannelTest : !0;this.Ta = a && a.fastHandshake || !1;a && a.Ea && this.a.Ea();
  }g = we.prototype;
  g.oa = 8;g.G = 1;function xe(a) {
    I(a.a, "disconnect()");ye(a);if (3 == a.G) {
      var b = a.P++,
          c = L(a.F);Q(c, "SID", a.I);Q(c, "RID", b);Q(c, "TYPE", "terminate");ze(a, c);b = new K(a, a.a, b, void 0);b.J = 2;b.h = Tc(L(c));c = !1;k.navigator && k.navigator.sendBeacon && (c = k.navigator.sendBeacon(b.h.toString(), ""));!c && k.Image && (new Image().src = b.h, c = !0);c || (b.a = b.i.da(null), b.a.fa(b.h));b.D = t();Wc(b);
    }Ae(a);
  }
  function ye(a) {
    a.B && (a.B.abort(), a.B = null);a.b && (a.b.cancel(), a.b = null);a.m && (k.clearTimeout(a.m), a.m = null);Be(a);a.c.cancel();a.l && (k.clearTimeout(a.l), a.l = null);
  }function Ce(a, b) {
    1E3 == a.g.length && xc(a.a, function () {
      return "Already have 1000 queued maps upon queueing " + Db(b);
    });a.g.push(new Xd(a.Ua++, b));3 == a.G && De(a);
  }g.Ja = function () {
    return 0 == this.G;
  };function De(a) {
    be(a.c) || a.l || (a.l = Ec(r(a.Oa, a), 0), a.C = 0);
  }
  function Ee(a, b) {
    var c = a.c;if ((c.b ? 1 : c.a ? c.a.u() : 0) >= a.c.f - (a.l ? 1 : 0)) return xc(a.a, "Unexpected retry request is scheduled."), !1;if (a.l) return I(a.a, "Use the retry request that is already scheduled."), a.g = b.s.concat(a.g), !0;if (1 == a.G || 2 == a.G || 2 <= a.C) return !1;I(a.a, "Going to retry POST");a.l = Ec(r(a.Oa, a, b), Fe(a, a.C));a.C++;return !0;
  }
  g.Oa = function (a) {
    this.l = null;I(this.a, "startForwardChannel_");if (1 == this.G) {
      if (a) xc(this.a, "Not supposed to retry the open");else {
        I(this.a, "open_()");this.P = Math.floor(1E5 * Math.random());a = this.P++;var b = new K(this, this.a, a, void 0),
            c = this.i;this.M && (c ? (c = Ea(c), Ga(c, this.M)) : c = this.M);null === this.h && (b.j = c);var d = Ge(this, b),
            e = L(this.F);Q(e, "RID", a);Q(e, "CVER", 21);this.D && this.j && Q(e, "X-HTTP-Session-Id", this.j);ze(this, e);this.h && c && ve(e, this.h, c);ae(this.c, b);this.Ta ? (Q(e, "$req", d), Sc(b, e, null)) : Sc(b, e, d);this.G = 2;
      }
    } else 3 == this.G && (a ? He(this, a) : 0 == this.g.length ? I(this.a, "startForwardChannel_ returned: nothing to send") : be(this.c) ? xc(this.a, "startForwardChannel_ returned: connection already in progress") : (He(this), I(this.a, "startForwardChannel_ finished, sent request")));
  };
  function He(a, b) {
    var c;b ? c = b.f : c = a.P++;var d = L(a.F);Q(d, "SID", a.I);Q(d, "RID", c);Q(d, "AID", a.N);ze(a, d);a.h && a.i && ve(d, a.h, a.i);c = new K(a, a.a, c, a.C + 1);null === a.h && (c.j = a.i);b && (a.g = b.s.concat(a.g));b = Ge(a, c);c.setTimeout(Math.round(1E4) + Math.round(1E4 * Math.random()));ae(a.c, c);Sc(c, d, b);
  }function ze(a, b) {
    a.f && hd({}, function (a, d) {
      Q(b, d, a);
    });
  }
  function Ge(a, b) {
    var c = Math.min(a.g.length, 1E3),
        d = a.f ? r(a.f.Va, a.f, a) : null;a: for (var e = a.g, f = -1;;) {
      var h = ["count=" + c];-1 == f ? 0 < c ? (f = e[0].a, h.push("ofs=" + f)) : f = 0 : h.push("ofs=" + f);for (var m = !0, v = 0; v < c; v++) {
        var G = e[v].a,
            Z = e[v].b;G -= f;if (0 > G) f = Math.max(0, e[v].a - 100), m = !1;else try {
          ie(Z, h, "req" + G + "_");
        } catch (Mb) {
          d && d(Z);
        }
      }if (m) {
        d = h.join("&");break a;
      }
    }a = a.g.splice(0, c);b.s = a;return d;
  }function Ie(a) {
    if (!a.b && !a.m) {
      a.T = 1;var b = a.Na;Tb || Ub();Wb || (Tb(), Wb = !0);Pb.add(b, a);a.w = 0;
    }
  }
  function Je(a) {
    if (a.b || a.m) return xc(a.a, "Request already in progress"), !1;if (3 <= a.w) return !1;I(a.a, "Going to retry GET");a.T++;a.m = Ec(r(a.Na, a), Fe(a, a.w));a.w++;return !0;
  }
  g.Na = function () {
    this.m = null;I(this.a, "Creating new HttpRequest");this.b = new K(this, this.a, "rpc", this.T);null === this.h && (this.b.j = this.i);this.b.P = 0;var a = L(this.wa);Q(a, "RID", "rpc");Q(a, "SID", this.I);Q(a, "CI", this.la ? "0" : "1");Q(a, "AID", this.N);ze(this, a);Q(a, "TYPE", "xmlhttp");this.h && this.i && ve(a, this.h, this.i);Vc(this.b, a, !0, this.ja);I(this.a, "New Request created");
  };
  function Sd(a, b, c) {
    I(a.a, "Test Connection Finished");var d = b.m;d && $d(a.c, d);a.la = c;a.s = b.f;I(a.a, "connectChannel_()");a.F = Ke(a, a.ka);De(a);
  }function Ud(a, b) {
    I(a.a, "Test Connection Failed");a.s = b.f;V(a, 2);
  }
  g.Ma = function (a, b) {
    if (0 != this.G && (this.b == a || ce(this.c, a))) if (this.s = a.C, ce(this.c, a) && 3 == this.G) {
      try {
        var c = this.ma.a.parse(b);
      } catch (f) {
        c = null;
      }if (n(c) && 3 == c.length) {
        if (b = c, 0 == b[0]) {
          a: if (I(this.a, "Server claims our backchannel is missing."), this.m) I(this.a, "But we are currently starting the request.");else {
            if (this.b) {
              if (this.b.D + 3E3 < a.D) Be(this), this.b.cancel(), this.b = null;else break a;
            } else E(this.a.a, "We do not have a BackChannel established");Je(this);J(18);
          }
        } else this.xa = b[1], a = this.xa - this.N, 0 < a && (b = b[2], I(this.a, b + " bytes (in " + a + " arrays) are outstanding on the BackChannel"), 37500 > b && this.la && 0 == this.w && !this.o && (this.o = Ec(r(this.$a, this), 6E3)));
      } else I(this.a, "Bad POST response data returned"), V(this, 11);
    } else if (this.b == a && Be(this), !/^[\s\xa0]*$/.test(b)) for (b = c = this.ma.a.parse(b), c = 0; c < b.length; c++) {
      var d = b[c];this.N = d[0];d = d[1];if (2 == this.G) {
        if ("c" == d[0]) {
          this.I = d[1];this.ja = d[2];var e = d[3];null != e && (this.oa = e, H(this.a, "VER=" + this.oa));d = d[4];null != d && (this.ya = d, H(this.a, "SVER=" + this.ya));
          this.D && (d = a.a) && ((e = d.a ? d.a.getResponseHeader("X-Client-Wire-Protocol") : null) && $d(this.c, e), this.j && ((d = d.a ? d.a.getResponseHeader("X-HTTP-Session-Id") : null) ? (this.J = d, Q(this.F, this.j, d)) : E(this.a.a, "Missing X_HTTP_SESSION_ID in the handshake response")));this.G = 3;this.f && this.f.Da();this.wa = Td(this, this.ja, this.ka);Ie(this);
        } else "stop" != d[0] && "close" != d[0] || V(this, 7);
      } else 3 == this.G && ("stop" == d[0] || "close" == d[0] ? "stop" == d[0] ? V(this, 7) : xe(this) : "noop" != d[0] && this.f && this.f.Ca(d), this.w = 0);
    }
  };
  g.$a = function () {
    null != this.o && (this.o = null, this.b.cancel(), this.b = null, Je(this), J(19));
  };function Be(a) {
    null != a.o && (k.clearTimeout(a.o), a.o = null);
  }
  g.ua = function (a) {
    I(this.a, "Request complete");var b = null;if (this.b == a) {
      Be(this);this.b = null;var c = 2;
    } else if (ce(this.c, a)) b = a.s, de(this.c, a), c = 1;else return;this.s = a.C;if (0 != this.G) if (a.c) 1 == c ? (Dc(a.m ? a.m.length : 0, t() - a.D, this.C), De(this)) : Ie(this);else {
      var d = a.l;if (3 == d || 0 == d && 0 < this.s) I(this.a, "Not retrying due to error type");else {
        var e = this;I(this.a, function () {
          return "Maybe retrying, last error: " + Pc(d, e.s);
        });if (1 == c && Ee(this, a) || 2 == c && Je(this)) return;I(this.a, "Exceeded max number of retries");
      }b && 0 < b.length && fe(this.c, b);I(this.a, "Error: HTTP request failed");switch (d) {case 1:
          V(this, 5);break;case 4:
          V(this, 10);break;case 3:
          V(this, 6);break;default:
          V(this, 2);}
    }
  };function Fe(a, b) {
    var c = 5E3 + Math.floor(1E4 * Math.random());a.ra() || (I(a.a, "Inactive channel"), c *= 2);return c * b;
  }
  function V(a, b) {
    H(a.a, "Error code " + b);if (2 == b) {
      var c = null;a.f && (c = null);var d = r(a.hb, a);c || (c = new P("//www.google.com/images/cleardot.gif"), k.location && "http" == k.location.protocol || nd(c, "https"), Tc(c));je(c.toString(), d);
    } else J(2);I(a.a, "HttpChannel: error - " + b);a.G = 0;a.f && a.f.Ba(b);Ae(a);ye(a);
  }g.hb = function (a) {
    a ? (H(this.a, "Successfully pinged google.com"), J(2)) : (H(this.a, "Failed to ping google.com"), J(1));
  };
  function Ae(a) {
    a.G = 0;a.s = -1;if (a.f) {
      var b = ee(a.c);if (0 != b.length || 0 != a.g.length) I(a.a, function () {
        return "Number of undelivered maps, pending: " + b.length + ", outgoing: " + a.g.length;
      }), a.c.c.length = 0, ya(a.g), a.g.length = 0;a.f.Aa();
    }
  }function Ke(a, b) {
    b = Le(a, null, b);I(a.a, "GetForwardChannelUri: " + b);return b;
  }function Td(a, b, c) {
    b = Le(a, a.ia() ? b : null, c);I(a.a, "GetBackChannelUri: " + b);return b;
  }
  function Le(a, b, c) {
    var d = Cd(c);if ("" != d.b) b && od(d, b + "." + d.b), pd(d, d.i);else {
      var e = k.location,
          f;b ? f = b + "." + e.hostname : f = e.hostname;d = Dd(e.protocol, f, e.port, c);
    }a.U && Ba(a.U, function (a, b) {
      Q(d, b, a);
    });b = a.j;c = a.J;b && c && Q(d, b, c);Q(d, "VER", a.oa);ze(a, d);return d;
  }g.da = function (a) {
    if (a && !this.S) throw Error("Can't create secondary domain capable XhrIo object.");a = new T();a.m = this.S;return a;
  };g.ra = function () {
    return !!this.f && !0;
  };g.ia = function () {
    return this.S;
  };new Ld();function Me() {}g = Me.prototype;g.Da = function () {};
  g.Ca = function () {};g.Ba = function () {};g.Aa = function () {};g.Va = function () {};function Ne(a) {
    for (var b = arguments[0], c = 1; c < arguments.length; c++) {
      var d = arguments[c];if (0 == d.lastIndexOf("/", 0)) b = d;else {
        var e;(e = "" == b) || (e = b.length - 1, e = 0 <= e && b.indexOf("/", e) == e);e ? b += d : b += "/" + d;
      }
    }return b;
  };function Oe() {
    if (z && !(10 <= Number(Ua))) throw Error("Environmental error: no available transport.");
  }Oe.prototype.a = function (a, b) {
    return new W(a, b);
  };
  function W(a, b) {
    B.call(this);this.a = new we(b);this.b = a;this.s = b && b.testUrl ? b.testUrl : Ne(this.b, "test");this.f = oc("goog.labs.net.webChannel.WebChannelBaseTransport");this.g = b && b.messageUrlParams || null;a = b && b.messageHeaders || null;b && b.clientProtocolHeaderRequired && (a ? a["X-Client-Protocol"] = "webchannel" : a = { "X-Client-Protocol": "webchannel" });this.a.i = a;a = b && b.initMessageHeaders || null;b && b.messageContentType && (a ? a["X-WebChannel-Content-Type"] = b.messageContentType : a = { "X-WebChannel-Content-Type": b.messageContentType });
    this.a.M = a;(a = b && b.httpHeadersOverwriteParam) && !/^[\s\xa0]*$/.test(a) && (this.a.h = a);this.o = b && b.supportsCrossDomainXhr || !1;this.m = b && b.sendRawJson || !1;(b = b && b.httpSessionIdParam) && !/^[\s\xa0]*$/.test(b) && (this.a.j = b, a = this.g, null !== a && b in a && (a = this.g, b in a && delete a[b], E(this.f, "Ignore httpSessionIdParam also specified with messageUrlParams: " + b)));this.h = new Pe(this);
  }u(W, B);
  W.prototype.j = function () {
    this.a.f = this.h;this.o && (this.a.S = !0);var a = this.a,
        b = this.s,
        c = this.b,
        d = this.g || void 0;I(a.a, "connect()");J(0);a.ka = c;a.U = d || {};a.D && (I(a.a, "connect() bypassed channel-test."), a.H.b = [], a.H.a = !1);I(a.a, "connectTest_()");a.B = new Qd(a, a.a);null === a.h && (a.B.i = a.i);c = b;a.h && a.i && (c = ve(b, a.h, a.i));a = a.B;a.l = c;b = Ke(a.a, a.l);J(3);c = a.a.H.b;null != c ? (a.g = c[0], a.R = 1, Rd(a)) : (Xc(b, "MODE", "init"), !a.a.D && a.a.j && Xc(b, "X-HTTP-Session-Id", a.a.j), a.c = new K(a, a.b, void 0, void 0), a.c.j = a.i, Vc(a.c, b, !1, null), a.R = 0);
  };W.prototype.close = function () {
    xe(this.a);
  };W.prototype.l = function (a) {
    if (l(a)) {
      var b = {};b.__data__ = a;Ce(this.a, b);
    } else this.m ? (b = {}, b.__data__ = Db(a), Ce(this.a, b)) : Ce(this.a, a);
  };W.prototype.A = function () {
    this.a.f = null;delete this.h;xe(this.a);delete this.a;W.L.A.call(this);
  };function Qe(a) {
    Od.call(this);var b = a.__sm__;if (b) {
      a: {
        for (var c in b) {
          a = c;break a;
        }a = void 0;
      }(this.c = a) ? (a = this.c, this.data = null !== b && a in b ? b[a] : void 0) : this.data = b;
    } else this.data = a;
  }u(Qe, Od);
  function Re() {
    Pd.call(this);this.status = 1;
  }u(Re, Pd);function Pe(a) {
    this.a = a;
  }u(Pe, Me);Pe.prototype.Da = function () {
    pc(this.a.f, "WebChannel opened on " + this.a.b);this.a.dispatchEvent("a");
  };Pe.prototype.Ca = function (a) {
    this.a.dispatchEvent(new Qe(a));
  };Pe.prototype.Ba = function (a) {
    pc(this.a.f, "WebChannel aborted on " + this.a.b + " due to channel error: " + a);this.a.dispatchEvent(new Re(a));
  };Pe.prototype.Aa = function () {
    pc(this.a.f, "WebChannel closed on " + this.a.b);this.a.dispatchEvent("b");
  };var Se = ia(function (a, b) {
    function c() {}c.prototype = a.prototype;var d = new c();a.apply(d, Array.prototype.slice.call(arguments, 1));return d;
  }, Oe);function Te() {
    this.b = [];this.a = [];
  }function Ue(a) {
    0 == a.b.length && (a.b = a.a, a.b.reverse(), a.a = []);return a.b.pop();
  }Te.prototype.u = function () {
    return this.b.length + this.a.length;
  };Te.prototype.contains = function (a) {
    return 0 <= sa(this.b, a) || 0 <= sa(this.a, a);
  };Te.prototype.v = function () {
    for (var a = [], b = this.b.length - 1; 0 <= b; --b) {
      a.push(this.b[b]);
    }var c = this.a.length;for (b = 0; b < c; ++b) {
      a.push(this.a[b]);
    }return a;
  };function Ve(a, b) {
    w.call(this);this.h = a || 0;this.c = b || 10;if (this.h > this.c) throw Error(We);this.a = new Te();this.b = new S();this.g = null;this.ba();
  }u(Ve, w);var We = "[goog.structs.Pool] Min can not be greater than max";g = Ve.prototype;g.ea = function () {
    var a = t();if (!(null != this.g && 0 > a - this.g)) {
      for (var b; 0 < this.a.u() && (b = Ue(this.a), !this.ta(b));) {
        this.ba();
      }!b && this.u() < this.c && (b = this.qa());b && (this.g = a, this.b.add(b));return b;
    }
  };g.gb = function (a) {
    return kd(this.b.a, Wd(a)) ? (this.na(a), !0) : !1;
  };
  g.na = function (a) {
    kd(this.b.a, Wd(a));this.ta(a) && this.u() < this.c ? this.a.a.push(a) : Xe(a);
  };g.ba = function () {
    for (var a = this.a; this.u() < this.h;) {
      var b = this.qa();a.a.push(b);
    }for (; this.u() > this.c && 0 < this.a.u();) {
      Xe(Ue(a));
    }
  };g.qa = function () {
    return {};
  };function Xe(a) {
    if ("function" == typeof a.Z) a.Z();else for (var b in a) {
      a[b] = null;
    }
  }g.ta = function (a) {
    return "function" == typeof a.Wa ? a.Wa() : !0;
  };g.contains = function (a) {
    return this.a.contains(a) || this.b.contains(a);
  };g.u = function () {
    return this.a.u() + this.b.u();
  };
  g.A = function () {
    Ve.L.A.call(this);if (0 < this.b.u()) throw Error("[goog.structs.Pool] Objects not released");delete this.b;for (var a = this.a; 0 != a.b.length || 0 != a.a.length;) {
      Xe(Ue(a));
    }delete this.a;
  };function Ye(a, b) {
    this.a = a;this.b = b;
  };function Ze(a) {
    this.a = [];if (a) a: {
      if (a instanceof Ze) {
        var b = a.O();a = a.v();if (0 >= this.u()) {
          for (var c = this.a, d = 0; d < b.length; d++) {
            c.push(new Ye(b[d], a[d]));
          }break a;
        }
      } else b = Da(a), a = Ca(a);for (d = 0; d < b.length; d++) {
        $e(this, b[d], a[d]);
      }
    }
  }function $e(a, b, c) {
    var d = a.a;d.push(new Ye(b, c));b = d.length - 1;a = a.a;for (c = a[b]; 0 < b;) {
      if (d = b - 1 >> 1, a[d].a > c.a) a[b] = a[d], b = d;else break;
    }a[b] = c;
  }Ze.prototype.v = function () {
    for (var a = this.a, b = [], c = a.length, d = 0; d < c; d++) {
      b.push(a[d].b);
    }return b;
  };
  Ze.prototype.O = function () {
    for (var a = this.a, b = [], c = a.length, d = 0; d < c; d++) {
      b.push(a[d].a);
    }return b;
  };Ze.prototype.u = function () {
    return this.a.length;
  };function af() {
    Ze.call(this);
  }u(af, Ze);function X(a, b) {
    this.f = new af();Ve.call(this, a, b);
  }u(X, Ve);g = X.prototype;g.ea = function (a, b) {
    if (!a) return X.L.ea.call(this);$e(this.f, void 0 !== b ? b : 100, a);this.sa();
  };g.sa = function () {
    for (var a = this.f; 0 < a.u();) {
      var b = this.ea();if (b) {
        var c = a,
            d = c.a,
            e = d.length;var f = d[0];if (0 >= e) f = void 0;else {
          if (1 == e) wa(d);else {
            d[0] = d.pop();d = 0;c = c.a;e = c.length;for (var h = c[d]; d < e >> 1;) {
              var m = 2 * d + 1,
                  v = 2 * d + 2;m = v < e && c[v].a < c[m].a ? v : m;if (c[m].a > h.a) break;c[d] = c[m];d = m;
            }c[d] = h;
          }f = f.b;
        }f.apply(this, [b]);
      } else break;
    }
  };
  g.na = function (a) {
    X.L.na.call(this, a);this.sa();
  };g.ba = function () {
    X.L.ba.call(this);this.sa();
  };g.A = function () {
    X.L.A.call(this);k.clearTimeout(void 0);wa(this.f.a);this.f = null;
  };function Y(a, b, c, d) {
    this.l = a;this.j = !!d;X.call(this, b, c);
  }u(Y, X);Y.prototype.qa = function () {
    var a = new T(),
        b = this.l;b && b.forEach(function (b, d) {
      a.headers.set(d, b);
    });this.j && (a.m = !0);return a;
  };Y.prototype.ta = function (a) {
    return !a.i && !a.a;
  };Oe.prototype.createWebChannel = Oe.prototype.a;W.prototype.send = W.prototype.l;W.prototype.open = W.prototype.j;W.prototype.close = W.prototype.close;Fc.NO_ERROR = 0;Fc.TIMEOUT = 8;Fc.HTTP_ERROR = 6;Gc.COMPLETE = "complete";Md.EventType = Nd;Nd.OPEN = "a";Nd.CLOSE = "b";Nd.ERROR = "c";Nd.MESSAGE = "d";B.prototype.listen = B.prototype.aa;Y.prototype.getObject = Y.prototype.ea;Y.prototype.releaseObject = Y.prototype.gb;T.prototype.listenOnce = T.prototype.Ha;T.prototype.getLastError = T.prototype.Za;T.prototype.getLastErrorCode = T.prototype.Fa;
  T.prototype.getStatus = T.prototype.W;T.prototype.getStatusText = T.prototype.Ga;T.prototype.getResponseJson = T.prototype.Ya;T.prototype.getResponseText = T.prototype.V;T.prototype.getResponseText = T.prototype.V;T.prototype.send = T.prototype.fa;module.exports = { createWebChannelTransport: Se, ErrorCode: Fc, EventType: Gc, WebChannel: Md, XhrIoPool: Y };
}).call(typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : {});

/***/ }),

/***/ "IpTH":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "JkW7":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });

// EXTERNAL MODULE: ./style/index.css
var style = __webpack_require__("rq4c");
var style_default = /*#__PURE__*/__webpack_require__.n(style);

// EXTERNAL MODULE: ../node_modules/preact/dist/preact.min.js
var preact_min = __webpack_require__("KM04");
var preact_min_default = /*#__PURE__*/__webpack_require__.n(preact_min);

// CONCATENATED MODULE: ../node_modules/preact-router/dist/preact-router.es.js


var EMPTY$1 = {};

function preact_router_es_assign(obj, props) {
	// eslint-disable-next-line guard-for-in
	for (var i in props) {
		obj[i] = props[i];
	}
	return obj;
}

function exec(url, route, opts) {
	var reg = /(?:\?([^#]*))?(#.*)?$/,
	    c = url.match(reg),
	    matches = {},
	    ret;
	if (c && c[1]) {
		var p = c[1].split('&');
		for (var i = 0; i < p.length; i++) {
			var r = p[i].split('=');
			matches[decodeURIComponent(r[0])] = decodeURIComponent(r.slice(1).join('='));
		}
	}
	url = segmentize(url.replace(reg, ''));
	route = segmentize(route || '');
	var max = Math.max(url.length, route.length);
	for (var i$1 = 0; i$1 < max; i$1++) {
		if (route[i$1] && route[i$1].charAt(0) === ':') {
			var param = route[i$1].replace(/(^\:|[+*?]+$)/g, ''),
			    flags = (route[i$1].match(/[+*?]+$/) || EMPTY$1)[0] || '',
			    plus = ~flags.indexOf('+'),
			    star = ~flags.indexOf('*'),
			    val = url[i$1] || '';
			if (!val && !star && (flags.indexOf('?') < 0 || plus)) {
				ret = false;
				break;
			}
			matches[param] = decodeURIComponent(val);
			if (plus || star) {
				matches[param] = url.slice(i$1).map(decodeURIComponent).join('/');
				break;
			}
		} else if (route[i$1] !== url[i$1]) {
			ret = false;
			break;
		}
	}
	if (opts.default !== true && ret === false) {
		return false;
	}
	return matches;
}

function pathRankSort(a, b) {
	return a.rank < b.rank ? 1 : a.rank > b.rank ? -1 : a.index - b.index;
}

// filter out VNodes without attributes (which are unrankeable), and add `index`/`rank` properties to be used in sorting.
function prepareVNodeForRanking(vnode, index) {
	vnode.index = index;
	vnode.rank = rankChild(vnode);
	return vnode.attributes;
}

function segmentize(url) {
	return url.replace(/(^\/+|\/+$)/g, '').split('/');
}

function rankSegment(segment) {
	return segment.charAt(0) == ':' ? 1 + '*+?'.indexOf(segment.charAt(segment.length - 1)) || 4 : 5;
}

function rank(path) {
	return segmentize(path).map(rankSegment).join('');
}

function rankChild(vnode) {
	return vnode.attributes.default ? 0 : rank(vnode.attributes.path);
}

var customHistory = null;

var ROUTERS = [];

var subscribers = [];

var EMPTY = {};

function isPreactElement(node) {
	return node.__preactattr_ != null || typeof Symbol !== 'undefined' && node[Symbol.for('preactattr')] != null;
}

function setUrl(url, type) {
	if (type === void 0) type = 'push';

	if (customHistory && customHistory[type]) {
		customHistory[type](url);
	} else if (typeof history !== 'undefined' && history[type + 'State']) {
		history[type + 'State'](null, null, url);
	}
}

function getCurrentUrl() {
	var url;
	if (customHistory && customHistory.location) {
		url = customHistory.location;
	} else if (customHistory && customHistory.getCurrentLocation) {
		url = customHistory.getCurrentLocation();
	} else {
		url = typeof location !== 'undefined' ? location : EMPTY;
	}
	return "" + (url.pathname || '') + (url.search || '');
}

function route(url, replace) {
	if (replace === void 0) replace = false;

	if (typeof url !== 'string' && url.url) {
		replace = url.replace;
		url = url.url;
	}

	// only push URL into history if we can handle it
	if (canRoute(url)) {
		setUrl(url, replace ? 'replace' : 'push');
	}

	return routeTo(url);
}

/** Check if the given URL can be handled by any router instances. */
function canRoute(url) {
	for (var i = ROUTERS.length; i--;) {
		if (ROUTERS[i].canRoute(url)) {
			return true;
		}
	}
	return false;
}

/** Tell all router instances to handle the given URL.  */
function routeTo(url) {
	var didRoute = false;
	for (var i = 0; i < ROUTERS.length; i++) {
		if (ROUTERS[i].routeTo(url) === true) {
			didRoute = true;
		}
	}
	for (var i$1 = subscribers.length; i$1--;) {
		subscribers[i$1](url);
	}
	return didRoute;
}

function routeFromLink(node) {
	// only valid elements
	if (!node || !node.getAttribute) {
		return;
	}

	var href = node.getAttribute('href'),
	    target = node.getAttribute('target');

	// ignore links with targets and non-path URLs
	if (!href || !href.match(/^\//g) || target && !target.match(/^_?self$/i)) {
		return;
	}

	// attempt to route, if no match simply cede control to browser
	return route(href);
}

function handleLinkClick(e) {
	if (e.button == 0) {
		routeFromLink(e.currentTarget || e.target || this);
		return prevent(e);
	}
}

function prevent(e) {
	if (e) {
		if (e.stopImmediatePropagation) {
			e.stopImmediatePropagation();
		}
		if (e.stopPropagation) {
			e.stopPropagation();
		}
		e.preventDefault();
	}
	return false;
}

function delegateLinkHandler(e) {
	// ignore events the browser takes care of already:
	if (e.ctrlKey || e.metaKey || e.altKey || e.shiftKey || e.button !== 0) {
		return;
	}

	var t = e.target;
	do {
		if (String(t.nodeName).toUpperCase() === 'A' && t.getAttribute('href') && isPreactElement(t)) {
			if (t.hasAttribute('native')) {
				return;
			}
			// if link is handled by the router, prevent browser defaults
			if (routeFromLink(t)) {
				return prevent(e);
			}
		}
	} while (t = t.parentNode);
}

var eventListenersInitialized = false;

function initEventListeners() {
	if (eventListenersInitialized) {
		return;
	}

	if (typeof addEventListener === 'function') {
		if (!customHistory) {
			addEventListener('popstate', function () {
				routeTo(getCurrentUrl());
			});
		}
		addEventListener('click', delegateLinkHandler);
	}
	eventListenersInitialized = true;
}

var preact_router_es_Router = function (Component$$1) {
	function Router(props) {
		Component$$1.call(this, props);
		if (props.history) {
			customHistory = props.history;
		}

		this.state = {
			url: props.url || getCurrentUrl()
		};

		initEventListeners();
	}

	if (Component$$1) Router.__proto__ = Component$$1;
	Router.prototype = Object.create(Component$$1 && Component$$1.prototype);
	Router.prototype.constructor = Router;

	Router.prototype.shouldComponentUpdate = function shouldComponentUpdate(props) {
		if (props.static !== true) {
			return true;
		}
		return props.url !== this.props.url || props.onChange !== this.props.onChange;
	};

	/** Check if the given URL can be matched against any children */
	Router.prototype.canRoute = function canRoute(url) {
		return this.getMatchingChildren(this.props.children, url, false).length > 0;
	};

	/** Re-render children with a new URL to match against. */
	Router.prototype.routeTo = function routeTo(url) {
		this._didRoute = false;
		this.setState({ url: url });

		// if we're in the middle of an update, don't synchronously re-route.
		if (this.updating) {
			return this.canRoute(url);
		}

		this.forceUpdate();
		return this._didRoute;
	};

	Router.prototype.componentWillMount = function componentWillMount() {
		ROUTERS.push(this);
		this.updating = true;
	};

	Router.prototype.componentDidMount = function componentDidMount() {
		var this$1 = this;

		if (customHistory) {
			this.unlisten = customHistory.listen(function (location) {
				this$1.routeTo("" + (location.pathname || '') + (location.search || ''));
			});
		}
		this.updating = false;
	};

	Router.prototype.componentWillUnmount = function componentWillUnmount() {
		if (typeof this.unlisten === 'function') {
			this.unlisten();
		}
		ROUTERS.splice(ROUTERS.indexOf(this), 1);
	};

	Router.prototype.componentWillUpdate = function componentWillUpdate() {
		this.updating = true;
	};

	Router.prototype.componentDidUpdate = function componentDidUpdate() {
		this.updating = false;
	};

	Router.prototype.getMatchingChildren = function getMatchingChildren(children, url, invoke) {
		return children.filter(prepareVNodeForRanking).sort(pathRankSort).map(function (vnode) {
			var matches = exec(url, vnode.attributes.path, vnode.attributes);
			if (matches) {
				if (invoke !== false) {
					var newProps = { url: url, matches: matches };
					preact_router_es_assign(newProps, matches);
					delete newProps.ref;
					delete newProps.key;
					return Object(preact_min["cloneElement"])(vnode, newProps);
				}
				return vnode;
			}
		}).filter(Boolean);
	};

	Router.prototype.render = function render(ref, ref$1) {
		var children = ref.children;
		var onChange = ref.onChange;
		var url = ref$1.url;

		var active = this.getMatchingChildren(children, url, true);

		var current = active[0] || null;
		this._didRoute = !!current;

		var previous = this.previousUrl;
		if (url !== previous) {
			this.previousUrl = url;
			if (typeof onChange === 'function') {
				onChange({
					router: this,
					url: url,
					previous: previous,
					active: active,
					current: current
				});
			}
		}

		return current;
	};

	return Router;
}(preact_min["Component"]);

var preact_router_es_Link = function Link(props) {
	return Object(preact_min["h"])('a', preact_router_es_assign({ onClick: handleLinkClick }, props));
};

var preact_router_es_Route = function Route(props) {
	return Object(preact_min["h"])(props.component, props);
};

preact_router_es_Router.subscribers = subscribers;
preact_router_es_Router.getCurrentUrl = getCurrentUrl;
preact_router_es_Router.route = route;
preact_router_es_Router.Router = preact_router_es_Router;
preact_router_es_Router.Route = preact_router_es_Route;
preact_router_es_Router.Link = preact_router_es_Link;

/* harmony default export */ var preact_router_es = (preact_router_es_Router);
//# sourceMappingURL=preact-router.es.js.map
// CONCATENATED MODULE: ../node_modules/@material/base/foundation.js
var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @template A
 */
var MDCFoundation = function () {
  _createClass(MDCFoundation, null, [{
    key: "cssClasses",

    /** @return enum{cssClasses} */
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports every
      // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
      return {};
    }

    /** @return enum{strings} */

  }, {
    key: "strings",
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
      return {};
    }

    /** @return enum{numbers} */

  }, {
    key: "numbers",
    get: function get() {
      // Classes extending MDCFoundation should implement this method to return an object which exports all
      // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
      return {};
    }

    /** @return {!Object} */

  }, {
    key: "defaultAdapter",
    get: function get() {
      // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
      // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
      // validation.
      return {};
    }

    /**
     * @param {A=} adapter
     */

  }]);

  function MDCFoundation() {
    var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, MDCFoundation);

    /** @protected {!A} */
    this.adapter_ = adapter;
  }

  MDCFoundation.prototype.init = function init() {
    // Subclasses should override this method to perform initialization routines (registering events, etc.)
  };

  MDCFoundation.prototype.destroy = function destroy() {
    // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
  };

  return MDCFoundation;
}();

/* harmony default export */ var foundation = (MDCFoundation);
// CONCATENATED MODULE: ../node_modules/@material/base/component.js
function component__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * @template F
 */

var component_MDCComponent = function () {
  /**
   * @param {!Element} root
   * @return {!MDCComponent}
   */
  MDCComponent.attachTo = function attachTo(root) {
    // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
    // returns an instantiated component with its root set to that element. Also note that in the cases of
    // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
    // from getDefaultFoundation().
    return new MDCComponent(root, new foundation());
  };

  /**
   * @param {!Element} root
   * @param {F=} foundation
   * @param {...?} args
   */


  function MDCComponent(root) {
    var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

    component__classCallCheck(this, MDCComponent);

    /** @protected {!Element} */
    this.root_ = root;

    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    this.initialize.apply(this, args);
    // Note that we initialize foundation here and not within the constructor's default param so that
    // this.root_ is defined and can be used within the foundation class.
    /** @protected {!F} */
    this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
    this.foundation_.init();
    this.initialSyncWithDOM();
  }

  MDCComponent.prototype.initialize = function initialize() /* ...args */{}
  // Subclasses can override this to do any additional setup work that would be considered part of a
  // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
  // initialized. Any additional arguments besides root and foundation will be passed in here.


  /**
   * @return {!F} foundation
   */
  ;

  MDCComponent.prototype.getDefaultFoundation = function getDefaultFoundation() {
    // Subclasses must override this method to return a properly configured foundation class for the
    // component.
    throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
  };

  MDCComponent.prototype.initialSyncWithDOM = function initialSyncWithDOM() {
    // Subclasses should override this method if they need to perform work to synchronize with a host DOM
    // object. An example of this would be a form control wrapper that needs to synchronize its internal state
    // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
    // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
  };

  MDCComponent.prototype.destroy = function destroy() {
    // Subclasses may implement this method to release any resources / deregister any listeners they have
    // attached. An example of this might be deregistering a resize event from the window object.
    this.foundation_.destroy();
  };

  /**
   * Wrapper method to add an event listener to the component's root element. This is most useful when
   * listening for custom events.
   * @param {string} evtType
   * @param {!Function} handler
   */


  MDCComponent.prototype.listen = function listen(evtType, handler) {
    this.root_.addEventListener(evtType, handler);
  };

  /**
   * Wrapper method to remove an event listener to the component's root element. This is most useful when
   * unlistening for custom events.
   * @param {string} evtType
   * @param {!Function} handler
   */


  MDCComponent.prototype.unlisten = function unlisten(evtType, handler) {
    this.root_.removeEventListener(evtType, handler);
  };

  /**
   * Fires a cross-browser-compatible custom event from the component root of the given type,
   * with the given data.
   * @param {string} evtType
   * @param {!Object} evtData
   * @param {boolean=} shouldBubble
   */


  MDCComponent.prototype.emit = function emit(evtType, evtData) {
    var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    var evt = void 0;
    if (typeof CustomEvent === 'function') {
      evt = new CustomEvent(evtType, {
        detail: evtData,
        bubbles: shouldBubble
      });
    } else {
      evt = document.createEvent('CustomEvent');
      evt.initCustomEvent(evtType, shouldBubble, false, evtData);
    }

    this.root_.dispatchEvent(evt);
  };

  return MDCComponent;
}();

/* harmony default export */ var base_component = (component_MDCComponent);
// CONCATENATED MODULE: ../node_modules/@material/ripple/adapter.js
function adapter__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint no-unused-vars: [2, {"args": "none"}] */

/**
 * Adapter for MDC Ripple. Provides an interface for managing
 * - classes
 * - dom
 * - CSS variables
 * - position
 * - dimensions
 * - scroll position
 * - event handlers
 * - unbounded, active and disabled states
 *
 * Additionally, provides type information for the adapter to the Closure
 * compiler.
 *
 * Implement this adapter for your framework of choice to delegate updates to
 * the component in your framework of choice. See architecture documentation
 * for more details.
 * https://github.com/material-components/material-components-web/blob/master/docs/architecture.md
 *
 * @record
 */
var MDCRippleAdapter = function () {
  function MDCRippleAdapter() {
    adapter__classCallCheck(this, MDCRippleAdapter);
  }

  /** @return {boolean} */
  MDCRippleAdapter.prototype.browserSupportsCssVars = function browserSupportsCssVars() {};

  /** @return {boolean} */


  MDCRippleAdapter.prototype.isUnbounded = function isUnbounded() {};

  /** @return {boolean} */


  MDCRippleAdapter.prototype.isSurfaceActive = function isSurfaceActive() {};

  /** @return {boolean} */


  MDCRippleAdapter.prototype.isSurfaceDisabled = function isSurfaceDisabled() {};

  /** @param {string} className */


  MDCRippleAdapter.prototype.addClass = function addClass(className) {};

  /** @param {string} className */


  MDCRippleAdapter.prototype.removeClass = function removeClass(className) {};

  /**
   * @param {string} evtType
   * @param {!Function} handler
   */


  MDCRippleAdapter.prototype.registerInteractionHandler = function registerInteractionHandler(evtType, handler) {};

  /**
   * @param {string} evtType
   * @param {!Function} handler
   */


  MDCRippleAdapter.prototype.deregisterInteractionHandler = function deregisterInteractionHandler(evtType, handler) {};

  /**
   * @param {!Function} handler
   */


  MDCRippleAdapter.prototype.registerResizeHandler = function registerResizeHandler(handler) {};

  /**
   * @param {!Function} handler
   */


  MDCRippleAdapter.prototype.deregisterResizeHandler = function deregisterResizeHandler(handler) {};

  /**
   * @param {string} varName
   * @param {?number|string} value
   */


  MDCRippleAdapter.prototype.updateCssVariable = function updateCssVariable(varName, value) {};

  /** @return {!ClientRect} */


  MDCRippleAdapter.prototype.computeBoundingRect = function computeBoundingRect() {};

  /** @return {{x: number, y: number}} */


  MDCRippleAdapter.prototype.getWindowPageOffset = function getWindowPageOffset() {};

  return MDCRippleAdapter;
}();

/* harmony default export */ var ripple_adapter = (MDCRippleAdapter);
// CONCATENATED MODULE: ../node_modules/@material/ripple/constants.js
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var cssClasses = {
  // Ripple is a special case where the "root" component is really a "mixin" of sorts,
  // given that it's an 'upgrade' to an existing component. That being said it is the root
  // CSS class that all other CSS classes derive from.
  ROOT: 'mdc-ripple-upgraded',
  UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
  BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
  BG_ACTIVE_FILL: 'mdc-ripple-upgraded--background-active-fill',
  FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
  FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
};

var strings = {
  VAR_FG_SIZE: '--mdc-ripple-fg-size',
  VAR_LEFT: '--mdc-ripple-left',
  VAR_TOP: '--mdc-ripple-top',
  VAR_FG_SCALE: '--mdc-ripple-fg-scale',
  VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
  VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
};

var numbers = {
  PADDING: 10,
  INITIAL_ORIGIN_SCALE: 0.6,
  DEACTIVATION_TIMEOUT_MS: 300,
  FG_DEACTIVATION_MS: 83
};


// CONCATENATED MODULE: ../node_modules/@material/ripple/util.js
/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
 * @private {boolean|undefined}
 */
var supportsCssVariables_ = void 0;

/**
 * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
 * @private {boolean|undefined}
 */
var supportsPassive_ = void 0;

/**
 * @param {!Window} windowObj
 * @return {boolean}
 */
function detectEdgePseudoVarBug(windowObj) {
  // Detect versions of Edge with buggy var() support
  // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
  var document = windowObj.document;
  var node = document.createElement('div');
  node.className = 'mdc-ripple-surface--test-edge-var-bug';
  document.body.appendChild(node);

  // The bug exists if ::before style ends up propagating to the parent element.
  // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
  // but Firefox is known to support CSS custom properties correctly.
  // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397
  var computedStyle = windowObj.getComputedStyle(node);
  var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
  node.remove();
  return hasPseudoVarBug;
}

/**
 * @param {!Window} windowObj
 * @param {boolean=} forceRefresh
 * @return {boolean|undefined}
 */

function supportsCssVariables(windowObj) {
  var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {
    return supportsCssVariables_;
  }

  var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';
  if (!supportsFunctionPresent) {
    return;
  }

  var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes');
  // See: https://bugs.webkit.org/show_bug.cgi?id=154669
  // See: README section on Safari
  var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

  if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
    supportsCssVariables_ = !detectEdgePseudoVarBug(windowObj);
  } else {
    supportsCssVariables_ = false;
  }
  return supportsCssVariables_;
}

//
/**
 * Determine whether the current browser supports passive event listeners, and if so, use them.
 * @param {!Window=} globalObj
 * @param {boolean=} forceRefresh
 * @return {boolean|{passive: boolean}}
 */
function applyPassive() {
  var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
  var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (supportsPassive_ === undefined || forceRefresh) {
    var isSupported = false;
    try {
      globalObj.document.addEventListener('test', null, { get passive() {
          isSupported = true;
        } });
    } catch (e) {}

    supportsPassive_ = isSupported;
  }

  return supportsPassive_ ? { passive: true } : false;
}

/**
 * @param {!Object} HTMLElementPrototype
 * @return {!Array<string>}
 */
function getMatchesProperty(HTMLElementPrototype) {
  return ['webkitMatchesSelector', 'msMatchesSelector', 'matches'].filter(function (p) {
    return p in HTMLElementPrototype;
  }).pop();
}

/**
 * @param {!Event} ev
 * @param {!{x: number, y: number}} pageOffset
 * @param {!ClientRect} clientRect
 * @return {!{x: number, y: number}}
 */
function getNormalizedEventCoords(ev, pageOffset, clientRect) {
  var x = pageOffset.x,
      y = pageOffset.y;

  var documentX = x + clientRect.left;
  var documentY = y + clientRect.top;

  var normalizedX = void 0;
  var normalizedY = void 0;
  // Determine touch point relative to the ripple container.
  if (ev.type === 'touchstart') {
    normalizedX = ev.changedTouches[0].pageX - documentX;
    normalizedY = ev.changedTouches[0].pageY - documentY;
  } else {
    normalizedX = ev.pageX - documentX;
    normalizedY = ev.pageY - documentY;
  }

  return { x: normalizedX, y: normalizedY };
}


// CONCATENATED MODULE: ../node_modules/@material/ripple/foundation.js
var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var foundation__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function foundation__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * @typedef {!{
 *   isActivated: (boolean|undefined),
 *   hasDeactivationUXRun: (boolean|undefined),
 *   wasActivatedByPointer: (boolean|undefined),
 *   wasElementMadeActive: (boolean|undefined),
 *   activationStartTime: (number|undefined),
 *   activationEvent: Event,
 *   isProgrammatic: (boolean|undefined)
 * }}
 */
var ActivationStateType = void 0;

/**
 * @typedef {!{
 *   activate: (string|undefined),
 *   deactivate: (string|undefined),
 *   focus: (string|undefined),
 *   blur: (string|undefined)
 * }}
 */
var ListenerInfoType = void 0;

/**
 * @typedef {!{
 *   activate: function(!Event),
 *   deactivate: function(!Event),
 *   focus: function(),
 *   blur: function()
 * }}
 */
var ListenersType = void 0;

/**
 * @typedef {!{
 *   x: number,
 *   y: number
 * }}
 */
var PointType = void 0;

/**
 * @enum {string}
 */
var DEACTIVATION_ACTIVATION_PAIRS = {
  mouseup: 'mousedown',
  pointerup: 'pointerdown',
  touchend: 'touchstart',
  keyup: 'keydown',
  blur: 'focus'
};

/**
 * @extends {MDCFoundation<!MDCRippleAdapter>}
 */

var foundation_MDCRippleFoundation = function (_MDCFoundation) {
  _inherits(MDCRippleFoundation, _MDCFoundation);

  foundation__createClass(MDCRippleFoundation, null, [{
    key: 'cssClasses',
    get: function get() {
      return cssClasses;
    }
  }, {
    key: 'strings',
    get: function get() {
      return strings;
    }
  }, {
    key: 'numbers',
    get: function get() {
      return numbers;
    }
  }, {
    key: 'defaultAdapter',
    get: function get() {
      return {
        browserSupportsCssVars: function browserSupportsCssVars() /* boolean - cached */{},
        isUnbounded: function isUnbounded() /* boolean */{},
        isSurfaceActive: function isSurfaceActive() /* boolean */{},
        isSurfaceDisabled: function isSurfaceDisabled() /* boolean */{},
        addClass: function addClass() /* className: string */{},
        removeClass: function removeClass() /* className: string */{},
        registerInteractionHandler: function registerInteractionHandler() /* evtType: string, handler: EventListener */{},
        deregisterInteractionHandler: function deregisterInteractionHandler() /* evtType: string, handler: EventListener */{},
        registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
        deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
        updateCssVariable: function updateCssVariable() /* varName: string, value: string */{},
        computeBoundingRect: function computeBoundingRect() /* ClientRect */{},
        getWindowPageOffset: function getWindowPageOffset() /* {x: number, y: number} */{}
      };
    }
  }]);

  function MDCRippleFoundation(adapter) {
    foundation__classCallCheck(this, MDCRippleFoundation);

    /** @private {number} */
    var _this = _possibleConstructorReturn(this, _MDCFoundation.call(this, _extends(MDCRippleFoundation.defaultAdapter, adapter)));

    _this.layoutFrame_ = 0;

    /** @private {!ClientRect} */
    _this.frame_ = /** @type {!ClientRect} */{ width: 0, height: 0 };

    /** @private {!ActivationStateType} */
    _this.activationState_ = _this.defaultActivationState_();

    /** @private {number} */
    _this.xfDuration_ = 0;

    /** @private {number} */
    _this.initialSize_ = 0;

    /** @private {number} */
    _this.maxRadius_ = 0;

    /** @private {!Array<{ListenerInfoType}>} */
    _this.listenerInfos_ = [{ activate: 'touchstart', deactivate: 'touchend' }, { activate: 'pointerdown', deactivate: 'pointerup' }, { activate: 'mousedown', deactivate: 'mouseup' }, { activate: 'keydown', deactivate: 'keyup' }, { focus: 'focus', blur: 'blur' }];

    /** @private {!ListenersType} */
    _this.listeners_ = {
      activate: function activate(e) {
        return _this.activate_(e);
      },
      deactivate: function deactivate(e) {
        return _this.deactivate_(e);
      },
      focus: function focus() {
        return requestAnimationFrame(function () {
          return _this.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
        });
      },
      blur: function blur() {
        return requestAnimationFrame(function () {
          return _this.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
        });
      }
    };

    /** @private {!Function} */
    _this.resizeHandler_ = function () {
      return _this.layout();
    };

    /** @private {!{left: number, top:number}} */
    _this.unboundedCoords_ = {
      left: 0,
      top: 0
    };

    /** @private {number} */
    _this.fgScale_ = 0;

    /** @private {number} */
    _this.activationTimer_ = 0;

    /** @private {number} */
    _this.fgDeactivationRemovalTimer_ = 0;

    /** @private {boolean} */
    _this.activationAnimationHasEnded_ = false;

    /** @private {!Function} */
    _this.activationTimerCallback_ = function () {
      _this.activationAnimationHasEnded_ = true;
      _this.runDeactivationUXLogicIfReady_();
    };
    return _this;
  }

  /**
   * We compute this property so that we are not querying information about the client
   * until the point in time where the foundation requests it. This prevents scenarios where
   * client-side feature-detection may happen too early, such as when components are rendered on the server
   * and then initialized at mount time on the client.
   * @return {boolean}
   * @private
   */


  MDCRippleFoundation.prototype.isSupported_ = function isSupported_() {
    return this.adapter_.browserSupportsCssVars();
  };

  /**
   * @return {!ActivationStateType}
   */


  MDCRippleFoundation.prototype.defaultActivationState_ = function defaultActivationState_() {
    return {
      isActivated: false,
      hasDeactivationUXRun: false,
      wasActivatedByPointer: false,
      wasElementMadeActive: false,
      activationStartTime: 0,
      activationEvent: null,
      isProgrammatic: false
    };
  };

  MDCRippleFoundation.prototype.init = function init() {
    var _this2 = this;

    if (!this.isSupported_()) {
      return;
    }
    this.addEventListeners_();

    var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
        ROOT = _MDCRippleFoundation$.ROOT,
        UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;

    requestAnimationFrame(function () {
      _this2.adapter_.addClass(ROOT);
      if (_this2.adapter_.isUnbounded()) {
        _this2.adapter_.addClass(UNBOUNDED);
      }
      _this2.layoutInternal_();
    });
  };

  /** @private */


  MDCRippleFoundation.prototype.addEventListeners_ = function addEventListeners_() {
    var _this3 = this;

    this.listenerInfos_.forEach(function (info) {
      Object.keys(info).forEach(function (k) {
        _this3.adapter_.registerInteractionHandler(info[k], _this3.listeners_[k]);
      });
    });
    this.adapter_.registerResizeHandler(this.resizeHandler_);
  };

  /**
   * @param {Event} e
   * @private
   */


  MDCRippleFoundation.prototype.activate_ = function activate_(e) {
    var _this4 = this;

    if (this.adapter_.isSurfaceDisabled()) {
      return;
    }

    var activationState = this.activationState_;

    if (activationState.isActivated) {
      return;
    }

    activationState.isActivated = true;
    activationState.isProgrammatic = e === null;
    activationState.activationEvent = e;
    activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown';
    activationState.activationStartTime = Date.now();

    requestAnimationFrame(function () {
      // This needs to be wrapped in an rAF call b/c web browsers
      // report active states inconsistently when they're called within
      // event handling code:
      // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
      // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
      activationState.wasElementMadeActive = e && e.type === 'keydown' ? _this4.adapter_.isSurfaceActive() : true;
      if (activationState.wasElementMadeActive) {
        _this4.animateActivation_();
      } else {
        // Reset activation state immediately if element was not made active.
        _this4.activationState_ = _this4.defaultActivationState_();
      }
    });
  };

  /**
   * @param {?Event=} event Optional event containing position information.
   */


  MDCRippleFoundation.prototype.activate = function activate() {
    var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    this.activate_(event);
  };

  /** @private */


  MDCRippleFoundation.prototype.animateActivation_ = function animateActivation_() {
    var _this5 = this;

    var _MDCRippleFoundation$2 = MDCRippleFoundation.strings,
        VAR_FG_TRANSLATE_START = _MDCRippleFoundation$2.VAR_FG_TRANSLATE_START,
        VAR_FG_TRANSLATE_END = _MDCRippleFoundation$2.VAR_FG_TRANSLATE_END;
    var _MDCRippleFoundation$3 = MDCRippleFoundation.cssClasses,
        BG_ACTIVE_FILL = _MDCRippleFoundation$3.BG_ACTIVE_FILL,
        FG_DEACTIVATION = _MDCRippleFoundation$3.FG_DEACTIVATION,
        FG_ACTIVATION = _MDCRippleFoundation$3.FG_ACTIVATION;
    var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;


    var translateStart = '';
    var translateEnd = '';

    if (!this.adapter_.isUnbounded()) {
      var _getFgTranslationCoor = this.getFgTranslationCoordinates_(),
          startPoint = _getFgTranslationCoor.startPoint,
          endPoint = _getFgTranslationCoor.endPoint;

      translateStart = startPoint.x + 'px, ' + startPoint.y + 'px';
      translateEnd = endPoint.x + 'px, ' + endPoint.y + 'px';
    }

    this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
    this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
    // Cancel any ongoing activation/deactivation animations
    clearTimeout(this.activationTimer_);
    clearTimeout(this.fgDeactivationRemovalTimer_);
    this.rmBoundedActivationClasses_();
    this.adapter_.removeClass(FG_DEACTIVATION);

    // Force layout in order to re-trigger the animation.
    this.adapter_.computeBoundingRect();
    this.adapter_.addClass(BG_ACTIVE_FILL);
    this.adapter_.addClass(FG_ACTIVATION);
    this.activationTimer_ = setTimeout(function () {
      return _this5.activationTimerCallback_();
    }, DEACTIVATION_TIMEOUT_MS);
  };

  /**
   * @private
   * @return {{startPoint: PointType, endPoint: PointType}}
   */


  MDCRippleFoundation.prototype.getFgTranslationCoordinates_ = function getFgTranslationCoordinates_() {
    var activationState = this.activationState_;
    var activationEvent = activationState.activationEvent,
        wasActivatedByPointer = activationState.wasActivatedByPointer;


    var startPoint = void 0;
    if (wasActivatedByPointer) {
      startPoint = getNormalizedEventCoords(
      /** @type {!Event} */activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
    } else {
      startPoint = {
        x: this.frame_.width / 2,
        y: this.frame_.height / 2
      };
    }
    // Center the element around the start point.
    startPoint = {
      x: startPoint.x - this.initialSize_ / 2,
      y: startPoint.y - this.initialSize_ / 2
    };

    var endPoint = {
      x: this.frame_.width / 2 - this.initialSize_ / 2,
      y: this.frame_.height / 2 - this.initialSize_ / 2
    };

    return { startPoint: startPoint, endPoint: endPoint };
  };

  /** @private */


  MDCRippleFoundation.prototype.runDeactivationUXLogicIfReady_ = function runDeactivationUXLogicIfReady_() {
    var _this6 = this;

    var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
    var _activationState_ = this.activationState_,
        hasDeactivationUXRun = _activationState_.hasDeactivationUXRun,
        isActivated = _activationState_.isActivated;

    var activationHasEnded = hasDeactivationUXRun || !isActivated;
    if (activationHasEnded && this.activationAnimationHasEnded_) {
      this.rmBoundedActivationClasses_();
      this.adapter_.addClass(FG_DEACTIVATION);
      this.fgDeactivationRemovalTimer_ = setTimeout(function () {
        _this6.adapter_.removeClass(FG_DEACTIVATION);
      }, numbers.FG_DEACTIVATION_MS);
    }
  };

  /** @private */


  MDCRippleFoundation.prototype.rmBoundedActivationClasses_ = function rmBoundedActivationClasses_() {
    var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
        BG_ACTIVE_FILL = _MDCRippleFoundation$4.BG_ACTIVE_FILL,
        FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;

    this.adapter_.removeClass(BG_ACTIVE_FILL);
    this.adapter_.removeClass(FG_ACTIVATION);
    this.activationAnimationHasEnded_ = false;
    this.adapter_.computeBoundingRect();
  };

  /**
   * @param {Event} e
   * @private
   */


  MDCRippleFoundation.prototype.deactivate_ = function deactivate_(e) {
    var _this7 = this;

    var activationState = this.activationState_;
    // This can happen in scenarios such as when you have a keyup event that blurs the element.

    if (!activationState.isActivated) {
      return;
    }
    // Programmatic deactivation.
    if (activationState.isProgrammatic) {
      var evtObject = null;
      var _state = /** @type {!ActivationStateType} */_extends({}, activationState);
      requestAnimationFrame(function () {
        return _this7.animateDeactivation_(evtObject, _state);
      });
      this.activationState_ = this.defaultActivationState_();
      return;
    }

    var actualActivationType = DEACTIVATION_ACTIVATION_PAIRS[e.type];
    var expectedActivationType = activationState.activationEvent.type;
    // NOTE: Pointer events are tricky - https://patrickhlauke.github.io/touch/tests/results/
    // Essentially, what we need to do here is decouple the deactivation UX from the actual
    // deactivation state itself. This way, touch/pointer events in sequence do not trample one
    // another.
    var needsDeactivationUX = actualActivationType === expectedActivationType;
    var needsActualDeactivation = needsDeactivationUX;
    if (activationState.wasActivatedByPointer) {
      needsActualDeactivation = e.type === 'mouseup';
    }

    var state = /** @type {!ActivationStateType} */_extends({}, activationState);
    requestAnimationFrame(function () {
      if (needsDeactivationUX) {
        _this7.activationState_.hasDeactivationUXRun = true;
        _this7.animateDeactivation_(e, state);
      }

      if (needsActualDeactivation) {
        _this7.activationState_ = _this7.defaultActivationState_();
      }
    });
  };

  /**
   * @param {?Event=} event Optional event containing position information.
   */


  MDCRippleFoundation.prototype.deactivate = function deactivate() {
    var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    this.deactivate_(event);
  };

  /**
   * @param {Event} e
   * @param {!ActivationStateType} options
   * @private
   */


  MDCRippleFoundation.prototype.animateDeactivation_ = function animateDeactivation_(e, _ref) {
    var wasActivatedByPointer = _ref.wasActivatedByPointer,
        wasElementMadeActive = _ref.wasElementMadeActive;
    var BG_FOCUSED = MDCRippleFoundation.cssClasses.BG_FOCUSED;

    if (wasActivatedByPointer || wasElementMadeActive) {
      // Remove class left over by element being focused
      this.adapter_.removeClass(BG_FOCUSED);
      this.runDeactivationUXLogicIfReady_();
    }
  };

  MDCRippleFoundation.prototype.destroy = function destroy() {
    var _this8 = this;

    if (!this.isSupported_()) {
      return;
    }
    this.removeEventListeners_();

    var _MDCRippleFoundation$5 = MDCRippleFoundation.cssClasses,
        ROOT = _MDCRippleFoundation$5.ROOT,
        UNBOUNDED = _MDCRippleFoundation$5.UNBOUNDED;

    requestAnimationFrame(function () {
      _this8.adapter_.removeClass(ROOT);
      _this8.adapter_.removeClass(UNBOUNDED);
      _this8.removeCssVars_();
    });
  };

  /** @private */


  MDCRippleFoundation.prototype.removeEventListeners_ = function removeEventListeners_() {
    var _this9 = this;

    this.listenerInfos_.forEach(function (info) {
      Object.keys(info).forEach(function (k) {
        _this9.adapter_.deregisterInteractionHandler(info[k], _this9.listeners_[k]);
      });
    });
    this.adapter_.deregisterResizeHandler(this.resizeHandler_);
  };

  /** @private */


  MDCRippleFoundation.prototype.removeCssVars_ = function removeCssVars_() {
    var _this10 = this;

    var strings = MDCRippleFoundation.strings;

    Object.keys(strings).forEach(function (k) {
      if (k.indexOf('VAR_') === 0) {
        _this10.adapter_.updateCssVariable(strings[k], null);
      }
    });
  };

  MDCRippleFoundation.prototype.layout = function layout() {
    var _this11 = this;

    if (this.layoutFrame_) {
      cancelAnimationFrame(this.layoutFrame_);
    }
    this.layoutFrame_ = requestAnimationFrame(function () {
      _this11.layoutInternal_();
      _this11.layoutFrame_ = 0;
    });
  };

  /** @private */


  MDCRippleFoundation.prototype.layoutInternal_ = function layoutInternal_() {
    this.frame_ = this.adapter_.computeBoundingRect();

    var maxDim = Math.max(this.frame_.height, this.frame_.width);
    var surfaceDiameter = Math.sqrt(Math.pow(this.frame_.width, 2) + Math.pow(this.frame_.height, 2));

    // 60% of the largest dimension of the surface
    this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;

    // Diameter of the surface + 10px
    this.maxRadius_ = surfaceDiameter + MDCRippleFoundation.numbers.PADDING;
    this.fgScale_ = this.maxRadius_ / this.initialSize_;
    this.xfDuration_ = 1000 * Math.sqrt(this.maxRadius_ / 1024);
    this.updateLayoutCssVars_();
  };

  /** @private */


  MDCRippleFoundation.prototype.updateLayoutCssVars_ = function updateLayoutCssVars_() {
    var _MDCRippleFoundation$6 = MDCRippleFoundation.strings,
        VAR_FG_SIZE = _MDCRippleFoundation$6.VAR_FG_SIZE,
        VAR_LEFT = _MDCRippleFoundation$6.VAR_LEFT,
        VAR_TOP = _MDCRippleFoundation$6.VAR_TOP,
        VAR_FG_SCALE = _MDCRippleFoundation$6.VAR_FG_SCALE;


    this.adapter_.updateCssVariable(VAR_FG_SIZE, this.initialSize_ + 'px');
    this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

    if (this.adapter_.isUnbounded()) {
      this.unboundedCoords_ = {
        left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
        top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
      };

      this.adapter_.updateCssVariable(VAR_LEFT, this.unboundedCoords_.left + 'px');
      this.adapter_.updateCssVariable(VAR_TOP, this.unboundedCoords_.top + 'px');
    }
  };

  return MDCRippleFoundation;
}(foundation);

/* harmony default export */ var ripple_foundation = (foundation_MDCRippleFoundation);
// CONCATENATED MODULE: ../node_modules/@material/ripple/index.js
var ripple__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function ripple__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ripple__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function ripple__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * @license
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * @extends MDCComponent<!MDCRippleFoundation>
 */

var ripple_MDCRipple = function (_MDCComponent) {
  ripple__inherits(MDCRipple, _MDCComponent);

  /** @param {...?} args */
  function MDCRipple() {
    ripple__classCallCheck(this, MDCRipple);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    /** @type {boolean} */
    var _this = ripple__possibleConstructorReturn(this, _MDCComponent.call.apply(_MDCComponent, [this].concat(args)));

    _this.disabled = false;

    /** @private {boolean} */
    _this.unbounded_;
    return _this;
  }

  /**
   * @param {!Element} root
   * @param {{isUnbounded: (boolean|undefined)}=} options
   * @return {!MDCRipple}
   */


  MDCRipple.attachTo = function attachTo(root) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$isUnbounded = _ref.isUnbounded,
        isUnbounded = _ref$isUnbounded === undefined ? undefined : _ref$isUnbounded;

    var ripple = new MDCRipple(root);
    // Only override unbounded behavior if option is explicitly specified
    if (isUnbounded !== undefined) {
      ripple.unbounded = /** @type {boolean} */isUnbounded;
    }
    return ripple;
  };

  /**
   * @param {!RippleCapableSurface} instance
   * @return {!MDCRippleAdapter}
   */


  MDCRipple.createAdapter = function createAdapter(instance) {
    var MATCHES = getMatchesProperty(HTMLElement.prototype);

    return {
      browserSupportsCssVars: function browserSupportsCssVars() {
        return supportsCssVariables(window);
      },
      isUnbounded: function isUnbounded() {
        return instance.unbounded;
      },
      isSurfaceActive: function isSurfaceActive() {
        return instance.root_[MATCHES](':active');
      },
      isSurfaceDisabled: function isSurfaceDisabled() {
        return instance.disabled;
      },
      addClass: function addClass(className) {
        return instance.root_.classList.add(className);
      },
      removeClass: function removeClass(className) {
        return instance.root_.classList.remove(className);
      },
      registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
        return instance.root_.addEventListener(evtType, handler, applyPassive());
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
        return instance.root_.removeEventListener(evtType, handler, applyPassive());
      },
      registerResizeHandler: function registerResizeHandler(handler) {
        return window.addEventListener('resize', handler);
      },
      deregisterResizeHandler: function deregisterResizeHandler(handler) {
        return window.removeEventListener('resize', handler);
      },
      updateCssVariable: function updateCssVariable(varName, value) {
        return instance.root_.style.setProperty(varName, value);
      },
      computeBoundingRect: function computeBoundingRect() {
        return instance.root_.getBoundingClientRect();
      },
      getWindowPageOffset: function getWindowPageOffset() {
        return { x: window.pageXOffset, y: window.pageYOffset };
      }
    };
  };

  /** @return {boolean} */


  MDCRipple.prototype.activate = function activate() {
    this.foundation_.activate();
  };

  MDCRipple.prototype.deactivate = function deactivate() {
    this.foundation_.deactivate();
  };

  MDCRipple.prototype.layout = function layout() {
    this.foundation_.layout();
  };

  /** @return {!MDCRippleFoundation} */


  MDCRipple.prototype.getDefaultFoundation = function getDefaultFoundation() {
    return new ripple_foundation(MDCRipple.createAdapter(this));
  };

  MDCRipple.prototype.initialSyncWithDOM = function initialSyncWithDOM() {
    this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
  };

  ripple__createClass(MDCRipple, [{
    key: 'unbounded',
    get: function get() {
      return this.unbounded_;
    }

    /** @param {boolean} unbounded */
    ,
    set: function set(unbounded) {
      var UNBOUNDED = ripple_foundation.cssClasses.UNBOUNDED;

      this.unbounded_ = Boolean(unbounded);
      if (this.unbounded_) {
        this.root_.classList.add(UNBOUNDED);
      } else {
        this.root_.classList.remove(UNBOUNDED);
      }
    }
  }]);

  return MDCRipple;
}(base_component);

/**
 * See Material Design spec for more details on when to use ripples.
 * https://material.io/guidelines/motion/choreography.html#choreography-creation
 * @record
 */


var RippleCapableSurface = function RippleCapableSurface() {
  ripple__classCallCheck(this, RippleCapableSurface);
};

/** @protected {!Element} */


RippleCapableSurface.prototype.root_;

/**
 * Whether or not the ripple bleeds out of the bounds of the element.
 * @type {boolean|undefined}
 */
RippleCapableSurface.prototype.unbounded;

/**
 * Whether or not the ripple is attached to a disabled component.
 * @type {boolean|undefined}
 */
RippleCapableSurface.prototype.disabled;


// CONCATENATED MODULE: ../node_modules/preact-material-components/MaterialComponent.js
var MaterialComponent__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function MaterialComponent__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function MaterialComponent__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function MaterialComponent__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }




/**
 * Base class for every Material component in this package
 * NOTE: every component should add a ref by the name of `control` to its root dom for autoInit Properties
 *
 * @export
 * @class MaterialComponent
 * @extends {Component}
 */

var MaterialComponent_MaterialComponent = function (_Component) {
  MaterialComponent__inherits(MaterialComponent, _Component);

  function MaterialComponent() {
    MaterialComponent__classCallCheck(this, MaterialComponent);

    // Attributes inside this array will be check for boolean value true
    // and will be converted to mdc classes
    var _this = MaterialComponent__possibleConstructorReturn(this, _Component.call(this));

    _this._mdcProps = [];
    // This will again be used to add apt classname to the component
    _this.componentName = "";
    // The final class name given to the dom
    _this.classText = "";
    return _this;
  }

  MaterialComponent.prototype.attachRipple = function attachRipple() {
    if (this.props.ripple && this.control) {
      ripple_MDCRipple.attachTo(this.control);
    }
  };
  // Build the className


  MaterialComponent.prototype.buildClassName = function buildClassName(props) {
    this.classText = "mdc-" + this.componentName;
    for (var propKey in this.props) {
      if (this.props.hasOwnProperty(propKey)) {
        var prop = this.props[propKey];
        if (typeof prop === "boolean" && prop) {
          if (this._mdcProps.indexOf(propKey) !== -1) {
            this.classText += " mdc-" + this.componentName + "--" + propKey;
          }
        }
      }
    }
  };

  MaterialComponent.prototype.getClassName = function getClassName(element) {
    if (!element) {
      return "";
    }
    var attrs = element.attributes = element.attributes || {};
    var classText = this.classText;
    if (attrs.class) {
      classText += " " + attrs.class;
    }
    if (attrs.className && attrs.className !== attrs.class) {
      classText += " " + attrs.className;
    }
    return classText;
  };
  // Components must implement this method for their specific DOM structure


  MaterialComponent.prototype.materialDom = function materialDom(props) {
    return Object(preact_min["h"])("div", MaterialComponent__extends({}, props), props.children);
  };

  MaterialComponent.prototype.render = function render() {
    this.buildClassName();
    // Fetch a VNode
    var componentProps = this.props;
    if (componentProps.class) {
      // We delete class prop here so that any sub node's class doesn't get over-ridden from this
      delete componentProps.class;
    }
    var element = this.materialDom(componentProps);
    element.attributes = element.attributes || {};
    // Fix for className
    element.attributes.class = this.getClassName(element);
    element.attributes.className = this.getClassName(element);
    // Clean this shit of proxy attributes
    this._mdcProps.forEach(function (prop) {
      delete element.attributes[prop];
    });
    return element;
  };

  return MaterialComponent;
}(preact_min["Component"]);


// CONCATENATED MODULE: ../node_modules/@material/base/index.js
/**
 * @license
 * Copyright 2016 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





// CONCATENATED MODULE: ../node_modules/@material/toolbar/constants.js
/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var constants_cssClasses = {
  FIXED: 'mdc-toolbar--fixed',
  FIXED_LASTROW: 'mdc-toolbar--fixed-lastrow-only',
  FIXED_AT_LAST_ROW: 'mdc-toolbar--fixed-at-last-row',
  TOOLBAR_ROW_FLEXIBLE: 'mdc-toolbar--flexible',
  FLEXIBLE_DEFAULT_BEHAVIOR: 'mdc-toolbar--flexible-default-behavior',
  FLEXIBLE_MAX: 'mdc-toolbar--flexible-space-maximized',
  FLEXIBLE_MIN: 'mdc-toolbar--flexible-space-minimized'
};

var constants_strings = {
  TITLE_SELECTOR: '.mdc-toolbar__title',
  FIRST_ROW_SELECTOR: '.mdc-toolbar__row:first-child',
  CHANGE_EVENT: 'MDCToolbar:change'
};

var constants_numbers = {
  MAX_TITLE_SIZE: 2.125,
  MIN_TITLE_SIZE: 1.25,
  TOOLBAR_ROW_HEIGHT: 64,
  TOOLBAR_ROW_MOBILE_HEIGHT: 56,
  TOOLBAR_MOBILE_BREAKPOINT: 600
};
// CONCATENATED MODULE: ../node_modules/@material/toolbar/foundation.js
var foundation__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var toolbar_foundation__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function toolbar_foundation__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function foundation__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function foundation__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var foundation_MDCToolbarFoundation = function (_MDCFoundation) {
  foundation__inherits(MDCToolbarFoundation, _MDCFoundation);

  toolbar_foundation__createClass(MDCToolbarFoundation, null, [{
    key: 'cssClasses',
    get: function get() {
      return constants_cssClasses;
    }
  }, {
    key: 'strings',
    get: function get() {
      return constants_strings;
    }
  }, {
    key: 'numbers',
    get: function get() {
      return constants_numbers;
    }
  }, {
    key: 'defaultAdapter',
    get: function get() {
      return {
        hasClass: function hasClass() {
          return (/* className: string */ /* boolean */false
          );
        },
        addClass: function addClass() /* className: string */{},
        removeClass: function removeClass() /* className: string */{},
        registerScrollHandler: function registerScrollHandler() /* handler: EventListener */{},
        deregisterScrollHandler: function deregisterScrollHandler() /* handler: EventListener */{},
        registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
        deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
        getViewportWidth: function getViewportWidth() {
          return (/* number */0
          );
        },
        getViewportScrollY: function getViewportScrollY() {
          return (/* number */0
          );
        },
        getOffsetHeight: function getOffsetHeight() {
          return (/* number */0
          );
        },
        getFirstRowElementOffsetHeight: function getFirstRowElementOffsetHeight() {
          return (/* number */0
          );
        },
        notifyChange: function notifyChange() /* evtData: {flexibleExpansionRatio: number} */{},
        setStyle: function setStyle() /* property: string, value: string */{},
        setStyleForTitleElement: function setStyleForTitleElement() /* property: string, value: string */{},
        setStyleForFlexibleRowElement: function setStyleForFlexibleRowElement() /* property: string, value: string */{},
        setStyleForFixedAdjustElement: function setStyleForFixedAdjustElement() /* property: string, value: string */{}
      };
    }
  }]);

  function MDCToolbarFoundation(adapter) {
    toolbar_foundation__classCallCheck(this, MDCToolbarFoundation);

    var _this = foundation__possibleConstructorReturn(this, _MDCFoundation.call(this, foundation__extends(MDCToolbarFoundation.defaultAdapter, adapter)));

    _this.resizeHandler_ = function () {
      return _this.checkRowHeight_();
    };
    _this.scrollHandler_ = function () {
      return _this.updateToolbarStyles_();
    };
    _this.checkRowHeightFrame_ = 0;
    _this.scrollFrame_ = 0;
    _this.executedLastChange_ = false;

    _this.calculations_ = {
      toolbarRowHeight: 0,
      // Calculated Height ratio. We use ratio to calculate corresponding heights in resize event.
      toolbarRatio: 0, // The ratio of toolbar height to row height
      flexibleExpansionRatio: 0, // The ratio of flexible space height to row height
      maxTranslateYRatio: 0, // The ratio of max toolbar move up distance to row height
      scrollThresholdRatio: 0, // The ratio of max scrollTop that we should listen to to row height
      // Derived Heights based on the above key ratios.
      toolbarHeight: 0,
      flexibleExpansionHeight: 0, // Flexible row minus toolbar height (derived)
      maxTranslateYDistance: 0, // When toolbar only fix last row (derived)
      scrollThreshold: 0
    };
    // Toolbar fixed behavior
    // If toolbar is fixed
    _this.fixed_ = false;
    // If fixed is targeted only at the last row
    _this.fixedLastrow_ = false;
    // Toolbar flexible behavior
    // If the first row is flexible
    _this.hasFlexibleRow_ = false;
    // If use the default behavior
    _this.useFlexDefaultBehavior_ = false;
    return _this;
  }

  MDCToolbarFoundation.prototype.init = function init() {
    this.fixed_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.FIXED);
    this.fixedLastrow_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.FIXED_LASTROW) & this.fixed_;
    this.hasFlexibleRow_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.TOOLBAR_ROW_FLEXIBLE);
    if (this.hasFlexibleRow_) {
      this.useFlexDefaultBehavior_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_DEFAULT_BEHAVIOR);
    }
    this.initKeyRatio_();
    this.setKeyHeights_();
    this.adapter_.registerResizeHandler(this.resizeHandler_);
    this.adapter_.registerScrollHandler(this.scrollHandler_);
  };

  MDCToolbarFoundation.prototype.destroy = function destroy() {
    this.adapter_.deregisterResizeHandler(this.resizeHandler_);
    this.adapter_.deregisterScrollHandler(this.scrollHandler_);
  };

  MDCToolbarFoundation.prototype.updateAdjustElementStyles = function updateAdjustElementStyles() {
    if (this.fixed_) {
      this.adapter_.setStyleForFixedAdjustElement('margin-top', this.calculations_.toolbarHeight + 'px');
    }
  };

  MDCToolbarFoundation.prototype.getFlexibleExpansionRatio_ = function getFlexibleExpansionRatio_(scrollTop) {
    // To prevent division by zero when there is no flexibleExpansionHeight
    var delta = 0.0001;
    return Math.max(0, 1 - scrollTop / (this.calculations_.flexibleExpansionHeight + delta));
  };

  MDCToolbarFoundation.prototype.checkRowHeight_ = function checkRowHeight_() {
    var _this2 = this;

    cancelAnimationFrame(this.checkRowHeightFrame_);
    this.checkRowHeightFrame_ = requestAnimationFrame(function () {
      return _this2.setKeyHeights_();
    });
  };

  MDCToolbarFoundation.prototype.setKeyHeights_ = function setKeyHeights_() {
    var newToolbarRowHeight = this.getRowHeight_();
    if (newToolbarRowHeight !== this.calculations_.toolbarRowHeight) {
      this.calculations_.toolbarRowHeight = newToolbarRowHeight;
      this.calculations_.toolbarHeight = this.calculations_.toolbarRatio * this.calculations_.toolbarRowHeight;
      this.calculations_.flexibleExpansionHeight = this.calculations_.flexibleExpansionRatio * this.calculations_.toolbarRowHeight;
      this.calculations_.maxTranslateYDistance = this.calculations_.maxTranslateYRatio * this.calculations_.toolbarRowHeight;
      this.calculations_.scrollThreshold = this.calculations_.scrollThresholdRatio * this.calculations_.toolbarRowHeight;
      this.updateAdjustElementStyles();
      this.updateToolbarStyles_();
    }
  };

  MDCToolbarFoundation.prototype.updateToolbarStyles_ = function updateToolbarStyles_() {
    var _this3 = this;

    cancelAnimationFrame(this.scrollFrame_);
    this.scrollFrame_ = requestAnimationFrame(function () {
      var scrollTop = _this3.adapter_.getViewportScrollY();
      var hasScrolledOutOfThreshold = _this3.scrolledOutOfThreshold_(scrollTop);

      if (hasScrolledOutOfThreshold && _this3.executedLastChange_) {
        return;
      }

      var flexibleExpansionRatio = _this3.getFlexibleExpansionRatio_(scrollTop);

      _this3.updateToolbarFlexibleState_(flexibleExpansionRatio);
      if (_this3.fixedLastrow_) {
        _this3.updateToolbarFixedState_(scrollTop);
      }
      if (_this3.hasFlexibleRow_) {
        _this3.updateFlexibleRowElementStyles_(flexibleExpansionRatio);
      }
      _this3.executedLastChange_ = hasScrolledOutOfThreshold;
      _this3.adapter_.notifyChange({ flexibleExpansionRatio: flexibleExpansionRatio });
    });
  };

  MDCToolbarFoundation.prototype.scrolledOutOfThreshold_ = function scrolledOutOfThreshold_(scrollTop) {
    return scrollTop > this.calculations_.scrollThreshold;
  };

  MDCToolbarFoundation.prototype.initKeyRatio_ = function initKeyRatio_() {
    var toolbarRowHeight = this.getRowHeight_();
    var firstRowMaxRatio = this.adapter_.getFirstRowElementOffsetHeight() / toolbarRowHeight;
    this.calculations_.toolbarRatio = this.adapter_.getOffsetHeight() / toolbarRowHeight;
    this.calculations_.flexibleExpansionRatio = firstRowMaxRatio - 1;
    this.calculations_.maxTranslateYRatio = this.fixedLastrow_ ? this.calculations_.toolbarRatio - firstRowMaxRatio : 0;
    this.calculations_.scrollThresholdRatio = (this.fixedLastrow_ ? this.calculations_.toolbarRatio : firstRowMaxRatio) - 1;
  };

  MDCToolbarFoundation.prototype.getRowHeight_ = function getRowHeight_() {
    var breakpoint = MDCToolbarFoundation.numbers.TOOLBAR_MOBILE_BREAKPOINT;
    return this.adapter_.getViewportWidth() < breakpoint ? MDCToolbarFoundation.numbers.TOOLBAR_ROW_MOBILE_HEIGHT : MDCToolbarFoundation.numbers.TOOLBAR_ROW_HEIGHT;
  };

  MDCToolbarFoundation.prototype.updateToolbarFlexibleState_ = function updateToolbarFlexibleState_(flexibleExpansionRatio) {
    this.adapter_.removeClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MAX);
    this.adapter_.removeClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MIN);
    if (flexibleExpansionRatio === 1) {
      this.adapter_.addClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MAX);
    } else if (flexibleExpansionRatio === 0) {
      this.adapter_.addClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MIN);
    }
  };

  MDCToolbarFoundation.prototype.updateToolbarFixedState_ = function updateToolbarFixedState_(scrollTop) {
    var translateDistance = Math.max(0, Math.min(scrollTop - this.calculations_.flexibleExpansionHeight, this.calculations_.maxTranslateYDistance));
    this.adapter_.setStyle('transform', 'translateY(' + -translateDistance + 'px)');

    if (translateDistance === this.calculations_.maxTranslateYDistance) {
      this.adapter_.addClass(MDCToolbarFoundation.cssClasses.FIXED_AT_LAST_ROW);
    } else {
      this.adapter_.removeClass(MDCToolbarFoundation.cssClasses.FIXED_AT_LAST_ROW);
    }
  };

  MDCToolbarFoundation.prototype.updateFlexibleRowElementStyles_ = function updateFlexibleRowElementStyles_(flexibleExpansionRatio) {
    if (this.fixed_) {
      var height = this.calculations_.flexibleExpansionHeight * flexibleExpansionRatio;
      this.adapter_.setStyleForFlexibleRowElement('height', height + this.calculations_.toolbarRowHeight + 'px');
    }
    if (this.useFlexDefaultBehavior_) {
      this.updateElementStylesDefaultBehavior_(flexibleExpansionRatio);
    }
  };

  MDCToolbarFoundation.prototype.updateElementStylesDefaultBehavior_ = function updateElementStylesDefaultBehavior_(flexibleExpansionRatio) {
    var maxTitleSize = MDCToolbarFoundation.numbers.MAX_TITLE_SIZE;
    var minTitleSize = MDCToolbarFoundation.numbers.MIN_TITLE_SIZE;
    var currentTitleSize = (maxTitleSize - minTitleSize) * flexibleExpansionRatio + minTitleSize;

    this.adapter_.setStyleForTitleElement('font-size', currentTitleSize + 'rem');
  };

  return MDCToolbarFoundation;
}(foundation);


// CONCATENATED MODULE: ../node_modules/@material/toolbar/util.js
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var util_supportsPassive_ = void 0;

// Determine whether the current browser supports passive event listeners, and if so, use them.
function util_applyPassive() {
  var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
  var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (util_supportsPassive_ === undefined || forceRefresh) {
    var isSupported = false;
    try {
      globalObj.document.addEventListener('test', null, { get passive() {
          isSupported = true;
        } });
    } catch (e) {}

    util_supportsPassive_ = isSupported;
  }

  return util_supportsPassive_ ? { passive: true } : false;
}
// CONCATENATED MODULE: ../node_modules/@material/toolbar/index.js
var toolbar__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function toolbar__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function toolbar__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function toolbar__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */









var toolbar_MDCToolbar = function (_MDCComponent) {
  toolbar__inherits(MDCToolbar, _MDCComponent);

  function MDCToolbar() {
    toolbar__classCallCheck(this, MDCToolbar);

    return toolbar__possibleConstructorReturn(this, _MDCComponent.apply(this, arguments));
  }

  MDCToolbar.attachTo = function attachTo(root) {
    return new MDCToolbar(root);
  };

  MDCToolbar.prototype.getDefaultFoundation = function getDefaultFoundation() {
    var _this2 = this;

    return new foundation_MDCToolbarFoundation({
      hasClass: function hasClass(className) {
        return _this2.root_.classList.contains(className);
      },
      addClass: function addClass(className) {
        return _this2.root_.classList.add(className);
      },
      removeClass: function removeClass(className) {
        return _this2.root_.classList.remove(className);
      },
      registerScrollHandler: function registerScrollHandler(handler) {
        return window.addEventListener('scroll', handler, util_applyPassive());
      },
      deregisterScrollHandler: function deregisterScrollHandler(handler) {
        return window.removeEventListener('scroll', handler, util_applyPassive());
      },
      registerResizeHandler: function registerResizeHandler(handler) {
        return window.addEventListener('resize', handler);
      },
      deregisterResizeHandler: function deregisterResizeHandler(handler) {
        return window.removeEventListener('resize', handler);
      },
      getViewportWidth: function getViewportWidth() {
        return window.innerWidth;
      },
      getViewportScrollY: function getViewportScrollY() {
        return window.pageYOffset;
      },
      getOffsetHeight: function getOffsetHeight() {
        return _this2.root_.offsetHeight;
      },
      getFirstRowElementOffsetHeight: function getFirstRowElementOffsetHeight() {
        return _this2.firstRowElement_.offsetHeight;
      },
      notifyChange: function notifyChange(evtData) {
        return _this2.emit(foundation_MDCToolbarFoundation.strings.CHANGE_EVENT, evtData);
      },
      setStyle: function setStyle(property, value) {
        return _this2.root_.style.setProperty(property, value);
      },
      setStyleForTitleElement: function setStyleForTitleElement(property, value) {
        return _this2.titleElement_.style.setProperty(property, value);
      },
      setStyleForFlexibleRowElement: function setStyleForFlexibleRowElement(property, value) {
        return _this2.firstRowElement_.style.setProperty(property, value);
      },
      setStyleForFixedAdjustElement: function setStyleForFixedAdjustElement(property, value) {
        if (_this2.fixedAdjustElement) {
          _this2.fixedAdjustElement.style.setProperty(property, value);
        }
      }
    });
  };

  toolbar__createClass(MDCToolbar, [{
    key: 'firstRowElement_',
    get: function get() {
      return this.root_.querySelector(foundation_MDCToolbarFoundation.strings.FIRST_ROW_SELECTOR);
    }
  }, {
    key: 'titleElement_',
    get: function get() {
      return this.root_.querySelector(foundation_MDCToolbarFoundation.strings.TITLE_SELECTOR);
    }
  }, {
    key: 'fixedAdjustElement',
    set: function set(fixedAdjustElement) {
      this.fixedAdjustElement_ = fixedAdjustElement;
      this.foundation_.updateAdjustElementStyles();
    },
    get: function get() {
      return this.fixedAdjustElement_;
    }
  }]);

  return MDCToolbar;
}(base_component);
// CONCATENATED MODULE: ../node_modules/preact-material-components/Toolbar/index.js
function Toolbar__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Toolbar__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Toolbar__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Toolbar__extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};




/**
 * @prop fixed = false
 * @prop fixed-lastrow-only = false
 * @prop waterfall = false
 * @prop flexible = false
 * @prop flexible-default-behavior = false
 */

var Toolbar_Toolbar = function (_MaterialComponent) {
  Toolbar__inherits(Toolbar, _MaterialComponent);

  function Toolbar() {
    Toolbar__classCallCheck(this, Toolbar);

    var _this = Toolbar__possibleConstructorReturn(this, _MaterialComponent.call(this));

    _this.componentName = "toolbar";
    _this._mdcProps = ["fixed", "fixed-lastrow-only", "waterfall", "flexible", "flexible-default-behavior"];
    _this._onChange = _this._onChange.bind(_this);
    return _this;
  }

  Toolbar.prototype._onChange = function _onChange(e) {
    if (this.props.onChange) {
      this.props.onChange(e);
    }
  };

  Toolbar.prototype.componentDidMount = function componentDidMount() {
    this.MDComponent = new toolbar_MDCToolbar(this.control);
    this.MDComponent.listen("MDCToolbar:change", this._onChange);
  };

  Toolbar.prototype.componentWillUnmount = function componentWillUnmount() {
    this.MDComponent.unlisten("MDCToolbar:change", this._onChange);
    this.MDComponent.destroy && this.MDComponent.destroy();
  };

  Toolbar.prototype.materialDom = function materialDom(props) {
    var _this2 = this;

    return Object(preact_min["h"])("header", Toolbar__extends({
      ref: function ref(control) {
        _this2.control = control;
      }
    }, props), props.children);
  };

  return Toolbar;
}(MaterialComponent_MaterialComponent);

var ToolbarRow = function (_MaterialComponent2) {
  Toolbar__inherits(ToolbarRow, _MaterialComponent2);

  function ToolbarRow() {
    Toolbar__classCallCheck(this, ToolbarRow);

    var _this3 = Toolbar__possibleConstructorReturn(this, _MaterialComponent2.call(this));

    _this3.componentName = "toolbar__row";
    return _this3;
  }

  return ToolbarRow;
}(MaterialComponent_MaterialComponent);

/**
 * @prop align-end = false
 * @prop align-start = false
 * @prop shrink-to-fit = false
 */


var Toolbar_ToolbarSection = function (_MaterialComponent3) {
  Toolbar__inherits(ToolbarSection, _MaterialComponent3);

  function ToolbarSection() {
    Toolbar__classCallCheck(this, ToolbarSection);

    var _this4 = Toolbar__possibleConstructorReturn(this, _MaterialComponent3.call(this));

    _this4.componentName = "toolbar__section";
    _this4._mdcProps = ["align-start", "align-end", "shrink-to-fit"];
    return _this4;
  }

  ToolbarSection.prototype.materialDom = function materialDom(props) {
    return Object(preact_min["h"])("section", props, props.children);
  };

  return ToolbarSection;
}(MaterialComponent_MaterialComponent);

/**
 * @prop menu = false
 */


var Toolbar_ToolbarIcon = function (_MaterialComponent4) {
  Toolbar__inherits(ToolbarIcon, _MaterialComponent4);

  function ToolbarIcon(props) {
    Toolbar__classCallCheck(this, ToolbarIcon);

    var _this5 = Toolbar__possibleConstructorReturn(this, _MaterialComponent4.call(this));

    _this5.componentName = "toolbar__icon";
    if (props.menu) {
      _this5.componentName = "toolbar__menu-icon";
    }
    return _this5;
  }

  ToolbarIcon.prototype.materialDom = function materialDom(props) {
    return Object(preact_min["h"])("a", Toolbar__extends({ className: "material-icons" }, props), props.children || "menu");
  };

  return ToolbarIcon;
}(MaterialComponent_MaterialComponent);

/**
 * @prop title = ''
 */


var Toolbar_ToolbarTitle = function (_MaterialComponent5) {
  Toolbar__inherits(ToolbarTitle, _MaterialComponent5);

  function ToolbarTitle() {
    Toolbar__classCallCheck(this, ToolbarTitle);

    var _this6 = Toolbar__possibleConstructorReturn(this, _MaterialComponent5.call(this));

    _this6.componentName = "toolbar__title";
    return _this6;
  }

  ToolbarTitle.prototype.materialDom = function materialDom(props) {
    return Object(preact_min["h"])("span", props, props.children);
  };

  return ToolbarTitle;
}(MaterialComponent_MaterialComponent);

Toolbar_Toolbar.Section = Toolbar_ToolbarSection;
Toolbar_Toolbar.Icon = Toolbar_ToolbarIcon;
Toolbar_Toolbar.Title = Toolbar_ToolbarTitle;
Toolbar_Toolbar.Row = ToolbarRow;

/* harmony default export */ var preact_material_components_Toolbar = (Toolbar_Toolbar);
// CONCATENATED MODULE: ../node_modules/@material/drawer/slidable/constants.js
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var constants_FOCUSABLE_ELEMENTS = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), ' + 'button:not([disabled]), iframe, object, embed, [tabindex], [contenteditable]';
// CONCATENATED MODULE: ../node_modules/@material/drawer/slidable/foundation.js
var slidable_foundation__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var slidable_foundation__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function slidable_foundation__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function slidable_foundation__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function slidable_foundation__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var MDCSlidableDrawerFoundation = function (_MDCFoundation) {
  slidable_foundation__inherits(MDCSlidableDrawerFoundation, _MDCFoundation);

  slidable_foundation__createClass(MDCSlidableDrawerFoundation, null, [{
    key: 'defaultAdapter',
    get: function get() {
      return {
        addClass: function addClass() /* className: string */{},
        removeClass: function removeClass() /* className: string */{},
        hasClass: function hasClass() /* className: string */{},
        hasNecessaryDom: function hasNecessaryDom() {
          return (/* boolean */false
          );
        },
        registerInteractionHandler: function registerInteractionHandler() /* evt: string, handler: EventListener */{},
        deregisterInteractionHandler: function deregisterInteractionHandler() /* evt: string, handler: EventListener */{},
        registerDrawerInteractionHandler: function registerDrawerInteractionHandler() /* evt: string, handler: EventListener */{},
        deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler() /* evt: string, handler: EventListener */{},
        registerTransitionEndHandler: function registerTransitionEndHandler() /* handler: EventListener */{},
        deregisterTransitionEndHandler: function deregisterTransitionEndHandler() /* handler: EventListener */{},
        registerDocumentKeydownHandler: function registerDocumentKeydownHandler() /* handler: EventListener */{},
        deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler() /* handler: EventListener */{},
        setTranslateX: function setTranslateX() /* value: number | null */{},
        getFocusableElements: function getFocusableElements() /* NodeList */{},
        saveElementTabState: function saveElementTabState() /* el: Element */{},
        restoreElementTabState: function restoreElementTabState() /* el: Element */{},
        makeElementUntabbable: function makeElementUntabbable() /* el: Element */{},
        notifyOpen: function notifyOpen() {},
        notifyClose: function notifyClose() {},
        isRtl: function isRtl() {
          return (/* boolean */false
          );
        },
        getDrawerWidth: function getDrawerWidth() {
          return (/* number */0
          );
        }
      };
    }
  }]);

  function MDCSlidableDrawerFoundation(adapter, rootCssClass, animatingCssClass, openCssClass) {
    slidable_foundation__classCallCheck(this, MDCSlidableDrawerFoundation);

    var _this = slidable_foundation__possibleConstructorReturn(this, _MDCFoundation.call(this, slidable_foundation__extends(MDCSlidableDrawerFoundation.defaultAdapter, adapter)));

    _this.rootCssClass_ = rootCssClass;
    _this.animatingCssClass_ = animatingCssClass;
    _this.openCssClass_ = openCssClass;

    _this.transitionEndHandler_ = function (evt) {
      return _this.handleTransitionEnd_(evt);
    };

    _this.inert_ = false;

    _this.drawerClickHandler_ = function (evt) {
      return evt.stopPropagation();
    };
    _this.componentTouchStartHandler_ = function (evt) {
      return _this.handleTouchStart_(evt);
    };
    _this.componentTouchMoveHandler_ = function (evt) {
      return _this.handleTouchMove_(evt);
    };
    _this.componentTouchEndHandler_ = function (evt) {
      return _this.handleTouchEnd_(evt);
    };
    _this.documentKeydownHandler_ = function (evt) {
      if (evt.key && evt.key === 'Escape' || evt.keyCode === 27) {
        _this.close();
      }
    };
    return _this;
  }

  MDCSlidableDrawerFoundation.prototype.init = function init() {
    var ROOT = this.rootCssClass_;
    var OPEN = this.openCssClass_;

    if (!this.adapter_.hasClass(ROOT)) {
      throw new Error(ROOT + ' class required in root element.');
    }

    if (!this.adapter_.hasNecessaryDom()) {
      throw new Error('Required DOM nodes missing in ' + ROOT + ' component.');
    }

    if (this.adapter_.hasClass(OPEN)) {
      this.isOpen_ = true;
    } else {
      this.detabinate_();
      this.isOpen_ = false;
    }

    this.adapter_.registerDrawerInteractionHandler('click', this.drawerClickHandler_);
    this.adapter_.registerDrawerInteractionHandler('touchstart', this.componentTouchStartHandler_);
    this.adapter_.registerInteractionHandler('touchmove', this.componentTouchMoveHandler_);
    this.adapter_.registerInteractionHandler('touchend', this.componentTouchEndHandler_);
  };

  MDCSlidableDrawerFoundation.prototype.destroy = function destroy() {
    this.adapter_.deregisterDrawerInteractionHandler('click', this.drawerClickHandler_);
    this.adapter_.deregisterDrawerInteractionHandler('touchstart', this.componentTouchStartHandler_);
    this.adapter_.deregisterInteractionHandler('touchmove', this.componentTouchMoveHandler_);
    this.adapter_.deregisterInteractionHandler('touchend', this.componentTouchEndHandler_);
    // Deregister the document keydown handler just in case the component is destroyed while the menu is open.
    this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
  };

  MDCSlidableDrawerFoundation.prototype.open = function open() {
    this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
    this.adapter_.registerDocumentKeydownHandler(this.documentKeydownHandler_);
    this.adapter_.addClass(this.animatingCssClass_);
    this.adapter_.addClass(this.openCssClass_);
    this.retabinate_();
    // Debounce multiple calls
    if (!this.isOpen_) {
      this.adapter_.notifyOpen();
    }
    this.isOpen_ = true;
  };

  MDCSlidableDrawerFoundation.prototype.close = function close() {
    this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
    this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
    this.adapter_.addClass(this.animatingCssClass_);
    this.adapter_.removeClass(this.openCssClass_);
    this.detabinate_();
    // Debounce multiple calls
    if (this.isOpen_) {
      this.adapter_.notifyClose();
    }
    this.isOpen_ = false;
  };

  MDCSlidableDrawerFoundation.prototype.isOpen = function isOpen() {
    return this.isOpen_;
  };

  /**
   *  Render all children of the drawer inert when it's closed.
   */


  MDCSlidableDrawerFoundation.prototype.detabinate_ = function detabinate_() {
    if (this.inert_) {
      return;
    }

    var elements = this.adapter_.getFocusableElements();
    if (elements) {
      for (var i = 0; i < elements.length; i++) {
        this.adapter_.saveElementTabState(elements[i]);
        this.adapter_.makeElementUntabbable(elements[i]);
      }
    }

    this.inert_ = true;
  };

  /**
   *  Make all children of the drawer tabbable again when it's open.
   */


  MDCSlidableDrawerFoundation.prototype.retabinate_ = function retabinate_() {
    if (!this.inert_) {
      return;
    }

    var elements = this.adapter_.getFocusableElements();
    if (elements) {
      for (var i = 0; i < elements.length; i++) {
        this.adapter_.restoreElementTabState(elements[i]);
      }
    }

    this.inert_ = false;
  };

  MDCSlidableDrawerFoundation.prototype.handleTouchStart_ = function handleTouchStart_(evt) {
    if (!this.adapter_.hasClass(this.openCssClass_)) {
      return;
    }
    if (evt.pointerType && evt.pointerType !== 'touch') {
      return;
    }

    this.direction_ = this.adapter_.isRtl() ? -1 : 1;
    this.drawerWidth_ = this.adapter_.getDrawerWidth();
    this.startX_ = evt.touches ? evt.touches[0].pageX : evt.pageX;
    this.currentX_ = this.startX_;

    this.updateRaf_ = requestAnimationFrame(this.updateDrawer_.bind(this));
  };

  MDCSlidableDrawerFoundation.prototype.handleTouchMove_ = function handleTouchMove_(evt) {
    if (evt.pointerType && evt.pointerType !== 'touch') {
      return;
    }

    this.currentX_ = evt.touches ? evt.touches[0].pageX : evt.pageX;
  };

  MDCSlidableDrawerFoundation.prototype.handleTouchEnd_ = function handleTouchEnd_(evt) {
    if (evt.pointerType && evt.pointerType !== 'touch') {
      return;
    }

    this.prepareForTouchEnd_();

    // Did the user close the drawer by more than 50%?
    if (Math.abs(this.newPosition_ / this.drawerWidth_) >= 0.5) {
      this.close();
    } else {
      // Triggering an open here means we'll get a nice animation back to the fully open state.
      this.open();
    }
  };

  MDCSlidableDrawerFoundation.prototype.prepareForTouchEnd_ = function prepareForTouchEnd_() {
    cancelAnimationFrame(this.updateRaf_);
    this.adapter_.setTranslateX(null);
  };

  MDCSlidableDrawerFoundation.prototype.updateDrawer_ = function updateDrawer_() {
    this.updateRaf_ = requestAnimationFrame(this.updateDrawer_.bind(this));
    this.adapter_.setTranslateX(this.newPosition_);
  };

  MDCSlidableDrawerFoundation.prototype.isRootTransitioningEventTarget_ = function isRootTransitioningEventTarget_() {
    // Classes extending MDCSlidableDrawerFoundation should implement this method to return true or false
    // if the event target is the root event target currently transitioning.
    return false;
  };

  MDCSlidableDrawerFoundation.prototype.handleTransitionEnd_ = function handleTransitionEnd_(evt) {
    if (this.isRootTransitioningEventTarget_(evt.target)) {
      this.adapter_.removeClass(this.animatingCssClass_);
      this.adapter_.deregisterTransitionEndHandler(this.transitionEndHandler_);
    }
  };

  slidable_foundation__createClass(MDCSlidableDrawerFoundation, [{
    key: 'newPosition_',
    get: function get() {
      var newPos = null;

      if (this.direction_ === 1) {
        newPos = Math.min(0, this.currentX_ - this.startX_);
      } else {
        newPos = Math.max(0, this.currentX_ - this.startX_);
      }

      return newPos;
    }
  }]);

  return MDCSlidableDrawerFoundation;
}(foundation);
// CONCATENATED MODULE: ../node_modules/@material/drawer/slidable/index.js
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



// CONCATENATED MODULE: ../node_modules/@material/drawer/temporary/constants.js
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var temporary_constants_cssClasses = {
  ROOT: 'mdc-temporary-drawer',
  OPEN: 'mdc-temporary-drawer--open',
  ANIMATING: 'mdc-temporary-drawer--animating',
  SCROLL_LOCK: 'mdc-drawer-scroll-lock'
};

var temporary_constants_strings = {
  DRAWER_SELECTOR: '.mdc-temporary-drawer__drawer',
  OPACITY_VAR_NAME: '--mdc-temporary-drawer-opacity',
  FOCUSABLE_ELEMENTS: constants_FOCUSABLE_ELEMENTS,
  OPEN_EVENT: 'MDCTemporaryDrawer:open',
  CLOSE_EVENT: 'MDCTemporaryDrawer:close'
};
// CONCATENATED MODULE: ../node_modules/@material/drawer/temporary/foundation.js
var temporary_foundation__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var temporary_foundation__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function temporary_foundation__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function temporary_foundation__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function temporary_foundation__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var foundation_MDCTemporaryDrawerFoundation = function (_MDCSlidableDrawerFou) {
  temporary_foundation__inherits(MDCTemporaryDrawerFoundation, _MDCSlidableDrawerFou);

  temporary_foundation__createClass(MDCTemporaryDrawerFoundation, null, [{
    key: 'cssClasses',
    get: function get() {
      return temporary_constants_cssClasses;
    }
  }, {
    key: 'strings',
    get: function get() {
      return temporary_constants_strings;
    }
  }, {
    key: 'defaultAdapter',
    get: function get() {
      return temporary_foundation__extends(MDCSlidableDrawerFoundation.defaultAdapter, {
        addBodyClass: function addBodyClass() /* className: string */{},
        removeBodyClass: function removeBodyClass() /* className: string */{},
        isDrawer: function isDrawer() {
          return false;
        },
        updateCssVariable: function updateCssVariable() /* value: string */{}
      });
    }
  }]);

  function MDCTemporaryDrawerFoundation(adapter) {
    temporary_foundation__classCallCheck(this, MDCTemporaryDrawerFoundation);

    var _this = temporary_foundation__possibleConstructorReturn(this, _MDCSlidableDrawerFou.call(this, temporary_foundation__extends(MDCTemporaryDrawerFoundation.defaultAdapter, adapter), MDCTemporaryDrawerFoundation.cssClasses.ROOT, MDCTemporaryDrawerFoundation.cssClasses.ANIMATING, MDCTemporaryDrawerFoundation.cssClasses.OPEN));

    _this.componentClickHandler_ = function () {
      return _this.close();
    };
    return _this;
  }

  MDCTemporaryDrawerFoundation.prototype.init = function init() {
    _MDCSlidableDrawerFou.prototype.init.call(this);

    // Make browser aware of custom property being used in this element.
    // Workaround for certain types of hard-to-reproduce heisenbugs.
    this.adapter_.updateCssVariable(0);
    this.adapter_.registerInteractionHandler('click', this.componentClickHandler_);
  };

  MDCTemporaryDrawerFoundation.prototype.destroy = function destroy() {
    _MDCSlidableDrawerFou.prototype.destroy.call(this);

    this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
    this.enableScroll_();
  };

  MDCTemporaryDrawerFoundation.prototype.open = function open() {
    this.disableScroll_();
    // Make sure custom property values are cleared before starting.
    this.adapter_.updateCssVariable('');

    _MDCSlidableDrawerFou.prototype.open.call(this);
  };

  MDCTemporaryDrawerFoundation.prototype.close = function close() {
    // Make sure custom property values are cleared before making any changes.
    this.adapter_.updateCssVariable('');

    _MDCSlidableDrawerFou.prototype.close.call(this);
  };

  MDCTemporaryDrawerFoundation.prototype.prepareForTouchEnd_ = function prepareForTouchEnd_() {
    _MDCSlidableDrawerFou.prototype.prepareForTouchEnd_.call(this);

    this.adapter_.updateCssVariable('');
  };

  MDCTemporaryDrawerFoundation.prototype.updateDrawer_ = function updateDrawer_() {
    _MDCSlidableDrawerFou.prototype.updateDrawer_.call(this);

    var newOpacity = Math.max(0, 1 + this.direction_ * (this.newPosition_ / this.drawerWidth_));
    this.adapter_.updateCssVariable(newOpacity);
  };

  MDCTemporaryDrawerFoundation.prototype.isRootTransitioningEventTarget_ = function isRootTransitioningEventTarget_(el) {
    return this.adapter_.isDrawer(el);
  };

  MDCTemporaryDrawerFoundation.prototype.handleTransitionEnd_ = function handleTransitionEnd_(evt) {
    _MDCSlidableDrawerFou.prototype.handleTransitionEnd_.call(this, evt);
    if (!this.isOpen_) {
      this.enableScroll_();
    }
  };

  MDCTemporaryDrawerFoundation.prototype.disableScroll_ = function disableScroll_() {
    this.adapter_.addBodyClass(temporary_constants_cssClasses.SCROLL_LOCK);
  };

  MDCTemporaryDrawerFoundation.prototype.enableScroll_ = function enableScroll_() {
    this.adapter_.removeBodyClass(temporary_constants_cssClasses.SCROLL_LOCK);
  };

  return MDCTemporaryDrawerFoundation;
}(MDCSlidableDrawerFoundation);


// CONCATENATED MODULE: ../node_modules/@material/drawer/util.js
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var TAB_DATA = 'data-mdc-tabindex';
var TAB_DATA_HANDLED = 'data-mdc-tabindex-handled';

var storedTransformPropertyName_ = void 0;
var drawer_util_supportsPassive_ = void 0;

// Remap touch events to pointer events, if the browser doesn't support touch events.
function remapEvent(eventName) {
  var globalObj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;

  if (!('ontouchstart' in globalObj.document)) {
    switch (eventName) {
      case 'touchstart':
        return 'pointerdown';
      case 'touchmove':
        return 'pointermove';
      case 'touchend':
        return 'pointerup';
      default:
        return eventName;
    }
  }

  return eventName;
}

// Choose the correct transform property to use on the current browser.
function getTransformPropertyName() {
  var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
  var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (storedTransformPropertyName_ === undefined || forceRefresh) {
    var el = globalObj.document.createElement('div');
    var transformPropertyName = 'transform' in el.style ? 'transform' : '-webkit-transform';
    storedTransformPropertyName_ = transformPropertyName;
  }

  return storedTransformPropertyName_;
}

// Determine whether the current browser supports CSS properties.
function supportsCssCustomProperties() {
  var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;

  if ('CSS' in globalObj) {
    return globalObj.CSS.supports('(--color: red)');
  }
  return false;
}

// Determine whether the current browser supports passive event listeners, and if so, use them.
function drawer_util_applyPassive() {
  var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
  var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (drawer_util_supportsPassive_ === undefined || forceRefresh) {
    var isSupported = false;
    try {
      globalObj.document.addEventListener('test', null, { get passive() {
          isSupported = true;
        } });
    } catch (e) {}

    drawer_util_supportsPassive_ = isSupported;
  }

  return drawer_util_supportsPassive_ ? { passive: true } : false;
}

// Save the tab state for an element.
function util_saveElementTabState(el) {
  if (el.hasAttribute('tabindex')) {
    el.setAttribute(TAB_DATA, el.getAttribute('tabindex'));
  }
  el.setAttribute(TAB_DATA_HANDLED, true);
}

// Restore the tab state for an element, if it was saved.
function util_restoreElementTabState(el) {
  // Only modify elements we've already handled, in case anything was dynamically added since we saved state.
  if (el.hasAttribute(TAB_DATA_HANDLED)) {
    if (el.hasAttribute(TAB_DATA)) {
      el.setAttribute('tabindex', el.getAttribute(TAB_DATA));
      el.removeAttribute(TAB_DATA);
    } else {
      el.removeAttribute('tabindex');
    }
    el.removeAttribute(TAB_DATA_HANDLED);
  }
}
// CONCATENATED MODULE: ../node_modules/@material/drawer/temporary/index.js
var temporary__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function temporary__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function temporary__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function temporary__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








var temporary_MDCTemporaryDrawer = function (_MDCComponent) {
  temporary__inherits(MDCTemporaryDrawer, _MDCComponent);

  function MDCTemporaryDrawer() {
    temporary__classCallCheck(this, MDCTemporaryDrawer);

    return temporary__possibleConstructorReturn(this, _MDCComponent.apply(this, arguments));
  }

  MDCTemporaryDrawer.attachTo = function attachTo(root) {
    return new MDCTemporaryDrawer(root);
  };

  MDCTemporaryDrawer.prototype.getDefaultFoundation = function getDefaultFoundation() {
    var _this2 = this;

    var _MDCTemporaryDrawerFo = foundation_MDCTemporaryDrawerFoundation.strings,
        FOCUSABLE_ELEMENTS = _MDCTemporaryDrawerFo.FOCUSABLE_ELEMENTS,
        OPACITY_VAR_NAME = _MDCTemporaryDrawerFo.OPACITY_VAR_NAME;


    return new foundation_MDCTemporaryDrawerFoundation({
      addClass: function addClass(className) {
        return _this2.root_.classList.add(className);
      },
      removeClass: function removeClass(className) {
        return _this2.root_.classList.remove(className);
      },
      hasClass: function hasClass(className) {
        return _this2.root_.classList.contains(className);
      },
      addBodyClass: function addBodyClass(className) {
        return document.body.classList.add(className);
      },
      removeBodyClass: function removeBodyClass(className) {
        return document.body.classList.remove(className);
      },
      hasNecessaryDom: function hasNecessaryDom() {
        return Boolean(_this2.drawer);
      },
      registerInteractionHandler: function registerInteractionHandler(evt, handler) {
        return _this2.root_.addEventListener(remapEvent(evt), handler, drawer_util_applyPassive());
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
        return _this2.root_.removeEventListener(remapEvent(evt), handler, drawer_util_applyPassive());
      },
      registerDrawerInteractionHandler: function registerDrawerInteractionHandler(evt, handler) {
        return _this2.drawer.addEventListener(remapEvent(evt), handler);
      },
      deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler(evt, handler) {
        return _this2.drawer.removeEventListener(remapEvent(evt), handler);
      },
      registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
        return _this2.drawer.addEventListener('transitionend', handler);
      },
      deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
        return _this2.drawer.removeEventListener('transitionend', handler);
      },
      registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
        return document.addEventListener('keydown', handler);
      },
      deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
        return document.removeEventListener('keydown', handler);
      },
      getDrawerWidth: function getDrawerWidth() {
        return _this2.drawer.offsetWidth;
      },
      setTranslateX: function setTranslateX(value) {
        return _this2.drawer.style.setProperty(getTransformPropertyName(), value === null ? null : 'translateX(' + value + 'px)');
      },
      updateCssVariable: function updateCssVariable(value) {
        if (supportsCssCustomProperties()) {
          _this2.root_.style.setProperty(OPACITY_VAR_NAME, value);
        }
      },
      getFocusableElements: function getFocusableElements() {
        return _this2.drawer.querySelectorAll(FOCUSABLE_ELEMENTS);
      },
      saveElementTabState: function saveElementTabState(el) {
        return util_saveElementTabState(el);
      },
      restoreElementTabState: function restoreElementTabState(el) {
        return util_restoreElementTabState(el);
      },
      makeElementUntabbable: function makeElementUntabbable(el) {
        return el.setAttribute('tabindex', -1);
      },
      notifyOpen: function notifyOpen() {
        return _this2.emit(foundation_MDCTemporaryDrawerFoundation.strings.OPEN_EVENT);
      },
      notifyClose: function notifyClose() {
        return _this2.emit(foundation_MDCTemporaryDrawerFoundation.strings.CLOSE_EVENT);
      },
      isRtl: function isRtl() {
        return getComputedStyle(_this2.root_).getPropertyValue('direction') === 'rtl';
      },
      isDrawer: function isDrawer(el) {
        return el === _this2.drawer;
      }
    });
  };

  temporary__createClass(MDCTemporaryDrawer, [{
    key: 'open',
    get: function get() {
      return this.foundation_.isOpen();
    },
    set: function set(value) {
      if (value) {
        this.foundation_.open();
      } else {
        this.foundation_.close();
      }
    }

    /* Return the drawer element inside the component. */

  }, {
    key: 'drawer',
    get: function get() {
      return this.root_.querySelector(foundation_MDCTemporaryDrawerFoundation.strings.DRAWER_SELECTOR);
    }
  }]);

  return MDCTemporaryDrawer;
}(base_component);
// CONCATENATED MODULE: ../node_modules/@material/drawer/persistent/constants.js
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var persistent_constants_cssClasses = {
  ROOT: 'mdc-persistent-drawer',
  OPEN: 'mdc-persistent-drawer--open',
  ANIMATING: 'mdc-persistent-drawer--animating'
};

var persistent_constants_strings = {
  DRAWER_SELECTOR: '.mdc-persistent-drawer__drawer',
  FOCUSABLE_ELEMENTS: constants_FOCUSABLE_ELEMENTS,
  OPEN_EVENT: 'MDCPersistentDrawer:open',
  CLOSE_EVENT: 'MDCPersistentDrawer:close'
};
// CONCATENATED MODULE: ../node_modules/@material/drawer/persistent/foundation.js
var persistent_foundation__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var persistent_foundation__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function persistent_foundation__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function persistent_foundation__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function persistent_foundation__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var foundation_MDCPersistentDrawerFoundation = function (_MDCSlidableDrawerFou) {
  persistent_foundation__inherits(MDCPersistentDrawerFoundation, _MDCSlidableDrawerFou);

  persistent_foundation__createClass(MDCPersistentDrawerFoundation, null, [{
    key: 'cssClasses',
    get: function get() {
      return persistent_constants_cssClasses;
    }
  }, {
    key: 'strings',
    get: function get() {
      return persistent_constants_strings;
    }
  }, {
    key: 'defaultAdapter',
    get: function get() {
      return persistent_foundation__extends(MDCSlidableDrawerFoundation.defaultAdapter, {
        isDrawer: function isDrawer() {
          return false;
        }
      });
    }
  }]);

  function MDCPersistentDrawerFoundation(adapter) {
    persistent_foundation__classCallCheck(this, MDCPersistentDrawerFoundation);

    return persistent_foundation__possibleConstructorReturn(this, _MDCSlidableDrawerFou.call(this, persistent_foundation__extends(MDCPersistentDrawerFoundation.defaultAdapter, adapter), MDCPersistentDrawerFoundation.cssClasses.ROOT, MDCPersistentDrawerFoundation.cssClasses.ANIMATING, MDCPersistentDrawerFoundation.cssClasses.OPEN));
  }

  MDCPersistentDrawerFoundation.prototype.isRootTransitioningEventTarget_ = function isRootTransitioningEventTarget_(el) {
    return this.adapter_.isDrawer(el);
  };

  return MDCPersistentDrawerFoundation;
}(MDCSlidableDrawerFoundation);


// CONCATENATED MODULE: ../node_modules/@material/drawer/persistent/index.js
var persistent__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function persistent__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function persistent__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function persistent__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








var persistent_MDCPersistentDrawer = function (_MDCComponent) {
  persistent__inherits(MDCPersistentDrawer, _MDCComponent);

  function MDCPersistentDrawer() {
    persistent__classCallCheck(this, MDCPersistentDrawer);

    return persistent__possibleConstructorReturn(this, _MDCComponent.apply(this, arguments));
  }

  MDCPersistentDrawer.attachTo = function attachTo(root) {
    return new MDCPersistentDrawer(root);
  };

  MDCPersistentDrawer.prototype.getDefaultFoundation = function getDefaultFoundation() {
    var _this2 = this;

    var FOCUSABLE_ELEMENTS = foundation_MDCPersistentDrawerFoundation.strings.FOCUSABLE_ELEMENTS;


    return new foundation_MDCPersistentDrawerFoundation({
      addClass: function addClass(className) {
        return _this2.root_.classList.add(className);
      },
      removeClass: function removeClass(className) {
        return _this2.root_.classList.remove(className);
      },
      hasClass: function hasClass(className) {
        return _this2.root_.classList.contains(className);
      },
      hasNecessaryDom: function hasNecessaryDom() {
        return Boolean(_this2.drawer);
      },
      registerInteractionHandler: function registerInteractionHandler(evt, handler) {
        return _this2.root_.addEventListener(remapEvent(evt), handler, drawer_util_applyPassive());
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
        return _this2.root_.removeEventListener(remapEvent(evt), handler, drawer_util_applyPassive());
      },
      registerDrawerInteractionHandler: function registerDrawerInteractionHandler(evt, handler) {
        return _this2.drawer.addEventListener(remapEvent(evt), handler);
      },
      deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler(evt, handler) {
        return _this2.drawer.removeEventListener(remapEvent(evt), handler);
      },
      registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
        return _this2.root_.addEventListener('transitionend', handler);
      },
      deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
        return _this2.root_.removeEventListener('transitionend', handler);
      },
      registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
        return document.addEventListener('keydown', handler);
      },
      deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
        return document.removeEventListener('keydown', handler);
      },
      getDrawerWidth: function getDrawerWidth() {
        return _this2.drawer.offsetWidth;
      },
      setTranslateX: function setTranslateX(value) {
        return _this2.drawer.style.setProperty(getTransformPropertyName(), value === null ? null : 'translateX(' + value + 'px)');
      },
      getFocusableElements: function getFocusableElements() {
        return _this2.drawer.querySelectorAll(FOCUSABLE_ELEMENTS);
      },
      saveElementTabState: function saveElementTabState(el) {
        return util_saveElementTabState(el);
      },
      restoreElementTabState: function restoreElementTabState(el) {
        return util_restoreElementTabState(el);
      },
      makeElementUntabbable: function makeElementUntabbable(el) {
        return el.setAttribute('tabindex', -1);
      },
      notifyOpen: function notifyOpen() {
        return _this2.emit(foundation_MDCPersistentDrawerFoundation.strings.OPEN_EVENT);
      },
      notifyClose: function notifyClose() {
        return _this2.emit(foundation_MDCPersistentDrawerFoundation.strings.CLOSE_EVENT);
      },
      isRtl: function isRtl() {
        return getComputedStyle(_this2.root_).getPropertyValue('direction') === 'rtl';
      },
      isDrawer: function isDrawer(el) {
        return el === _this2.drawer;
      }
    });
  };

  persistent__createClass(MDCPersistentDrawer, [{
    key: 'open',
    get: function get() {
      return this.foundation_.isOpen();
    },
    set: function set(value) {
      if (value) {
        this.foundation_.open();
      } else {
        this.foundation_.close();
      }
    }

    // Return the drawer element inside the component.

  }, {
    key: 'drawer',
    get: function get() {
      return this.root_.querySelector(foundation_MDCPersistentDrawerFoundation.strings.DRAWER_SELECTOR);
    }
  }]);

  return MDCPersistentDrawer;
}(base_component);
// CONCATENATED MODULE: ../node_modules/preact-material-components/List/index.js
function List__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function List__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function List__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var List__extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};




/**
 * @prop dense = false
 * @prop two-line = false
 * @prop interactive = false
 */

var List_List = function (_MaterialComponent) {
  List__inherits(List, _MaterialComponent);

  function List() {
    List__classCallCheck(this, List);

    var _this = List__possibleConstructorReturn(this, _MaterialComponent.call(this));

    _this.componentName = "list";
    _this._mdcProps = ["dense", "two-line"];
    return _this;
  }

  List.prototype.materialDom = function materialDom(props) {
    var _this2 = this;

    if (props.interactive) {
      return Object(preact_min["h"])("nav", List__extends({ ref: function ref(control) {
          return _this2.control = control;
        } }, props), props.children);
    }

    return Object(preact_min["h"])("ul", List__extends({}, props, { ref: function ref(control) {
        return _this2.control = control;
      } }), props.children);
  };

  return List;
}(MaterialComponent_MaterialComponent);

var List_ListItem = function (_MaterialComponent2) {
  List__inherits(ListItem, _MaterialComponent2);

  function ListItem() {
    List__classCallCheck(this, ListItem);

    var _this3 = List__possibleConstructorReturn(this, _MaterialComponent2.call(this));

    _this3.componentName = "list-item";
    return _this3;
  }

  ListItem.prototype.materialDom = function materialDom(props) {
    var _this4 = this;

    return Object(preact_min["h"])("li", List__extends({ role: "option" }, props, { ref: function ref(control) {
        return _this4.control = control;
      } }), props.children);
  };

  return ListItem;
}(MaterialComponent_MaterialComponent);

var List_LinkItem = function (_MaterialComponent3) {
  List__inherits(LinkItem, _MaterialComponent3);

  function LinkItem() {
    List__classCallCheck(this, LinkItem);

    var _this5 = List__possibleConstructorReturn(this, _MaterialComponent3.call(this));

    _this5.componentName = "list-item";
    return _this5;
  }

  LinkItem.prototype.componentDidMount = function componentDidMount() {
    _MaterialComponent3.prototype.attachRipple.call(this);
  };

  LinkItem.prototype.materialDom = function materialDom(props) {
    var _this6 = this;

    return Object(preact_min["h"])("a", List__extends({ role: "option" }, props, { ref: function ref(control) {
        return _this6.control = control;
      } }), props.children);
  };

  return LinkItem;
}(MaterialComponent_MaterialComponent);

/**
 * @prop start-detail = true
 * @prop end-detail = false
 */


var List_ListItemIcon = function (_MaterialComponent4) {
  List__inherits(ListItemIcon, _MaterialComponent4);

  function ListItemIcon() {
    List__classCallCheck(this, ListItemIcon);

    var _this7 = List__possibleConstructorReturn(this, _MaterialComponent4.call(this));

    _this7.componentName = "mdc-list-item__icon";
    return _this7;
  }

  ListItemIcon.prototype.getProxyClassName = function getProxyClassName(props) {
    var classNames = [];

    // default behavior
    props["start-detail"] = props["start-detail"] || true;

    // setting class names mutually exclusive
    if (props["end-detail"]) {
      classNames.push("mdc-list-item__end-detail");
    } else if (props["start-detail"]) {
      classNames.push("mdc-list-item__start-detail");
    }
    return classNames.join(" ");
  };

  ListItemIcon.prototype.materialDom = function materialDom(props) {
    var _this8 = this;

    var className = "material-icons " + this.getProxyClassName(props);
    return Object(preact_min["h"])("i", List__extends({
      className: className,
      "aria-hidden": "true"
    }, props, {
      ref: function ref(control) {
        return _this8.control = control;
      }
    }), props.children);
  };

  return ListItemIcon;
}(MaterialComponent_MaterialComponent);

/**
 * @prop start-detail = true
 * @prop end-detail = false
 */


var List_ListItemAvatar = function (_ListItemIcon) {
  List__inherits(ListItemAvatar, _ListItemIcon);

  function ListItemAvatar() {
    List__classCallCheck(this, ListItemAvatar);

    var _this9 = List__possibleConstructorReturn(this, _ListItemIcon.call(this));

    _this9.componentName = "mdc-list-item__avatar";
    return _this9;
  }

  ListItemAvatar.prototype.materialDom = function materialDom(props) {
    var _this10 = this;

    return Object(preact_min["h"])("img", List__extends({}, props, {
      className: _ListItemIcon.prototype.getProxyClassName.call(this, props)
    }, props, {
      ref: function ref(control) {
        return _this10.control = control;
      },
      width: props.width || "56",
      height: props.height || "56",
      alt: props.alt || ""
    }));
  };

  return ListItemAvatar;
}(List_ListItemIcon);

var List_ListDivider = function (_MaterialComponent5) {
  List__inherits(ListDivider, _MaterialComponent5);

  function ListDivider() {
    List__classCallCheck(this, ListDivider);

    var _this11 = List__possibleConstructorReturn(this, _MaterialComponent5.call(this));

    _this11.componentName = "list-divider";
    _this11._mdcProps = ["inset"];
    return _this11;
  }

  ListDivider.prototype.materialDom = function materialDom(props) {
    var _this12 = this;

    return Object(preact_min["h"])("li", List__extends({
      role: "separator"
    }, props, {
      ref: function ref(control) {
        return _this12.control = control;
      }
    }));
  };

  return ListDivider;
}(MaterialComponent_MaterialComponent);

var List_ListTextContainer = function (_MaterialComponent6) {
  List__inherits(ListTextContainer, _MaterialComponent6);

  function ListTextContainer() {
    List__classCallCheck(this, ListTextContainer);

    var _this13 = List__possibleConstructorReturn(this, _MaterialComponent6.call(this));

    _this13.componentName = "list-item__text";
    return _this13;
  }

  ListTextContainer.prototype.materialDom = function materialDom(props) {
    var _this14 = this;

    return Object(preact_min["h"])("span", List__extends({}, props, { ref: function ref(control) {
        return _this14.control = control;
      } }), props.children);
  };

  return ListTextContainer;
}(MaterialComponent_MaterialComponent);

var ListPrimaryText = function (_ListTextContainer) {
  List__inherits(ListPrimaryText, _ListTextContainer);

  function ListPrimaryText() {
    List__classCallCheck(this, ListPrimaryText);

    var _this15 = List__possibleConstructorReturn(this, _ListTextContainer.call(this));

    _this15.componentName = "list-item__text__primary";
    return _this15;
  }

  return ListPrimaryText;
}(List_ListTextContainer);

var ListSecondaryText = function (_ListTextContainer2) {
  List__inherits(ListSecondaryText, _ListTextContainer2);

  function ListSecondaryText() {
    List__classCallCheck(this, ListSecondaryText);

    var _this16 = List__possibleConstructorReturn(this, _ListTextContainer2.call(this));

    _this16.componentName = "list-item__text__secondary";
    return _this16;
  }

  return ListSecondaryText;
}(List_ListTextContainer);

List_List.Item = List_ListItem;
List_List.LinkItem = List_LinkItem;
List_List.ItemIcon = List_ListItemIcon;
List_List.ItemAvatar = List_ListItemAvatar;
List_List.Divider = List_ListDivider;
List_List.TextContainer = List_ListTextContainer;
List_List.PrimaryText = ListPrimaryText;
List_List.SecondaryText = ListSecondaryText;

/* harmony default export */ var preact_material_components_List = (List_List);
// CONCATENATED MODULE: ../node_modules/preact-material-components/Drawer/index.js
function Drawer__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Drawer__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Drawer__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Drawer__extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};







/*
 * Default props for drawers
 */
var defaultProps = {
  open: false
};

var Drawer_TemporaryDrawer = function (_MaterialComponent) {
  Drawer__inherits(TemporaryDrawer, _MaterialComponent);

  function TemporaryDrawer() {
    Drawer__classCallCheck(this, TemporaryDrawer);

    var _this = Drawer__possibleConstructorReturn(this, _MaterialComponent.call(this));

    _this.componentName = "temporary-drawer";
    _this._open = _this._open.bind(_this);
    _this._close = _this._close.bind(_this);
    return _this;
  }

  TemporaryDrawer.prototype._open = function _open() {
    if (this.props.onOpen) {
      this.props.onOpen();
    }
  };

  TemporaryDrawer.prototype._close = function _close() {
    if (this.props.onClose) {
      this.props.onClose();
    }
  };

  TemporaryDrawer.prototype.componentDidMount = function componentDidMount() {
    this.MDComponent = temporary_MDCTemporaryDrawer.attachTo(this.control);
    this.MDComponent.listen("MDCTemporaryDrawer:open", this._open);
    this.MDComponent.listen("MDCTemporaryDrawer:close", this._close);
    toggleDrawer(defaultProps, this.props, this.MDComponent);
  };

  TemporaryDrawer.prototype.componentWillUnmount = function componentWillUnmount() {
    this.MDComponent.unlisten("MDCTemporaryDrawer:close", this._close);
    this.MDComponent.unlisten("MDCTemporaryDrawer:open", this._open);
    this.MDComponent.destroy && this.MDComponent.destroy();
  };

  TemporaryDrawer.prototype.componentWillUpdate = function componentWillUpdate(nextProps) {
    toggleDrawer(this.props, nextProps, this.MDComponent);
  };

  TemporaryDrawer.prototype.materialDom = function materialDom(props) {
    var _this2 = this;

    return Object(preact_min["h"])("aside", Drawer__extends({
      className: "mdc-typography",
      ref: function ref(control) {
        _this2.control = control;
      }
    }, props), Object(preact_min["h"])("nav", { className: "mdc-temporary-drawer__drawer" }, props.children));
  };

  return TemporaryDrawer;
}(MaterialComponent_MaterialComponent);

var Drawer_TemporaryDrawerHeader = function (_MaterialComponent2) {
  Drawer__inherits(TemporaryDrawerHeader, _MaterialComponent2);

  function TemporaryDrawerHeader() {
    Drawer__classCallCheck(this, TemporaryDrawerHeader);

    var _this3 = Drawer__possibleConstructorReturn(this, _MaterialComponent2.call(this));

    _this3.componentName = "temporary-drawer__header";
    return _this3;
  }

  TemporaryDrawerHeader.prototype.materialDom = function materialDom(props) {
    var _this4 = this;

    return Object(preact_min["h"])("header", Drawer__extends({
      ref: function ref(control) {
        _this4.control = control;
      }
    }, props), Object(preact_min["h"])("div", { className: "mdc-temporary-drawer__header-content" }, props.children));
  };

  return TemporaryDrawerHeader;
}(MaterialComponent_MaterialComponent);

var Drawer_TemporaryDrawerContent = function (_MaterialComponent3) {
  Drawer__inherits(TemporaryDrawerContent, _MaterialComponent3);

  function TemporaryDrawerContent() {
    Drawer__classCallCheck(this, TemporaryDrawerContent);

    var _this5 = Drawer__possibleConstructorReturn(this, _MaterialComponent3.call(this));

    _this5.componentName = "temporary-drawer__content";
    return _this5;
  }

  TemporaryDrawerContent.prototype.materialDom = function materialDom(props) {
    var _this6 = this;

    return Object(preact_min["h"])("nav", Drawer__extends({
      className: "mdc-list",
      ref: function ref(control) {
        _this6.control = control;
      }
    }, props), props.children);
  };

  return TemporaryDrawerContent;
}(MaterialComponent_MaterialComponent);

/**
 * @prop spacer = false
 */


var Drawer_PermanentDrawer = function (_MaterialComponent4) {
  Drawer__inherits(PermanentDrawer, _MaterialComponent4);

  function PermanentDrawer() {
    Drawer__classCallCheck(this, PermanentDrawer);

    var _this7 = Drawer__possibleConstructorReturn(this, _MaterialComponent4.call(this));

    _this7.componentName = "permanent-drawer";
    return _this7;
  }

  PermanentDrawer.prototype.materialDom = function materialDom(props) {
    return Object(preact_min["h"])("nav", Drawer__extends({ className: "mdc-typography" }, props), props.spacer && Object(preact_min["h"])("div", { className: "mdc-permanent-drawer__toolbar-spacer" }), Object(preact_min["h"])("div", { className: "mdc-permanent-drawer__content" }, Object(preact_min["h"])("nav", { className: "mdc-list" }, props.children)));
  };

  return PermanentDrawer;
}(MaterialComponent_MaterialComponent);

var Drawer_PermanentDrawerHeader = function (_MaterialComponent5) {
  Drawer__inherits(PermanentDrawerHeader, _MaterialComponent5);

  function PermanentDrawerHeader() {
    Drawer__classCallCheck(this, PermanentDrawerHeader);

    var _this8 = Drawer__possibleConstructorReturn(this, _MaterialComponent5.call(this));

    _this8.componentName = "permanent-drawer__header";
    return _this8;
  }

  PermanentDrawerHeader.prototype.materialDom = function materialDom(props) {
    var _this9 = this;

    return Object(preact_min["h"])("header", Drawer__extends({
      ref: function ref(control) {
        _this9.control = control;
      }
    }, props), Object(preact_min["h"])("div", { className: "mdc-permanent-drawer__header-content" }, props.children));
  };

  return PermanentDrawerHeader;
}(MaterialComponent_MaterialComponent);

var PermanentDrawerContent = function (_TemporaryDrawerConte) {
  Drawer__inherits(PermanentDrawerContent, _TemporaryDrawerConte);

  function PermanentDrawerContent() {
    Drawer__classCallCheck(this, PermanentDrawerContent);

    var _this10 = Drawer__possibleConstructorReturn(this, _TemporaryDrawerConte.call(this));

    _this10.componentName = "permanent-drawer__content";
    return _this10;
  }

  return PermanentDrawerContent;
}(Drawer_TemporaryDrawerContent);

var Drawer_PersistentDrawer = function (_MaterialComponent6) {
  Drawer__inherits(PersistentDrawer, _MaterialComponent6);

  function PersistentDrawer() {
    Drawer__classCallCheck(this, PersistentDrawer);

    var _this11 = Drawer__possibleConstructorReturn(this, _MaterialComponent6.call(this));

    _this11.componentName = "persistent-drawer";
    _this11._open = _this11._open.bind(_this11);
    _this11._close = _this11._close.bind(_this11);
    return _this11;
  }

  PersistentDrawer.prototype._open = function _open() {
    if (this.props.onOpen) {
      this.props.onOpen();
    }
  };

  PersistentDrawer.prototype._close = function _close() {
    if (this.props.onClose) {
      this.props.onClose();
    }
  };

  PersistentDrawer.prototype.componentDidMount = function componentDidMount() {
    this.MDComponent = persistent_MDCPersistentDrawer.attachTo(this.control);
    this.MDComponent.listen("MDCPersistentDrawer:open", this._open);
    this.MDComponent.listen("MDCPersistentDrawer:close", this._close);
    toggleDrawer(defaultProps, this.props, this.MDComponent);
  };

  PersistentDrawer.prototype.componentWillUnmount = function componentWillUnmount() {
    this.MDComponent.unlisten("MDCPersistentDrawer:close", this._close);
    this.MDComponent.unlisten("MDCPersistentDrawer:open", this._open);
    this.MDComponent.destroy && this.MDComponent.destroy();
  };

  PersistentDrawer.prototype.componentWillUpdate = function componentWillUpdate(nextProps) {
    toggleDrawer(this.props, nextProps, this.MDComponent);
  };

  PersistentDrawer.prototype.materialDom = function materialDom(props) {
    var _this12 = this;

    return Object(preact_min["h"])("aside", Drawer__extends({
      className: "mdc-typography",
      ref: function ref(control) {
        _this12.control = control;
      }
    }, props), Object(preact_min["h"])("nav", { className: "mdc-persistent-drawer__drawer" }, props.children));
  };

  return PersistentDrawer;
}(MaterialComponent_MaterialComponent);

var Drawer_PersistentDrawerHeader = function (_MaterialComponent7) {
  Drawer__inherits(PersistentDrawerHeader, _MaterialComponent7);

  function PersistentDrawerHeader() {
    Drawer__classCallCheck(this, PersistentDrawerHeader);

    var _this13 = Drawer__possibleConstructorReturn(this, _MaterialComponent7.call(this));

    _this13.componentName = "persistent-drawer__header";
    return _this13;
  }

  PersistentDrawerHeader.prototype.materialDom = function materialDom(props) {
    var _this14 = this;

    return Object(preact_min["h"])("header", Drawer__extends({
      ref: function ref(control) {
        _this14.control = control;
      }
    }, props), Object(preact_min["h"])("div", { className: "mdc-persistent-drawer__header-content" }, props.children));
  };

  return PersistentDrawerHeader;
}(MaterialComponent_MaterialComponent);

var PersistentDrawerContent = function (_TemporaryDrawerConte2) {
  Drawer__inherits(PersistentDrawerContent, _TemporaryDrawerConte2);

  function PersistentDrawerContent() {
    Drawer__classCallCheck(this, PersistentDrawerContent);

    var _this15 = Drawer__possibleConstructorReturn(this, _TemporaryDrawerConte2.call(this));

    _this15.componentName = "persistent-drawer__content";
    return _this15;
  }

  return PersistentDrawerContent;
}(Drawer_TemporaryDrawerContent);

/**
 * @prop selected = false
 */


var DrawerItem = function (_List$LinkItem) {
  Drawer__inherits(DrawerItem, _List$LinkItem);

  function DrawerItem() {
    Drawer__classCallCheck(this, DrawerItem);

    return Drawer__possibleConstructorReturn(this, _List$LinkItem.call(this));
  }

  DrawerItem.prototype.materialDom = function materialDom(props) {
    var returnedNode = _List$LinkItem.prototype.materialDom.call(this, props);
    /* Logic to add selected class */
    if (props.selected) {
      returnedNode.attributes["className"] = "mdc-temporary-drawer--selected mdc-permanent-drawer--selected";
    }
    return returnedNode;
  };

  return DrawerItem;
}(preact_material_components_List.LinkItem);

/*
 * Function to add declarative opening/closing to drawer
 */


function toggleDrawer(oldprops, newprops, drawer) {
  if ("open" in oldprops && "open" in newprops && oldprops.open !== newprops.open) {
    drawer.open = newprops.open;
  }
}

var Drawer = {};

Drawer.DrawerItem = DrawerItem;
Drawer.TemporaryDrawer = Drawer_TemporaryDrawer;
Drawer.TemporaryDrawerHeader = Drawer_TemporaryDrawerHeader;
Drawer.TemporaryDrawerContent = Drawer_TemporaryDrawerContent;
Drawer.PermanentDrawer = Drawer_PermanentDrawer;
Drawer.PermanentDrawerHeader = Drawer_PermanentDrawerHeader;
Drawer.PermanentDrawerContent = PermanentDrawerContent;
Drawer.PersistentDrawer = Drawer_PersistentDrawer;
Drawer.PersistentDrawerHeader = Drawer_PersistentDrawerHeader;
Drawer.PersistentDrawerContent = PersistentDrawerContent;

/* harmony default export */ var preact_material_components_Drawer = (Drawer);
// CONCATENATED MODULE: ../node_modules/@material/dialog/constants.js
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var dialog_constants_cssClasses = {
  ROOT: 'mdc-dialog',
  OPEN: 'mdc-dialog--open',
  ANIMATING: 'mdc-dialog--animating',
  BACKDROP: 'mdc-dialog__backdrop',
  SCROLL_LOCK: 'mdc-dialog-scroll-lock',
  ACCEPT_BTN: 'mdc-dialog__footer__button--accept',
  CANCEL_BTN: 'mdc-dialog__footer__button--cancel'
};

var dialog_constants_strings = {
  OPEN_DIALOG_SELECTOR: '.mdc-dialog--open',
  DIALOG_SURFACE_SELECTOR: '.mdc-dialog__surface',
  ACCEPT_SELECTOR: '.mdc-dialog__footer__button--accept',
  ACCEPT_EVENT: 'MDCDialog:accept',
  CANCEL_EVENT: 'MDCDialog:cancel'
};
// CONCATENATED MODULE: ../node_modules/@material/dialog/foundation.js
var dialog_foundation__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var dialog_foundation__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function dialog_foundation__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function dialog_foundation__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function dialog_foundation__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var foundation_MDCDialogFoundation = function (_MDCFoundation) {
  dialog_foundation__inherits(MDCDialogFoundation, _MDCFoundation);

  dialog_foundation__createClass(MDCDialogFoundation, null, [{
    key: 'cssClasses',
    get: function get() {
      return dialog_constants_cssClasses;
    }
  }, {
    key: 'strings',
    get: function get() {
      return dialog_constants_strings;
    }
  }, {
    key: 'defaultAdapter',
    get: function get() {
      return {
        addClass: function addClass() /* className: string */{},
        removeClass: function removeClass() /* className: string */{},
        addBodyClass: function addBodyClass() /* className: string */{},
        removeBodyClass: function removeBodyClass() /* className: string */{},
        eventTargetHasClass: function eventTargetHasClass() {
          return (/* target: EventTarget, className: string */ /* boolean */false
          );
        },
        registerInteractionHandler: function registerInteractionHandler() /* evt: string, handler: EventListener */{},
        deregisterInteractionHandler: function deregisterInteractionHandler() /* evt: string, handler: EventListener */{},
        registerSurfaceInteractionHandler: function registerSurfaceInteractionHandler() /* evt: string, handler: EventListener */{},
        deregisterSurfaceInteractionHandler: function deregisterSurfaceInteractionHandler() /* evt: string, handler: EventListener */{},
        registerDocumentKeydownHandler: function registerDocumentKeydownHandler() /* handler: EventListener */{},
        deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler() /* handler: EventListener */{},
        registerTransitionEndHandler: function registerTransitionEndHandler() /* handler: EventListener */{},
        deregisterTransitionEndHandler: function deregisterTransitionEndHandler() /* handler: EventListener */{},
        notifyAccept: function notifyAccept() {},
        notifyCancel: function notifyCancel() {},
        trapFocusOnSurface: function trapFocusOnSurface() {},
        untrapFocusOnSurface: function untrapFocusOnSurface() {},
        isDialog: function isDialog() {
          return (/* el: Element */ /* boolean */false
          );
        },
        layoutFooterRipples: function layoutFooterRipples() {}
      };
    }
  }]);

  function MDCDialogFoundation(adapter) {
    dialog_foundation__classCallCheck(this, MDCDialogFoundation);

    var _this = dialog_foundation__possibleConstructorReturn(this, _MDCFoundation.call(this, dialog_foundation__extends(MDCDialogFoundation.defaultAdapter, adapter)));

    _this.isOpen_ = false;
    _this.componentClickHandler_ = function (evt) {
      if (_this.adapter_.eventTargetHasClass(evt.target, dialog_constants_cssClasses.BACKDROP)) {
        _this.cancel(true);
      }
    };
    _this.dialogClickHandler_ = function (evt) {
      return _this.handleDialogClick_(evt);
    };
    _this.documentKeydownHandler_ = function (evt) {
      if (evt.key && evt.key === 'Escape' || evt.keyCode === 27) {
        _this.cancel(true);
      }
    };
    _this.transitionEndHandler_ = function (evt) {
      return _this.handleTransitionEnd_(evt);
    };
    return _this;
  }

  MDCDialogFoundation.prototype.destroy = function destroy() {
    // Ensure that dialog is cleaned up when destroyed
    if (this.isOpen_) {
      this.adapter_.deregisterSurfaceInteractionHandler('click', this.dialogClickHandler_);
      this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
      this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
      this.adapter_.untrapFocusOnSurface();
      this.adapter_.deregisterTransitionEndHandler(this.transitionEndHandler_);
      this.adapter_.removeClass(MDCDialogFoundation.cssClasses.ANIMATING);
      this.adapter_.removeClass(MDCDialogFoundation.cssClasses.OPEN);
      this.enableScroll_();
    }
  };

  MDCDialogFoundation.prototype.open = function open() {
    this.isOpen_ = true;
    this.disableScroll_();
    this.adapter_.registerDocumentKeydownHandler(this.documentKeydownHandler_);
    this.adapter_.registerSurfaceInteractionHandler('click', this.dialogClickHandler_);
    this.adapter_.registerInteractionHandler('click', this.componentClickHandler_);
    this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
    this.adapter_.addClass(MDCDialogFoundation.cssClasses.ANIMATING);
    this.adapter_.addClass(MDCDialogFoundation.cssClasses.OPEN);
  };

  MDCDialogFoundation.prototype.close = function close() {
    this.isOpen_ = false;
    this.adapter_.deregisterSurfaceInteractionHandler('click', this.dialogClickHandler_);
    this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
    this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
    this.adapter_.untrapFocusOnSurface();
    this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
    this.adapter_.addClass(MDCDialogFoundation.cssClasses.ANIMATING);
    this.adapter_.removeClass(MDCDialogFoundation.cssClasses.OPEN);
  };

  MDCDialogFoundation.prototype.isOpen = function isOpen() {
    return this.isOpen_;
  };

  MDCDialogFoundation.prototype.accept = function accept(shouldNotify) {
    if (shouldNotify) {
      this.adapter_.notifyAccept();
    }

    this.close();
  };

  MDCDialogFoundation.prototype.cancel = function cancel(shouldNotify) {
    if (shouldNotify) {
      this.adapter_.notifyCancel();
    }

    this.close();
  };

  MDCDialogFoundation.prototype.handleDialogClick_ = function handleDialogClick_(evt) {
    var target = evt.target;

    if (this.adapter_.eventTargetHasClass(target, dialog_constants_cssClasses.ACCEPT_BTN)) {
      this.accept(true);
    } else if (this.adapter_.eventTargetHasClass(target, dialog_constants_cssClasses.CANCEL_BTN)) {
      this.cancel(true);
    }
  };

  MDCDialogFoundation.prototype.handleTransitionEnd_ = function handleTransitionEnd_(evt) {
    if (this.adapter_.isDialog(evt.target)) {
      this.adapter_.deregisterTransitionEndHandler(this.transitionEndHandler_);
      this.adapter_.removeClass(MDCDialogFoundation.cssClasses.ANIMATING);
      if (this.isOpen_) {
        this.adapter_.trapFocusOnSurface();
        this.adapter_.layoutFooterRipples();
      } else {
        this.enableScroll_();
      };
    };
  };

  MDCDialogFoundation.prototype.disableScroll_ = function disableScroll_() {
    this.adapter_.addBodyClass(dialog_constants_cssClasses.SCROLL_LOCK);
  };

  MDCDialogFoundation.prototype.enableScroll_ = function enableScroll_() {
    this.adapter_.removeBodyClass(dialog_constants_cssClasses.SCROLL_LOCK);
  };

  return MDCDialogFoundation;
}(foundation);


// EXTERNAL MODULE: ../node_modules/focus-trap/index.js
var focus_trap = __webpack_require__("ySUw");
var focus_trap_default = /*#__PURE__*/__webpack_require__.n(focus_trap);

// CONCATENATED MODULE: ../node_modules/@material/dialog/util.js
/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



function createFocusTrapInstance(surfaceEl, acceptButtonEl) {
  var focusTrapFactory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : focus_trap_default.a;

  return focusTrapFactory(surfaceEl, {
    initialFocus: acceptButtonEl,
    clickOutsideDeactivates: true
  });
}
// CONCATENATED MODULE: ../node_modules/@material/dialog/index.js
var dialog__createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function dialog__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function dialog__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function dialog__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Copyright 2017 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */










var dialog_MDCDialog = function (_MDCComponent) {
  dialog__inherits(MDCDialog, _MDCComponent);

  function MDCDialog() {
    dialog__classCallCheck(this, MDCDialog);

    return dialog__possibleConstructorReturn(this, _MDCComponent.apply(this, arguments));
  }

  MDCDialog.attachTo = function attachTo(root) {
    return new MDCDialog(root);
  };

  MDCDialog.prototype.initialize = function initialize() {
    this.focusTrap_ = createFocusTrapInstance(this.dialogSurface_, this.acceptButton_);
    this.footerBtnRipples_ = [];

    var footerBtns = this.root_.querySelectorAll('.mdc-dialog__footer__button');
    for (var i = 0, footerBtn; footerBtn = footerBtns[i]; i++) {
      this.footerBtnRipples_.push(new ripple_MDCRipple(footerBtn));
    }
  };

  MDCDialog.prototype.destroy = function destroy() {
    this.footerBtnRipples_.forEach(function (ripple) {
      return ripple.destroy();
    });
    _MDCComponent.prototype.destroy.call(this);
  };

  MDCDialog.prototype.show = function show() {
    this.foundation_.open();
  };

  MDCDialog.prototype.close = function close() {
    this.foundation_.close();
  };

  MDCDialog.prototype.getDefaultFoundation = function getDefaultFoundation() {
    var _this2 = this;

    return new foundation_MDCDialogFoundation({
      addClass: function addClass(className) {
        return _this2.root_.classList.add(className);
      },
      removeClass: function removeClass(className) {
        return _this2.root_.classList.remove(className);
      },
      addBodyClass: function addBodyClass(className) {
        return document.body.classList.add(className);
      },
      removeBodyClass: function removeBodyClass(className) {
        return document.body.classList.remove(className);
      },
      eventTargetHasClass: function eventTargetHasClass(target, className) {
        return target.classList.contains(className);
      },
      registerInteractionHandler: function registerInteractionHandler(evt, handler) {
        return _this2.root_.addEventListener(evt, handler);
      },
      deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
        return _this2.root_.removeEventListener(evt, handler);
      },
      registerSurfaceInteractionHandler: function registerSurfaceInteractionHandler(evt, handler) {
        return _this2.dialogSurface_.addEventListener(evt, handler);
      },
      deregisterSurfaceInteractionHandler: function deregisterSurfaceInteractionHandler(evt, handler) {
        return _this2.dialogSurface_.removeEventListener(evt, handler);
      },
      registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
        return document.addEventListener('keydown', handler);
      },
      deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
        return document.removeEventListener('keydown', handler);
      },
      registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
        return _this2.dialogSurface_.addEventListener('transitionend', handler);
      },
      deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
        return _this2.dialogSurface_.removeEventListener('transitionend', handler);
      },
      notifyAccept: function notifyAccept() {
        return _this2.emit(foundation_MDCDialogFoundation.strings.ACCEPT_EVENT);
      },
      notifyCancel: function notifyCancel() {
        return _this2.emit(foundation_MDCDialogFoundation.strings.CANCEL_EVENT);
      },
      trapFocusOnSurface: function trapFocusOnSurface() {
        return _this2.focusTrap_.activate();
      },
      untrapFocusOnSurface: function untrapFocusOnSurface() {
        return _this2.focusTrap_.deactivate();
      },
      isDialog: function isDialog(el) {
        return el === _this2.dialogSurface_;
      },
      layoutFooterRipples: function layoutFooterRipples() {
        return _this2.footerBtnRipples_.forEach(function (ripple) {
          return ripple.layout();
        });
      }
    });
  };

  dialog__createClass(MDCDialog, [{
    key: 'open',
    get: function get() {
      return this.foundation_.isOpen();
    }
  }, {
    key: 'acceptButton_',
    get: function get() {
      return this.root_.querySelector(foundation_MDCDialogFoundation.strings.ACCEPT_SELECTOR);
    }
  }, {
    key: 'dialogSurface_',
    get: function get() {
      return this.root_.querySelector(foundation_MDCDialogFoundation.strings.DIALOG_SURFACE_SELECTOR);
    }
  }]);

  return MDCDialog;
}(base_component);
// CONCATENATED MODULE: ../node_modules/preact-material-components/Icon/index.js
function Icon__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Icon__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Icon__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Icon__extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};




/**
 * @prop disabled = false
 */

var Icon_Icon = function (_MaterialComponent) {
  Icon__inherits(Icon, _MaterialComponent);

  function Icon() {
    Icon__classCallCheck(this, Icon);

    var _this = Icon__possibleConstructorReturn(this, _MaterialComponent.call(this));

    _this.componentName = "icon";
    return _this;
  }

  Icon.prototype.materialDom = function materialDom(props) {
    var classes = ["material-icons"];
    if (props.className) {
      classes.push(props.className);
    }
    return Object(preact_min["h"])("i", Icon__extends({}, props, { className: classes.join(" ") }), props.children);
  };

  return Icon;
}(MaterialComponent_MaterialComponent);


// CONCATENATED MODULE: ../node_modules/preact-material-components/Button/index.js
function Button__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Button__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Button__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Button__extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};





/**
 *  @prop dense = false
 *  @prop raised = false
 *  @prop compact = false
 *  @prop disabled = false
 *  @prop unelevated = false
 *  @prop stroked = false
 */

var Button_Button = function (_MaterialComponent) {
  Button__inherits(Button, _MaterialComponent);

  function Button() {
    Button__classCallCheck(this, Button);

    var _this = Button__possibleConstructorReturn(this, _MaterialComponent.call(this));

    _this.componentName = "button";
    _this._mdcProps = ["dense", "raised", "compact", "unelevated", "stroked"];
    return _this;
  }

  Button.prototype.componentDidMount = function componentDidMount() {
    _MaterialComponent.prototype.attachRipple.call(this);
  };

  Button.prototype.materialDom = function materialDom(props) {
    var _this2 = this;

    var ButtonElement = props.href ? "a" : "button";

    return Object(preact_min["h"])(ButtonElement, Button__extends({
      ref: function ref(control) {
        _this2.control = control;
      }
    }, props), this.props.children);
  };

  return Button;
}(MaterialComponent_MaterialComponent);

var ButtonIcon = function (_Icon) {
  Button__inherits(ButtonIcon, _Icon);

  function ButtonIcon() {
    Button__classCallCheck(this, ButtonIcon);

    var _this3 = Button__possibleConstructorReturn(this, _Icon.call(this));

    _this3.componentName = "button__icon";
    return _this3;
  }

  return ButtonIcon;
}(Icon_Icon);

Button_Button.Icon = ButtonIcon;
/* harmony default export */ var preact_material_components_Button = (Button_Button);
// CONCATENATED MODULE: ../node_modules/preact-material-components/Dialog/index.js
function Dialog__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Dialog__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Dialog__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Dialog__extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};





/**
 */

var Dialog_Dialog = function (_MaterialComponent) {
  Dialog__inherits(Dialog, _MaterialComponent);

  function Dialog() {
    Dialog__classCallCheck(this, Dialog);

    var _this = Dialog__possibleConstructorReturn(this, _MaterialComponent.call(this));

    _this.componentName = "dialog";
    _this._onAccept = _this._onAccept.bind(_this);
    _this._onCancel = _this._onCancel.bind(_this);
    return _this;
  }

  Dialog.prototype.componentDidMount = function componentDidMount() {
    this.MDComponent = new dialog_MDCDialog(this.control);
    this.MDComponent.listen("MDCDialog:accept", this._onAccept);
    this.MDComponent.listen("MDCDialog:cancel", this._onCancel);
  };

  Dialog.prototype.componentWillUnmount = function componentWillUnmount() {
    this.MDComponent.unlisten("MDCDialog:accept", this._onAccept);
    this.MDComponent.unlisten("MDCDialog:cancel", this._onCancel);
    this.MDComponent.destroy && this.MDComponent.destroy();
  };

  Dialog.prototype._onAccept = function _onAccept(e) {
    if (this.props.onAccept) {
      this.props.onAccept(e);
    }
  };

  Dialog.prototype._onCancel = function _onCancel(e) {
    if (this.props.onCancel) {
      this.props.onCancel(e);
    }
  };

  Dialog.prototype.materialDom = function materialDom(props) {
    var _this2 = this;

    return Object(preact_min["h"])("aside", Dialog__extends({
      role: "alertdialog",
      ref: function ref(control) {
        _this2.control = control;
      }
    }, props), Object(preact_min["h"])("div", { className: "mdc-dialog__surface" }, props.children), Object(preact_min["h"])("div", { className: "mdc-dialog__backdrop" }));
  };

  return Dialog;
}(MaterialComponent_MaterialComponent);

var Dialog_DialogHeader = function (_MaterialComponent2) {
  Dialog__inherits(DialogHeader, _MaterialComponent2);

  function DialogHeader() {
    Dialog__classCallCheck(this, DialogHeader);

    var _this3 = Dialog__possibleConstructorReturn(this, _MaterialComponent2.call(this));

    _this3.componentName = "dialog__header";
    return _this3;
  }

  DialogHeader.prototype.materialDom = function materialDom(props) {
    return Object(preact_min["h"])("header", props, Object(preact_min["h"])("h2", { className: "mdc-dialog__header__title" }, props.children));
  };

  return DialogHeader;
}(MaterialComponent_MaterialComponent);

/**
 * @prop scrollable = false
 */


var Dialog_DialogBody = function (_MaterialComponent3) {
  Dialog__inherits(DialogBody, _MaterialComponent3);

  function DialogBody() {
    Dialog__classCallCheck(this, DialogBody);

    var _this4 = Dialog__possibleConstructorReturn(this, _MaterialComponent3.call(this));

    _this4.componentName = "dialog__body";
    _this4._mdcProps = ["scrollable"];
    return _this4;
  }

  DialogBody.prototype.materialDom = function materialDom(props) {
    return Object(preact_min["h"])("section", props, props.children);
  };

  return DialogBody;
}(MaterialComponent_MaterialComponent);

var Dialog_DialogFooter = function (_MaterialComponent4) {
  Dialog__inherits(DialogFooter, _MaterialComponent4);

  function DialogFooter() {
    Dialog__classCallCheck(this, DialogFooter);

    var _this5 = Dialog__possibleConstructorReturn(this, _MaterialComponent4.call(this));

    _this5.componentName = "dialog__footer";
    return _this5;
  }

  DialogFooter.prototype.materialDom = function materialDom(props) {
    return Object(preact_min["h"])("footer", props, props.children);
  };

  return DialogFooter;
}(MaterialComponent_MaterialComponent);

/**
 * @prop cancel = false
 * @prop accept = false
 */


var Dialog_DialogFooterButton = function (_Button) {
  Dialog__inherits(DialogFooterButton, _Button);

  function DialogFooterButton() {
    Dialog__classCallCheck(this, DialogFooterButton);

    var _this6 = Dialog__possibleConstructorReturn(this, _Button.call(this));

    _this6.componentName = "dialog__footer__button";
    _this6._mdcProps = ["cancel", "accept"];
    return _this6;
  }

  DialogFooterButton.prototype.materialDom = function materialDom(props) {
    var _this7 = this;

    return Object(preact_min["h"])("button", Dialog__extends({}, props, {
      className: "mdc-button",
      ref: function ref(control) {
        _this7.control = control;
      }
    }), props.children);
  };

  return DialogFooterButton;
}(preact_material_components_Button);

Dialog_Dialog.Header = Dialog_DialogHeader;
Dialog_Dialog.Body = Dialog_DialogBody;
Dialog_Dialog.Footer = Dialog_DialogFooter;
Dialog_Dialog.FooterButton = Dialog_DialogFooterButton;

/* harmony default export */ var preact_material_components_Dialog = (Dialog_Dialog);
// CONCATENATED MODULE: ../node_modules/preact-material-components/Switch/index.js
function Switch__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Switch__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Switch__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Switch__extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};

function _objectWithoutProperties(obj, keys) {
  var target = {};for (var i in obj) {
    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
  }return target;
}




/**
 * @prop disabled = false
 */

var Switch_Switch = function (_MaterialComponent) {
  Switch__inherits(Switch, _MaterialComponent);

  function Switch() {
    Switch__classCallCheck(this, Switch);

    var _this = Switch__possibleConstructorReturn(this, _MaterialComponent.call(this));

    _this.componentName = "switch";
    _this._mdcProps = ["disabled"];
    return _this;
  }

  Switch.prototype.materialDom = function materialDom(allprops) {
    var className = allprops.className,
        props = _objectWithoutProperties(allprops, ["className"]);

    return Object(preact_min["h"])("div", { className: className }, Object(preact_min["h"])("input", Switch__extends({
      type: "checkbox",
      className: "mdc-switch__native-control"
    }, props)), Object(preact_min["h"])("div", { className: "mdc-switch__background" }, Object(preact_min["h"])("div", { className: "mdc-switch__knob" })));
  };

  return Switch;
}(MaterialComponent_MaterialComponent);


// EXTERNAL MODULE: ../node_modules/preact-material-components/Switch/style.css
var Switch_style = __webpack_require__("IpTH");
var Switch_style_default = /*#__PURE__*/__webpack_require__.n(Switch_style);

// EXTERNAL MODULE: ../node_modules/preact-material-components/Dialog/style.css
var Dialog_style = __webpack_require__("sEh6");
var Dialog_style_default = /*#__PURE__*/__webpack_require__.n(Dialog_style);

// EXTERNAL MODULE: ../node_modules/preact-material-components/Drawer/style.css
var Drawer_style = __webpack_require__("RYBc");
var Drawer_style_default = /*#__PURE__*/__webpack_require__.n(Drawer_style);

// EXTERNAL MODULE: ../node_modules/preact-material-components/List/style.css
var List_style = __webpack_require__("u+vq");
var List_style_default = /*#__PURE__*/__webpack_require__.n(List_style);

// EXTERNAL MODULE: ../node_modules/preact-material-components/Toolbar/style.css
var Toolbar_style = __webpack_require__("LbTS");
var Toolbar_style_default = /*#__PURE__*/__webpack_require__.n(Toolbar_style);

// CONCATENATED MODULE: ./components/header/index.js


function header__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function header__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function header__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }













// import style from './style';

var header__ref = Object(preact_min["h"])(
	preact_material_components_Toolbar.Title,
	null,
	'Preact app'
);

var header__ref2 = Object(preact_min["h"])(
	preact_material_components_Toolbar.Icon,
	null,
	'settings'
);

var _ref3 = Object(preact_min["h"])(
	preact_material_components_List.ItemIcon,
	null,
	'home'
);

var _ref4 = Object(preact_min["h"])(
	preact_material_components_List.ItemIcon,
	null,
	'account_circle'
);

var _ref5 = Object(preact_min["h"])(
	preact_material_components_Dialog.Header,
	null,
	'Settings'
);

var _ref6 = Object(preact_min["h"])(
	preact_material_components_Dialog.Footer,
	null,
	Object(preact_min["h"])(
		preact_material_components_Dialog.FooterButton,
		{ accept: true },
		'okay'
	)
);

var header_Header = function (_Component) {
	header__inherits(Header, _Component);

	function Header() {
		var _temp, _this, _ret;

		header__classCallCheck(this, Header);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = header__possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.openDrawer = function () {
			return _this.drawer.MDComponent.open = true;
		}, _this.openSettings = function () {
			return _this.dialog.MDComponent.show();
		}, _this.drawerRef = function (drawer) {
			return _this.drawer = drawer;
		}, _this.dialogRef = function (dialog) {
			return _this.dialog = dialog;
		}, _this.linkTo = function (path) {
			return function () {
				route(path);
				_this.closeDrawer();
			};
		}, _this.goHome = _this.linkTo('/'), _this.goToMyProfile = _this.linkTo('/profile'), _this.toggleDarkTheme = function () {
			_this.setState({
				darkThemeEnabled: !_this.state.darkThemeEnabled
			}, function () {
				if (_this.state.darkThemeEnabled) {
					document.body.classList.add('mdc-theme--dark');
				} else {
					document.body.classList.remove('mdc-theme--dark');
				}
			});
		}, _temp), header__possibleConstructorReturn(_this, _ret);
	}

	Header.prototype.closeDrawer = function closeDrawer() {
		this.drawer.MDComponent.open = false;
		this.state = {
			darkThemeEnabled: false
		};
	};

	Header.prototype.render = function render() {
		return Object(preact_min["h"])(
			'div',
			null,
			Object(preact_min["h"])(
				preact_material_components_Toolbar,
				{ className: 'toolbar' },
				Object(preact_min["h"])(
					preact_material_components_Toolbar.Row,
					null,
					Object(preact_min["h"])(
						preact_material_components_Toolbar.Section,
						{ 'align-start': true },
						Object(preact_min["h"])(
							preact_material_components_Toolbar.Icon,
							{ menu: true, onClick: this.openDrawer },
							'menu'
						),
						header__ref
					),
					Object(preact_min["h"])(
						preact_material_components_Toolbar.Section,
						{ 'align-end': true, onClick: this.openSettings },
						header__ref2
					)
				)
			),
			Object(preact_min["h"])(
				preact_material_components_Drawer.TemporaryDrawer,
				{ ref: this.drawerRef },
				Object(preact_min["h"])(
					preact_material_components_Drawer.TemporaryDrawerContent,
					null,
					Object(preact_min["h"])(
						preact_material_components_List,
						null,
						Object(preact_min["h"])(
							preact_material_components_List.LinkItem,
							{ onClick: this.goHome },
							_ref3,
							'Home'
						),
						Object(preact_min["h"])(
							preact_material_components_List.LinkItem,
							{ onClick: this.goToMyProfile },
							_ref4,
							'Profile'
						)
					)
				)
			),
			Object(preact_min["h"])(
				preact_material_components_Dialog,
				{ ref: this.dialogRef },
				_ref5,
				Object(preact_min["h"])(
					preact_material_components_Dialog.Body,
					null,
					Object(preact_min["h"])(
						'div',
						null,
						'Enable dark theme ',
						Object(preact_min["h"])(Switch_Switch, { onClick: this.toggleDarkTheme })
					)
				),
				_ref6
			)
		);
	};

	return Header;
}(preact_min["Component"]);


// CONCATENATED MODULE: ../node_modules/preact-material-components/Card/index.js
function Card__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Card__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Card__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Card__extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }return target;
};





var Card = function (_MaterialComponent) {
  Card__inherits(Card, _MaterialComponent);

  function Card() {
    Card__classCallCheck(this, Card);

    var _this = Card__possibleConstructorReturn(this, _MaterialComponent.call(this));

    _this.componentName = "card";
    _this._mdcProps = ["theme-dark"];
    return _this;
  }

  return Card;
}(MaterialComponent_MaterialComponent);

var Card_CardSection = function (_MaterialComponent2) {
  Card__inherits(CardSection, _MaterialComponent2);

  function CardSection() {
    Card__classCallCheck(this, CardSection);

    var _this2 = Card__possibleConstructorReturn(this, _MaterialComponent2.call(this));

    _this2.componentName = "";
    return _this2;
  }

  CardSection.prototype.materialDom = function materialDom(props) {
    return Object(preact_min["h"])("section", props, props.children);
  };

  return CardSection;
}(MaterialComponent_MaterialComponent);

var CardPrimary = function (_CardSection) {
  Card__inherits(CardPrimary, _CardSection);

  function CardPrimary() {
    Card__classCallCheck(this, CardPrimary);

    var _this3 = Card__possibleConstructorReturn(this, _CardSection.call(this));

    _this3.componentName = "card__primary";
    return _this3;
  }

  return CardPrimary;
}(Card_CardSection);

var CardSupportingText = function (_CardSection2) {
  Card__inherits(CardSupportingText, _CardSection2);

  function CardSupportingText() {
    Card__classCallCheck(this, CardSupportingText);

    var _this4 = Card__possibleConstructorReturn(this, _CardSection2.call(this));

    _this4.componentName = "card__supporting-text";
    return _this4;
  }

  return CardSupportingText;
}(Card_CardSection);

var CardActions = function (_CardSection3) {
  Card__inherits(CardActions, _CardSection3);

  function CardActions() {
    Card__classCallCheck(this, CardActions);

    var _this5 = Card__possibleConstructorReturn(this, _CardSection3.call(this));

    _this5.componentName = "card__actions";
    _this5._mdcProps = ["vertical"];
    return _this5;
  }

  return CardActions;
}(Card_CardSection);

var CardMedia = function (_CardSection4) {
  Card__inherits(CardMedia, _CardSection4);

  function CardMedia() {
    Card__classCallCheck(this, CardMedia);

    var _this6 = Card__possibleConstructorReturn(this, _CardSection4.call(this));

    _this6.componentName = "card__media";
    return _this6;
  }

  return CardMedia;
}(Card_CardSection);

var Card_CardAction = function (_Button) {
  Card__inherits(CardAction, _Button);

  function CardAction() {
    Card__classCallCheck(this, CardAction);

    var _this7 = Card__possibleConstructorReturn(this, _Button.call(this));

    _this7.componentName = "card__action";
    return _this7;
  }

  CardAction.prototype.materialDom = function materialDom(props) {
    var _this8 = this;

    return Object(preact_min["h"])("button", Card__extends({
      className: "mdc-button mdc-button--compact"
    }, props, {
      ref: function ref(control) {
        _this8.control = control;
      }
    }), props.children);
  };

  return CardAction;
}(preact_material_components_Button);

var Card_CardTitle = function (_MaterialComponent3) {
  Card__inherits(CardTitle, _MaterialComponent3);

  function CardTitle() {
    Card__classCallCheck(this, CardTitle);

    var _this9 = Card__possibleConstructorReturn(this, _MaterialComponent3.call(this));

    _this9.componentName = "card__title";
    _this9._mdcProps = ["large"];
    return _this9;
  }

  CardTitle.prototype.materialDom = function materialDom(props) {
    return Object(preact_min["h"])("h1", props, props.children);
  };

  return CardTitle;
}(MaterialComponent_MaterialComponent);

var Card_CardSubtitle = function (_MaterialComponent4) {
  Card__inherits(CardSubtitle, _MaterialComponent4);

  function CardSubtitle() {
    Card__classCallCheck(this, CardSubtitle);

    var _this10 = Card__possibleConstructorReturn(this, _MaterialComponent4.call(this));

    _this10.componentName = "card__subtitle";
    return _this10;
  }

  CardSubtitle.prototype.materialDom = function materialDom(props) {
    return Object(preact_min["h"])("h2", props, props.children);
  };

  return CardSubtitle;
}(MaterialComponent_MaterialComponent);

var CardHorizontalBlock = function (_CardSection5) {
  Card__inherits(CardHorizontalBlock, _CardSection5);

  function CardHorizontalBlock() {
    Card__classCallCheck(this, CardHorizontalBlock);

    var _this11 = Card__possibleConstructorReturn(this, _CardSection5.call(this));

    _this11.componentName = "card__horizontal-block";
    return _this11;
  }

  return CardHorizontalBlock;
}(Card_CardSection);

var Card_CardMediaItem = function (_MaterialComponent5) {
  Card__inherits(CardMediaItem, _MaterialComponent5);

  function CardMediaItem() {
    Card__classCallCheck(this, CardMediaItem);

    var _this12 = Card__possibleConstructorReturn(this, _MaterialComponent5.call(this));

    _this12.componentName = "card__media-item";
    _this12._mdcProps = [];
    return _this12;
  }

  CardMediaItem.prototype.materialDom = function materialDom(props) {
    var className = "";
    if (props.x) {
      className = "mdc-card__media-item--" + props.x + "x";
    }
    return Object(preact_min["h"])("img", Card__extends({ className: className }, props));
  };

  return CardMediaItem;
}(MaterialComponent_MaterialComponent);

Card.Primary = CardPrimary;
Card.SupportingText = CardSupportingText;
Card.Actions = CardActions;
Card.Action = Card_CardAction;
Card.Media = CardMedia;
Card.Title = Card_CardTitle;
Card.Subtitle = Card_CardSubtitle;
Card.HorizontalBlock = CardHorizontalBlock;
Card.MediaItem = Card_CardMediaItem;

/* harmony default export */ var preact_material_components_Card = (Card);
// EXTERNAL MODULE: ../node_modules/lodash.map/index.js
var lodash_map = __webpack_require__("yYyN");
var lodash_map_default = /*#__PURE__*/__webpack_require__.n(lodash_map);

// CONCATENATED MODULE: ../node_modules/@firebase/util/dist/esm/src/constants.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @fileoverview Firebase constants.  Some of these (@defines) can be overridden at compile-time.
 */
var CONSTANTS = {
  /**
   * @define {boolean} Whether this is the client Node.js SDK.
   */
  NODE_CLIENT: false,
  /**
   * @define {boolean} Whether this is the Admin Node.js SDK.
   */
  NODE_ADMIN: false,
  /**
   * Firebase SDK Version
   */
  SDK_VERSION: '${JSCORE_VERSION}'
};

//# sourceMappingURL=constants.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/util/dist/esm/src/assert.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Throws an error if the provided assertion is falsy
 * @param {*} assertion The assertion to be tested for falsiness
 * @param {!string} message The message to display if the check fails
 */
var assert = function assert(assertion, message) {
  if (!assertion) {
    throw assert_assertionError(message);
  }
};
/**
 * Returns an Error object suitable for throwing.
 * @param {string} message
 * @return {!Error}
 */
var assert_assertionError = function assertionError(message) {
  return new Error('Firebase Database (' + CONSTANTS.SDK_VERSION + ') INTERNAL ASSERT FAILED: ' + message);
};

//# sourceMappingURL=assert.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/util/dist/esm/src/crypt.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var crypt_stringToByteArray = function stringToByteArray(str) {
    var output = [],
        p = 0;
    for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        while (c > 255) {
            output[p++] = c & 255;
            c >>= 8;
        }
        output[p++] = c;
    }
    return output;
};
/**
 * Turns an array of numbers into the string given by the concatenation of the
 * characters to which the numbers correspond.
 * @param {Array<number>} bytes Array of numbers representing characters.
 * @return {string} Stringification of the array.
 */
var byteArrayToString = function byteArrayToString(bytes) {
    var CHUNK_SIZE = 8192;
    // Special-case the simple case for speed's sake.
    if (bytes.length < CHUNK_SIZE) {
        return String.fromCharCode.apply(null, bytes);
    }
    // The remaining logic splits conversion by chunks since
    // Function#apply() has a maximum parameter count.
    // See discussion: http://goo.gl/LrWmZ9
    var str = '';
    for (var i = 0; i < bytes.length; i += CHUNK_SIZE) {
        var chunk = bytes.slice(i, i + CHUNK_SIZE);
        str += String.fromCharCode.apply(null, chunk);
    }
    return str;
};
// Static lookup maps, lazily populated by init_()
var crypt_base64 = {
    /**
     * Maps bytes to characters.
     * @type {Object}
     * @private
     */
    byteToCharMap_: null,
    /**
     * Maps characters to bytes.
     * @type {Object}
     * @private
     */
    charToByteMap_: null,
    /**
     * Maps bytes to websafe characters.
     * @type {Object}
     * @private
     */
    byteToCharMapWebSafe_: null,
    /**
     * Maps websafe characters to bytes.
     * @type {Object}
     * @private
     */
    charToByteMapWebSafe_: null,
    /**
     * Our default alphabet, shared between
     * ENCODED_VALS and ENCODED_VALS_WEBSAFE
     * @type {string}
     */
    ENCODED_VALS_BASE: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' + 'abcdefghijklmnopqrstuvwxyz' + '0123456789',
    /**
     * Our default alphabet. Value 64 (=) is special; it means "nothing."
     * @type {string}
     */
    get ENCODED_VALS() {
        return this.ENCODED_VALS_BASE + '+/=';
    },
    /**
     * Our websafe alphabet.
     * @type {string}
     */
    get ENCODED_VALS_WEBSAFE() {
        return this.ENCODED_VALS_BASE + '-_.';
    },
    /**
     * Whether this browser supports the atob and btoa functions. This extension
     * started at Mozilla but is now implemented by many browsers. We use the
     * ASSUME_* variables to avoid pulling in the full useragent detection library
     * but still allowing the standard per-browser compilations.
     *
     * @type {boolean}
     */
    HAS_NATIVE_SUPPORT: typeof atob === 'function',
    /**
     * Base64-encode an array of bytes.
     *
     * @param {Array<number>|Uint8Array} input An array of bytes (numbers with
     *     value in [0, 255]) to encode.
     * @param {boolean=} opt_webSafe Boolean indicating we should use the
     *     alternative alphabet.
     * @return {string} The base64 encoded string.
     */
    encodeByteArray: function encodeByteArray(input, opt_webSafe) {
        if (!Array.isArray(input)) {
            throw Error('encodeByteArray takes an array as a parameter');
        }
        this.init_();
        var byteToCharMap = opt_webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;
        var output = [];
        for (var i = 0; i < input.length; i += 3) {
            var byte1 = input[i];
            var haveByte2 = i + 1 < input.length;
            var byte2 = haveByte2 ? input[i + 1] : 0;
            var haveByte3 = i + 2 < input.length;
            var byte3 = haveByte3 ? input[i + 2] : 0;
            var outByte1 = byte1 >> 2;
            var outByte2 = (byte1 & 0x03) << 4 | byte2 >> 4;
            var outByte3 = (byte2 & 0x0f) << 2 | byte3 >> 6;
            var outByte4 = byte3 & 0x3f;
            if (!haveByte3) {
                outByte4 = 64;
                if (!haveByte2) {
                    outByte3 = 64;
                }
            }
            output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
        }
        return output.join('');
    },
    /**
     * Base64-encode a string.
     *
     * @param {string} input A string to encode.
     * @param {boolean=} opt_webSafe If true, we should use the
     *     alternative alphabet.
     * @return {string} The base64 encoded string.
     */
    encodeString: function encodeString(input, opt_webSafe) {
        // Shortcut for Mozilla browsers that implement
        // a native base64 encoder in the form of "btoa/atob"
        if (this.HAS_NATIVE_SUPPORT && !opt_webSafe) {
            return btoa(input);
        }
        return this.encodeByteArray(crypt_stringToByteArray(input), opt_webSafe);
    },
    /**
     * Base64-decode a string.
     *
     * @param {string} input to decode.
     * @param {boolean=} opt_webSafe True if we should use the
     *     alternative alphabet.
     * @return {string} string representing the decoded value.
     */
    decodeString: function decodeString(input, opt_webSafe) {
        // Shortcut for Mozilla browsers that implement
        // a native base64 encoder in the form of "btoa/atob"
        if (this.HAS_NATIVE_SUPPORT && !opt_webSafe) {
            return atob(input);
        }
        return byteArrayToString(this.decodeStringToByteArray(input, opt_webSafe));
    },
    /**
     * Base64-decode a string.
     *
     * In base-64 decoding, groups of four characters are converted into three
     * bytes.  If the encoder did not apply padding, the input length may not
     * be a multiple of 4.
     *
     * In this case, the last group will have fewer than 4 characters, and
     * padding will be inferred.  If the group has one or two characters, it decodes
     * to one byte.  If the group has three characters, it decodes to two bytes.
     *
     * @param {string} input Input to decode.
     * @param {boolean=} opt_webSafe True if we should use the web-safe alphabet.
     * @return {!Array<number>} bytes representing the decoded value.
     */
    decodeStringToByteArray: function decodeStringToByteArray(input, opt_webSafe) {
        this.init_();
        var charToByteMap = opt_webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;
        var output = [];
        for (var i = 0; i < input.length;) {
            var byte1 = charToByteMap[input.charAt(i++)];
            var haveByte2 = i < input.length;
            var byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
            ++i;
            var haveByte3 = i < input.length;
            var byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;
            ++i;
            var haveByte4 = i < input.length;
            var byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;
            ++i;
            if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {
                throw Error();
            }
            var outByte1 = byte1 << 2 | byte2 >> 4;
            output.push(outByte1);
            if (byte3 != 64) {
                var outByte2 = byte2 << 4 & 0xf0 | byte3 >> 2;
                output.push(outByte2);
                if (byte4 != 64) {
                    var outByte3 = byte3 << 6 & 0xc0 | byte4;
                    output.push(outByte3);
                }
            }
        }
        return output;
    },
    /**
     * Lazy static initialization function. Called before
     * accessing any of the static map variables.
     * @private
     */
    init_: function init_() {
        if (!this.byteToCharMap_) {
            this.byteToCharMap_ = {};
            this.charToByteMap_ = {};
            this.byteToCharMapWebSafe_ = {};
            this.charToByteMapWebSafe_ = {};
            // We want quick mappings back and forth, so we precompute two maps.
            for (var i = 0; i < this.ENCODED_VALS.length; i++) {
                this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);
                this.charToByteMap_[this.byteToCharMap_[i]] = i;
                this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);
                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;
                // Be forgiving when decoding and correctly decode both encodings.
                if (i >= this.ENCODED_VALS_BASE.length) {
                    this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;
                    this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;
                }
            }
        }
    }
};
/**
 * URL-safe base64 encoding
 * @param {!string} str
 * @return {!string}
 */
var base64Encode = function base64Encode(str) {
    var utf8Bytes = crypt_stringToByteArray(str);
    return crypt_base64.encodeByteArray(utf8Bytes, true);
};
/**
 * URL-safe base64 decoding
 *
 * NOTE: DO NOT use the global atob() function - it does NOT support the
 * base64Url variant encoding.
 *
 * @param {string} str To be decoded
 * @return {?string} Decoded result, if possible
 */
var base64Decode = function base64Decode(str) {
    try {
        return crypt_base64.decodeString(str, true);
    } catch (e) {
        console.error('base64Decode failed: ', e);
    }
    return null;
};

//# sourceMappingURL=crypt.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/util/dist/esm/src/deepCopy.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Do a deep-copy of basic JavaScript Objects or Arrays.
 */
function deepCopy(value) {
    return deepExtend(undefined, value);
}
/**
 * Copy properties from source to target (recursively allows extension
 * of Objects and Arrays).  Scalar values in the target are over-written.
 * If target is undefined, an object of the appropriate type will be created
 * (and returned).
 *
 * We recursively copy all child properties of plain Objects in the source- so
 * that namespace- like dictionaries are merged.
 *
 * Note that the target can be a function, in which case the properties in
 * the source Object are copied onto it as static properties of the Function.
 */
function deepExtend(target, source) {
    if (!(source instanceof Object)) {
        return source;
    }
    switch (source.constructor) {
        case Date:
            // Treat Dates like scalars; if the target date object had any child
            // properties - they will be lost!
            var dateValue = source;
            return new Date(dateValue.getTime());
        case Object:
            if (target === undefined) {
                target = {};
            }
            break;
        case Array:
            // Always copy the array source and overwrite the target.
            target = [];
            break;
        default:
            // Not a plain Object - treat it as a scalar.
            return source;
    }
    for (var prop in source) {
        if (!source.hasOwnProperty(prop)) {
            continue;
        }
        target[prop] = deepExtend(target[prop], source[prop]);
    }
    return target;
}
// TODO: Really needed (for JSCompiler type checking)?
function patchProperty(obj, prop, value) {
    obj[prop] = value;
}

//# sourceMappingURL=deepCopy.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/util/dist/esm/src/deferred.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var Deferred = /** @class */function () {
    function Deferred() {
        var _this = this;
        this.promise = new Promise(function (resolve, reject) {
            _this.resolve = resolve;
            _this.reject = reject;
        });
    }
    /**
     * Our API internals are not promiseified and cannot because our callback APIs have subtle expectations around
     * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
     * and returns a node-style callback which will resolve or reject the Deferred's promise.
     * @param {((?function(?(Error)): (?|undefined))| (?function(?(Error),?=): (?|undefined)))=} callback
     * @return {!function(?(Error), ?=)}
     */
    Deferred.prototype.wrapCallback = function (callback) {
        var _this = this;
        return function (error, value) {
            if (error) {
                _this.reject(error);
            } else {
                _this.resolve(value);
            }
            if (typeof callback === 'function') {
                // Attaching noop handler just in case developer wasn't expecting
                // promises
                _this.promise.catch(function () {});
                // Some of our callbacks don't expect a value and our own tests
                // assert that the parameter length is 1
                if (callback.length === 1) {
                    callback(error);
                } else {
                    callback(error, value);
                }
            }
        };
    };
    return Deferred;
}();


//# sourceMappingURL=deferred.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/util/dist/esm/src/environment.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns navigator.userAgent string or '' if it's not defined.
 * @return {string} user agent string
 */
var getUA = function getUA() {
    if (typeof navigator !== 'undefined' && typeof navigator['userAgent'] === 'string') {
        return navigator['userAgent'];
    } else {
        return '';
    }
};
/**
 * Detect Cordova / PhoneGap / Ionic frameworks on a mobile device.
 *
 * Deliberately does not rely on checking `file://` URLs (as this fails PhoneGap in the Ripple emulator) nor
 * Cordova `onDeviceReady`, which would normally wait for a callback.
 *
 * @return {boolean} isMobileCordova
 */
var isMobileCordova = function isMobileCordova() {
    return typeof window !== 'undefined' && !!(window['cordova'] || window['phonegap'] || window['PhoneGap']) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA());
};
/**
 * Detect React Native.
 *
 * @return {boolean} True if ReactNative environment is detected.
 */
var isReactNative = function isReactNative() {
    return typeof navigator === 'object' && navigator['product'] === 'ReactNative';
};
/**
 * Detect Node.js.
 *
 * @return {boolean} True if Node.js environment is detected.
 */
var environment_isNodeSdk = function isNodeSdk() {
    return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;
};

//# sourceMappingURL=environment.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/util/dist/esm/src/errors.js
var ERROR_NAME = 'FirebaseError';
var captureStackTrace = Error.captureStackTrace;
// Export for faking in tests
function patchCapture(captureFake) {
    var result = captureStackTrace;
    captureStackTrace = captureFake;
    return result;
}
var FirebaseError = /** @class */function () {
    function FirebaseError(code, message) {
        this.code = code;
        this.message = message;
        var stack;
        // We want the stack value, if implemented by Error
        if (captureStackTrace) {
            // Patches this.stack, omitted calls above ErrorFactory#create
            captureStackTrace(this, ErrorFactory.prototype.create);
        } else {
            var err_1 = Error.apply(this, arguments);
            this.name = ERROR_NAME;
            // Make non-enumerable getter for the property.
            Object.defineProperty(this, 'stack', {
                get: function get() {
                    return err_1.stack;
                }
            });
        }
    }
    return FirebaseError;
}();

// Back-door inheritance
FirebaseError.prototype = Object.create(Error.prototype);
FirebaseError.prototype.constructor = FirebaseError;
FirebaseError.prototype.name = ERROR_NAME;
var ErrorFactory = /** @class */function () {
    function ErrorFactory(service, serviceName, errors) {
        this.service = service;
        this.serviceName = serviceName;
        this.errors = errors;
        // Matches {$name}, by default.
        this.pattern = /\{\$([^}]+)}/g;
        // empty
    }
    ErrorFactory.prototype.create = function (code, data) {
        if (data === undefined) {
            data = {};
        }
        var template = this.errors[code];
        var fullCode = this.service + '/' + code;
        var message;
        if (template === undefined) {
            message = 'Error';
        } else {
            message = template.replace(this.pattern, function (match, key) {
                var value = data[key];
                return value !== undefined ? value.toString() : '<' + key + '?>';
            });
        }
        // Service: Error message (service/code).
        message = this.serviceName + ': ' + message + ' (' + fullCode + ').';
        var err = new FirebaseError(fullCode, message);
        // Populate the Error object with message parts for programmatic
        // accesses (e.g., e.file).
        for (var prop in data) {
            if (!data.hasOwnProperty(prop) || prop.slice(-1) === '_') {
                continue;
            }
            err[prop] = data[prop];
        }
        return err;
    };
    return ErrorFactory;
}();


//# sourceMappingURL=errors.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/util/dist/esm/src/json.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Evaluates a JSON string into a javascript object.
 *
 * @param {string} str A string containing JSON.
 * @return {*} The javascript object representing the specified JSON.
 */
function jsonEval(str) {
  return JSON.parse(str);
}
/**
 * Returns JSON representing a javascript object.
 * @param {*} data Javascript object to be stringified.
 * @return {string} The JSON contents of the object.
 */
function stringify(data) {
  return JSON.stringify(data);
}

//# sourceMappingURL=json.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/util/dist/esm/src/jwt.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Decodes a Firebase auth. token into constituent parts.
 *
 * Notes:
 * - May return with invalid / incomplete claims if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 *
 * @param {?string} token
 * @return {{header: *, claims: *, data: *, signature: string}}
 */
var jwt_decode = function decode(token) {
    var header = {},
        claims = {},
        data = {},
        signature = '';
    try {
        var parts = token.split('.');
        header = jsonEval(base64Decode(parts[0]) || '');
        claims = jsonEval(base64Decode(parts[1]) || '');
        signature = parts[2];
        data = claims['d'] || {};
        delete claims['d'];
    } catch (e) {}
    return {
        header: header,
        claims: claims,
        data: data,
        signature: signature
    };
};
/**
 * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the
 * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 *
 * @param {?string} token
 * @return {boolean}
 */
var isValidTimestamp = function isValidTimestamp(token) {
    var claims = jwt_decode(token).claims,
        now = Math.floor(new Date().getTime() / 1000),
        validSince,
        validUntil;
    if (typeof claims === 'object') {
        if (claims.hasOwnProperty('nbf')) {
            validSince = claims['nbf'];
        } else if (claims.hasOwnProperty('iat')) {
            validSince = claims['iat'];
        }
        if (claims.hasOwnProperty('exp')) {
            validUntil = claims['exp'];
        } else {
            // token will expire after 24h by default
            validUntil = validSince + 86400;
        }
    }
    return now && validSince && validUntil && now >= validSince && now <= validUntil;
};
/**
 * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.
 *
 * Notes:
 * - May return null if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 *
 * @param {?string} token
 * @return {?number}
 */
var issuedAtTime = function issuedAtTime(token) {
    var claims = jwt_decode(token).claims;
    if (typeof claims === 'object' && claims.hasOwnProperty('iat')) {
        return claims['iat'];
    }
    return null;
};
/**
 * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time and non-empty
 * signature.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 *
 * @param {?string} token
 * @return {boolean}
 */
var isValidFormat = function isValidFormat(token) {
    var decoded = jwt_decode(token),
        claims = decoded.claims;
    return !!decoded.signature && !!claims && typeof claims === 'object' && claims.hasOwnProperty('iat');
};
/**
 * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.
 *
 * Notes:
 * - May return a false negative if there's no native base64 decoding support.
 * - Doesn't check if the token is actually valid.
 *
 * @param {?string} token
 * @return {boolean}
 */
var isAdmin = function isAdmin(token) {
    var claims = jwt_decode(token).claims;
    return typeof claims === 'object' && claims['admin'] === true;
};

//# sourceMappingURL=jwt.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/util/dist/esm/src/obj.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// See http://www.devthought.com/2012/01/18/an-object-is-not-a-hash/
var contains = function contains(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
};
var safeGet = function safeGet(obj, key) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) return obj[key];
    // else return undefined.
};
/**
 * Enumerates the keys/values in an object, excluding keys defined on the prototype.
 *
 * @param {?Object.<K,V>} obj Object to enumerate.
 * @param {!function(K, V)} fn Function to call for each key and value.
 * @template K,V
 */
var forEach = function forEach(obj, fn) {
    for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn(key, obj[key]);
        }
    }
};
/**
 * Copies all the (own) properties from one object to another.
 * @param {!Object} objTo
 * @param {!Object} objFrom
 * @return {!Object} objTo
 */
var extend = function extend(objTo, objFrom) {
    forEach(objFrom, function (key, value) {
        objTo[key] = value;
    });
    return objTo;
};
/**
 * Returns a clone of the specified object.
 * @param {!Object} obj
 * @return {!Object} cloned obj.
 */
var clone = function clone(obj) {
    return extend({}, obj);
};
/**
 * Returns true if obj has typeof "object" and is not null.  Unlike goog.isObject(), does not return true
 * for functions.
 *
 * @param obj {*} A potential object.
 * @returns {boolean} True if it's an object.
 */
var isNonNullObject = function isNonNullObject(obj) {
    return typeof obj === 'object' && obj !== null;
};
var isEmpty = function isEmpty(obj) {
    for (var key in obj) {
        return false;
    }
    return true;
};
var getCount = function getCount(obj) {
    var rv = 0;
    for (var key in obj) {
        rv++;
    }
    return rv;
};
var obj_map = function map(obj, f, opt_obj) {
    var res = {};
    for (var key in obj) {
        res[key] = f.call(opt_obj, obj[key], key, obj);
    }
    return res;
};
var findKey = function findKey(obj, fn, opt_this) {
    for (var key in obj) {
        if (fn.call(opt_this, obj[key], key, obj)) {
            return key;
        }
    }
    return undefined;
};
var findValue = function findValue(obj, fn, opt_this) {
    var key = findKey(obj, fn, opt_this);
    return key && obj[key];
};
var getAnyKey = function getAnyKey(obj) {
    for (var key in obj) {
        return key;
    }
};
var getValues = function getValues(obj) {
    var res = [];
    var i = 0;
    for (var key in obj) {
        res[i++] = obj[key];
    }
    return res;
};
/**
 * Tests whether every key/value pair in an object pass the test implemented
 * by the provided function
 *
 * @param {?Object.<K,V>} obj Object to test.
 * @param {!function(K, V)} fn Function to call for each key and value.
 * @template K,V
 */
var every = function every(obj, fn) {
    for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            if (!fn(key, obj[key])) {
                return false;
            }
        }
    }
    return true;
};

//# sourceMappingURL=obj.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/util/dist/esm/src/query.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Returns a querystring-formatted string (e.g. &arg=val&arg2=val2) from a params
 * object (e.g. {arg: 'val', arg2: 'val2'})
 * Note: You must prepend it with ? when adding it to a URL.
 *
 * @param {!Object} querystringParams
 * @return {string}
 */
var query_querystring = function querystring(querystringParams) {
    var params = [];
    forEach(querystringParams, function (key, value) {
        if (Array.isArray(value)) {
            value.forEach(function (arrayVal) {
                params.push(encodeURIComponent(key) + '=' + encodeURIComponent(arrayVal));
            });
        } else {
            params.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
        }
    });
    return params.length ? '&' + params.join('&') : '';
};
/**
 * Decodes a querystring (e.g. ?arg=val&arg2=val2) into a params object (e.g. {arg: 'val', arg2: 'val2'})
 *
 * @param {string} querystring
 * @return {!Object}
 */
var querystringDecode = function querystringDecode(querystring) {
    var obj = {};
    var tokens = querystring.replace(/^\?/, '').split('&');
    tokens.forEach(function (token) {
        if (token) {
            var key = token.split('=');
            obj[key[0]] = key[1];
        }
    });
    return obj;
};

//# sourceMappingURL=query.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/util/dist/esm/src/hash.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Copyright 2011 The Closure Library Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS-IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
/**
 * @fileoverview Abstract cryptographic hash interface.
 *
 * See Sha1 and Md5 for sample implementations.
 *
 */
/**
 * Create a cryptographic hash instance.
 *
 * @constructor
 * @struct
 */
var Hash = /** @class */function () {
  function Hash() {
    /**
     * The block size for the hasher.
     * @type {number}
     */
    this.blockSize = -1;
  }
  return Hash;
}();


//# sourceMappingURL=hash.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/util/dist/esm/src/sha1.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();

/**
 * @fileoverview SHA-1 cryptographic hash.
 * Variable names follow the notation in FIPS PUB 180-3:
 * http://csrc.nist.gov/publications/fips/fips180-3/fips180-3_final.pdf.
 *
 * Usage:
 *   var sha1 = new sha1();
 *   sha1.update(bytes);
 *   var hash = sha1.digest();
 *
 * Performance:
 *   Chrome 23:   ~400 Mbit/s
 *   Firefox 16:  ~250 Mbit/s
 *
 */
/**
 * SHA-1 cryptographic hash constructor.
 *
 * The properties declared here are discussed in the above algorithm document.
 * @constructor
 * @extends {Hash}
 * @final
 * @struct
 */
var Sha1 = /** @class */function (_super) {
    __extends(Sha1, _super);
    function Sha1() {
        var _this = _super.call(this) || this;
        /**
         * Holds the previous values of accumulated variables a-e in the compress_
         * function.
         * @type {!Array<number>}
         * @private
         */
        _this.chain_ = [];
        /**
         * A buffer holding the partially computed hash result.
         * @type {!Array<number>}
         * @private
         */
        _this.buf_ = [];
        /**
         * An array of 80 bytes, each a part of the message to be hashed.  Referred to
         * as the message schedule in the docs.
         * @type {!Array<number>}
         * @private
         */
        _this.W_ = [];
        /**
         * Contains data needed to pad messages less than 64 bytes.
         * @type {!Array<number>}
         * @private
         */
        _this.pad_ = [];
        /**
         * @private {number}
         */
        _this.inbuf_ = 0;
        /**
         * @private {number}
         */
        _this.total_ = 0;
        _this.blockSize = 512 / 8;
        _this.pad_[0] = 128;
        for (var i = 1; i < _this.blockSize; ++i) {
            _this.pad_[i] = 0;
        }
        _this.reset();
        return _this;
    }
    Sha1.prototype.reset = function () {
        this.chain_[0] = 0x67452301;
        this.chain_[1] = 0xefcdab89;
        this.chain_[2] = 0x98badcfe;
        this.chain_[3] = 0x10325476;
        this.chain_[4] = 0xc3d2e1f0;
        this.inbuf_ = 0;
        this.total_ = 0;
    };
    /**
     * Internal compress helper function.
     * @param {!Array<number>|!Uint8Array|string} buf Block to compress.
     * @param {number=} opt_offset Offset of the block in the buffer.
     * @private
     */
    Sha1.prototype.compress_ = function (buf, opt_offset) {
        if (!opt_offset) {
            opt_offset = 0;
        }
        var W = this.W_;
        // get 16 big endian words
        if (typeof buf === 'string') {
            for (var i = 0; i < 16; i++) {
                // TODO(user): [bug 8140122] Recent versions of Safari for Mac OS and iOS
                // have a bug that turns the post-increment ++ operator into pre-increment
                // during JIT compilation.  We have code that depends heavily on SHA-1 for
                // correctness and which is affected by this bug, so I've removed all uses
                // of post-increment ++ in which the result value is used.  We can revert
                // this change once the Safari bug
                // (https://bugs.webkit.org/show_bug.cgi?id=109036) has been fixed and
                // most clients have been updated.
                W[i] = buf.charCodeAt(opt_offset) << 24 | buf.charCodeAt(opt_offset + 1) << 16 | buf.charCodeAt(opt_offset + 2) << 8 | buf.charCodeAt(opt_offset + 3);
                opt_offset += 4;
            }
        } else {
            for (var i = 0; i < 16; i++) {
                W[i] = buf[opt_offset] << 24 | buf[opt_offset + 1] << 16 | buf[opt_offset + 2] << 8 | buf[opt_offset + 3];
                opt_offset += 4;
            }
        }
        // expand to 80 words
        for (var i = 16; i < 80; i++) {
            var t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
            W[i] = (t << 1 | t >>> 31) & 0xffffffff;
        }
        var a = this.chain_[0];
        var b = this.chain_[1];
        var c = this.chain_[2];
        var d = this.chain_[3];
        var e = this.chain_[4];
        var f, k;
        // TODO(user): Try to unroll this loop to speed up the computation.
        for (var i = 0; i < 80; i++) {
            if (i < 40) {
                if (i < 20) {
                    f = d ^ b & (c ^ d);
                    k = 0x5a827999;
                } else {
                    f = b ^ c ^ d;
                    k = 0x6ed9eba1;
                }
            } else {
                if (i < 60) {
                    f = b & c | d & (b | c);
                    k = 0x8f1bbcdc;
                } else {
                    f = b ^ c ^ d;
                    k = 0xca62c1d6;
                }
            }
            var t = (a << 5 | a >>> 27) + f + e + k + W[i] & 0xffffffff;
            e = d;
            d = c;
            c = (b << 30 | b >>> 2) & 0xffffffff;
            b = a;
            a = t;
        }
        this.chain_[0] = this.chain_[0] + a & 0xffffffff;
        this.chain_[1] = this.chain_[1] + b & 0xffffffff;
        this.chain_[2] = this.chain_[2] + c & 0xffffffff;
        this.chain_[3] = this.chain_[3] + d & 0xffffffff;
        this.chain_[4] = this.chain_[4] + e & 0xffffffff;
    };
    Sha1.prototype.update = function (bytes, opt_length) {
        // TODO(johnlenz): tighten the function signature and remove this check
        if (bytes == null) {
            return;
        }
        if (opt_length === undefined) {
            opt_length = bytes.length;
        }
        var lengthMinusBlock = opt_length - this.blockSize;
        var n = 0;
        // Using local instead of member variables gives ~5% speedup on Firefox 16.
        var buf = this.buf_;
        var inbuf = this.inbuf_;
        // The outer while loop should execute at most twice.
        while (n < opt_length) {
            // When we have no data in the block to top up, we can directly process the
            // input buffer (assuming it contains sufficient data). This gives ~25%
            // speedup on Chrome 23 and ~15% speedup on Firefox 16, but requires that
            // the data is provided in large chunks (or in multiples of 64 bytes).
            if (inbuf == 0) {
                while (n <= lengthMinusBlock) {
                    this.compress_(bytes, n);
                    n += this.blockSize;
                }
            }
            if (typeof bytes === 'string') {
                while (n < opt_length) {
                    buf[inbuf] = bytes.charCodeAt(n);
                    ++inbuf;
                    ++n;
                    if (inbuf == this.blockSize) {
                        this.compress_(buf);
                        inbuf = 0;
                        // Jump to the outer loop so we use the full-block optimization.
                        break;
                    }
                }
            } else {
                while (n < opt_length) {
                    buf[inbuf] = bytes[n];
                    ++inbuf;
                    ++n;
                    if (inbuf == this.blockSize) {
                        this.compress_(buf);
                        inbuf = 0;
                        // Jump to the outer loop so we use the full-block optimization.
                        break;
                    }
                }
            }
        }
        this.inbuf_ = inbuf;
        this.total_ += opt_length;
    };
    /** @override */
    Sha1.prototype.digest = function () {
        var digest = [];
        var totalBits = this.total_ * 8;
        // Add pad 0x80 0x00*.
        if (this.inbuf_ < 56) {
            this.update(this.pad_, 56 - this.inbuf_);
        } else {
            this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
        }
        // Add # bits.
        for (var i = this.blockSize - 1; i >= 56; i--) {
            this.buf_[i] = totalBits & 255;
            totalBits /= 256; // Don't use bit-shifting here!
        }
        this.compress_(this.buf_);
        var n = 0;
        for (var i = 0; i < 5; i++) {
            for (var j = 24; j >= 0; j -= 8) {
                digest[n] = this.chain_[i] >> j & 255;
                ++n;
            }
        }
        return digest;
    };
    return Sha1;
}(Hash);


//# sourceMappingURL=sha1.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/util/dist/esm/src/subscribe.js
/**
 * Helper to make a Subscribe function (just like Promise helps make a
 * Thenable).
 *
 * @param executor Function which can make calls to a single Observer
 *     as a proxy.
 * @param onNoObservers Callback when count of Observers goes to zero.
 */
function createSubscribe(executor, onNoObservers) {
    var proxy = new ObserverProxy(executor, onNoObservers);
    return proxy.subscribe.bind(proxy);
}
/**
 * Implement fan-out for any number of Observers attached via a subscribe
 * function.
 */
var ObserverProxy = /** @class */function () {
    /**
     * @param executor Function which can make calls to a single Observer
     *     as a proxy.
     * @param onNoObservers Callback when count of Observers goes to zero.
     */
    function ObserverProxy(executor, onNoObservers) {
        var _this = this;
        this.observers = [];
        this.unsubscribes = [];
        this.observerCount = 0;
        // Micro-task scheduling by calling task.then().
        this.task = Promise.resolve();
        this.finalized = false;
        this.onNoObservers = onNoObservers;
        // Call the executor asynchronously so subscribers that are called
        // synchronously after the creation of the subscribe function
        // can still receive the very first value generated in the executor.
        this.task.then(function () {
            executor(_this);
        }).catch(function (e) {
            _this.error(e);
        });
    }
    ObserverProxy.prototype.next = function (value) {
        this.forEachObserver(function (observer) {
            observer.next(value);
        });
    };
    ObserverProxy.prototype.error = function (error) {
        this.forEachObserver(function (observer) {
            observer.error(error);
        });
        this.close(error);
    };
    ObserverProxy.prototype.complete = function () {
        this.forEachObserver(function (observer) {
            observer.complete();
        });
        this.close();
    };
    /**
     * Subscribe function that can be used to add an Observer to the fan-out list.
     *
     * - We require that no event is sent to a subscriber sychronously to their
     *   call to subscribe().
     */
    ObserverProxy.prototype.subscribe = function (nextOrObserver, error, complete) {
        var _this = this;
        var observer;
        if (nextOrObserver === undefined && error === undefined && complete === undefined) {
            throw new Error('Missing Observer.');
        }
        // Assemble an Observer object when passed as callback functions.
        if (implementsAnyMethods(nextOrObserver, ['next', 'error', 'complete'])) {
            observer = nextOrObserver;
        } else {
            observer = {
                next: nextOrObserver,
                error: error,
                complete: complete
            };
        }
        if (observer.next === undefined) {
            observer.next = noop;
        }
        if (observer.error === undefined) {
            observer.error = noop;
        }
        if (observer.complete === undefined) {
            observer.complete = noop;
        }
        var unsub = this.unsubscribeOne.bind(this, this.observers.length);
        // Attempt to subscribe to a terminated Observable - we
        // just respond to the Observer with the final error or complete
        // event.
        if (this.finalized) {
            this.task.then(function () {
                try {
                    if (_this.finalError) {
                        observer.error(_this.finalError);
                    } else {
                        observer.complete();
                    }
                } catch (e) {
                    // nothing
                }
                return;
            });
        }
        this.observers.push(observer);
        return unsub;
    };
    // Unsubscribe is synchronous - we guarantee that no events are sent to
    // any unsubscribed Observer.
    ObserverProxy.prototype.unsubscribeOne = function (i) {
        if (this.observers === undefined || this.observers[i] === undefined) {
            return;
        }
        delete this.observers[i];
        this.observerCount -= 1;
        if (this.observerCount === 0 && this.onNoObservers !== undefined) {
            this.onNoObservers(this);
        }
    };
    ObserverProxy.prototype.forEachObserver = function (fn) {
        if (this.finalized) {
            // Already closed by previous event....just eat the additional values.
            return;
        }
        // Since sendOne calls asynchronously - there is no chance that
        // this.observers will become undefined.
        for (var i = 0; i < this.observers.length; i++) {
            this.sendOne(i, fn);
        }
    };
    // Call the Observer via one of it's callback function. We are careful to
    // confirm that the observe has not been unsubscribed since this asynchronous
    // function had been queued.
    ObserverProxy.prototype.sendOne = function (i, fn) {
        var _this = this;
        // Execute the callback asynchronously
        this.task.then(function () {
            if (_this.observers !== undefined && _this.observers[i] !== undefined) {
                try {
                    fn(_this.observers[i]);
                } catch (e) {
                    // Ignore exceptions raised in Observers or missing methods of an
                    // Observer.
                    // Log error to console. b/31404806
                    if (typeof console !== 'undefined' && console.error) {
                        console.error(e);
                    }
                }
            }
        });
    };
    ObserverProxy.prototype.close = function (err) {
        var _this = this;
        if (this.finalized) {
            return;
        }
        this.finalized = true;
        if (err !== undefined) {
            this.finalError = err;
        }
        // Proxy is no longer needed - garbage collect references
        this.task.then(function () {
            _this.observers = undefined;
            _this.onNoObservers = undefined;
        });
    };
    return ObserverProxy;
}();
/** Turn synchronous function into one called asynchronously. */
function subscribe_async(fn, onError) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        Promise.resolve(true).then(function () {
            fn.apply(void 0, args);
        }).catch(function (error) {
            if (onError) {
                onError(error);
            }
        });
    };
}
/**
 * Return true if the object passed in implements any of the named methods.
 */
function implementsAnyMethods(obj, methods) {
    if (typeof obj !== 'object' || obj === null) {
        return false;
    }
    for (var _i = 0, methods_1 = methods; _i < methods_1.length; _i++) {
        var method = methods_1[_i];
        if (method in obj && typeof obj[method] === 'function') {
            return true;
        }
    }
    return false;
}
function noop() {}
// do nothing


//# sourceMappingURL=subscribe.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/util/dist/esm/src/validation.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Check to make sure the appropriate number of arguments are provided for a public function.
 * Throws an error if it fails.
 *
 * @param {!string} fnName The function name
 * @param {!number} minCount The minimum number of arguments to allow for the function call
 * @param {!number} maxCount The maximum number of argument to allow for the function call
 * @param {!number} argCount The actual number of arguments provided.
 */
var validateArgCount = function validateArgCount(fnName, minCount, maxCount, argCount) {
    var argError;
    if (argCount < minCount) {
        argError = 'at least ' + minCount;
    } else if (argCount > maxCount) {
        argError = maxCount === 0 ? 'none' : 'no more than ' + maxCount;
    }
    if (argError) {
        var error = fnName + ' failed: Was called with ' + argCount + (argCount === 1 ? ' argument.' : ' arguments.') + ' Expects ' + argError + '.';
        throw new Error(error);
    }
};
/**
 * Generates a string to prefix an error message about failed argument validation
 *
 * @param {!string} fnName The function name
 * @param {!number} argumentNumber The index of the argument
 * @param {boolean} optional Whether or not the argument is optional
 * @return {!string} The prefix to add to the error thrown for validation.
 */
function errorPrefix(fnName, argumentNumber, optional) {
    var argName = '';
    switch (argumentNumber) {
        case 1:
            argName = optional ? 'first' : 'First';
            break;
        case 2:
            argName = optional ? 'second' : 'Second';
            break;
        case 3:
            argName = optional ? 'third' : 'Third';
            break;
        case 4:
            argName = optional ? 'fourth' : 'Fourth';
            break;
        default:
            throw new Error('errorPrefix called with argumentNumber > 4.  Need to update it?');
    }
    var error = fnName + ' failed: ';
    error += argName + ' argument ';
    return error;
}
/**
 * @param {!string} fnName
 * @param {!number} argumentNumber
 * @param {!string} namespace
 * @param {boolean} optional
 */
function validateNamespace(fnName, argumentNumber, namespace, optional) {
    if (optional && !namespace) return;
    if (typeof namespace !== 'string') {
        //TODO: I should do more validation here. We only allow certain chars in namespaces.
        throw new Error(errorPrefix(fnName, argumentNumber, optional) + 'must be a valid firebase namespace.');
    }
}
function validateCallback(fnName, argumentNumber, callback, optional) {
    if (optional && !callback) return;
    if (typeof callback !== 'function') throw new Error(errorPrefix(fnName, argumentNumber, optional) + 'must be a valid function.');
}
function validateContextObject(fnName, argumentNumber, context, optional) {
    if (optional && !context) return;
    if (typeof context !== 'object' || context === null) throw new Error(errorPrefix(fnName, argumentNumber, optional) + 'must be a valid context object.');
}

//# sourceMappingURL=validation.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/util/dist/esm/src/utf8.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Code originally came from goog.crypt.stringToUtf8ByteArray, but for some reason they
// automatically replaced '\r\n' with '\n', and they didn't handle surrogate pairs,
// so it's been modified.
// Note that not all Unicode characters appear as single characters in JavaScript strings.
// fromCharCode returns the UTF-16 encoding of a character - so some Unicode characters
// use 2 characters in Javascript.  All 4-byte UTF-8 characters begin with a first
// character in the range 0xD800 - 0xDBFF (the first character of a so-called surrogate
// pair).
// See http://www.ecma-international.org/ecma-262/5.1/#sec-15.1.3
/**
 * @param {string} str
 * @return {Array}
 */
var utf8_stringToByteArray = function stringToByteArray(str) {
    var out = [],
        p = 0;
    for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        // Is this the lead surrogate in a surrogate pair?
        if (c >= 0xd800 && c <= 0xdbff) {
            var high = c - 0xd800; // the high 10 bits.
            i++;
            assert(i < str.length, 'Surrogate pair missing trail surrogate.');
            var low = str.charCodeAt(i) - 0xdc00; // the low 10 bits.
            c = 0x10000 + (high << 10) + low;
        }
        if (c < 128) {
            out[p++] = c;
        } else if (c < 2048) {
            out[p++] = c >> 6 | 192;
            out[p++] = c & 63 | 128;
        } else if (c < 65536) {
            out[p++] = c >> 12 | 224;
            out[p++] = c >> 6 & 63 | 128;
            out[p++] = c & 63 | 128;
        } else {
            out[p++] = c >> 18 | 240;
            out[p++] = c >> 12 & 63 | 128;
            out[p++] = c >> 6 & 63 | 128;
            out[p++] = c & 63 | 128;
        }
    }
    return out;
};
/**
 * Calculate length without actually converting; useful for doing cheaper validation.
 * @param {string} str
 * @return {number}
 */
var stringLength = function stringLength(str) {
    var p = 0;
    for (var i = 0; i < str.length; i++) {
        var c = str.charCodeAt(i);
        if (c < 128) {
            p++;
        } else if (c < 2048) {
            p += 2;
        } else if (c >= 0xd800 && c <= 0xdbff) {
            // Lead surrogate of a surrogate pair.  The pair together will take 4 bytes to represent.
            p += 4;
            i++; // skip trail surrogate.
        } else {
            p += 3;
        }
    }
    return p;
};

//# sourceMappingURL=utf8.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/util/dist/esm/index.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
















//# sourceMappingURL=index.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/app/dist/esm/src/firebaseApp.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var firebaseApp_contains = function contains(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
};
var DEFAULT_ENTRY_NAME = '[DEFAULT]';
// An array to capture listeners before the true auth functions
// exist
var tokenListeners = [];
/**
 * Global context object for a collection of services using
 * a shared authentication state.
 */
var firebaseApp_FirebaseAppImpl = /** @class */function () {
    function FirebaseAppImpl(options, name, firebase_) {
        this.firebase_ = firebase_;
        this.isDeleted_ = false;
        this.services_ = {};
        this.name_ = name;
        this.options_ = deepCopy(options);
        this.INTERNAL = {
            getUid: function getUid() {
                return null;
            },
            getToken: function getToken() {
                return Promise.resolve(null);
            },
            addAuthTokenListener: function addAuthTokenListener(callback) {
                tokenListeners.push(callback);
                // Make sure callback is called, asynchronously, in the absence of the auth module
                setTimeout(function () {
                    return callback(null);
                }, 0);
            },
            removeAuthTokenListener: function removeAuthTokenListener(callback) {
                tokenListeners = tokenListeners.filter(function (listener) {
                    return listener !== callback;
                });
            }
        };
    }
    Object.defineProperty(FirebaseAppImpl.prototype, "name", {
        get: function get() {
            this.checkDestroyed_();
            return this.name_;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FirebaseAppImpl.prototype, "options", {
        get: function get() {
            this.checkDestroyed_();
            return this.options_;
        },
        enumerable: true,
        configurable: true
    });
    FirebaseAppImpl.prototype.delete = function () {
        var _this = this;
        return new Promise(function (resolve) {
            _this.checkDestroyed_();
            resolve();
        }).then(function () {
            _this.firebase_.INTERNAL.removeApp(_this.name_);
            var services = [];
            Object.keys(_this.services_).forEach(function (serviceKey) {
                Object.keys(_this.services_[serviceKey]).forEach(function (instanceKey) {
                    services.push(_this.services_[serviceKey][instanceKey]);
                });
            });
            return Promise.all(services.map(function (service) {
                return service.INTERNAL.delete();
            }));
        }).then(function () {
            _this.isDeleted_ = true;
            _this.services_ = {};
        });
    };
    /**
     * Return a service instance associated with this app (creating it
     * on demand), identified by the passed instanceIdentifier.
     *
     * NOTE: Currently storage is the only one that is leveraging this
     * functionality. They invoke it by calling:
     *
     * ```javascript
     * firebase.app().storage('STORAGE BUCKET ID')
     * ```
     *
     * The service name is passed to this already
     * @internal
     */
    FirebaseAppImpl.prototype._getService = function (name, instanceIdentifier) {
        if (instanceIdentifier === void 0) {
            instanceIdentifier = DEFAULT_ENTRY_NAME;
        }
        this.checkDestroyed_();
        if (!this.services_[name]) {
            this.services_[name] = {};
        }
        if (!this.services_[name][instanceIdentifier]) {
            /**
             * If a custom instance has been defined (i.e. not '[DEFAULT]')
             * then we will pass that instance on, otherwise we pass `null`
             */
            var instanceSpecifier = instanceIdentifier !== DEFAULT_ENTRY_NAME ? instanceIdentifier : undefined;
            var service = this.firebase_.INTERNAL.factories[name](this, this.extendApp.bind(this), instanceSpecifier);
            this.services_[name][instanceIdentifier] = service;
        }
        return this.services_[name][instanceIdentifier];
    };
    /**
     * Callback function used to extend an App instance at the time
     * of service instance creation.
     */
    FirebaseAppImpl.prototype.extendApp = function (props) {
        var _this = this;
        // Copy the object onto the FirebaseAppImpl prototype
        deepExtend(this, props);
        /**
         * If the app has overwritten the addAuthTokenListener stub, forward
         * the active token listeners on to the true fxn.
         *
         * TODO: This function is required due to our current module
         * structure. Once we are able to rely strictly upon a single module
         * implementation, this code should be refactored and Auth should
         * provide these stubs and the upgrade logic
         */
        if (props.INTERNAL && props.INTERNAL.addAuthTokenListener) {
            tokenListeners.forEach(function (listener) {
                _this.INTERNAL.addAuthTokenListener(listener);
            });
            tokenListeners = [];
        }
    };
    /**
     * This function will throw an Error if the App has already been deleted -
     * use before performing API actions on the App.
     */
    FirebaseAppImpl.prototype.checkDestroyed_ = function () {
        if (this.isDeleted_) {
            firebaseApp_error('app-deleted', { name: this.name_ });
        }
    };
    return FirebaseAppImpl;
}();
// Prevent dead-code elimination of these methods w/o invalid property
// copying.
firebaseApp_FirebaseAppImpl.prototype.name && firebaseApp_FirebaseAppImpl.prototype.options || firebaseApp_FirebaseAppImpl.prototype.delete || console.log('dc');
/**
 * Return a firebase namespace object.
 *
 * In production, this will be called exactly once and the result
 * assigned to the 'firebase' global.  It may be called multiple times
 * in unit tests.
 */
function createFirebaseNamespace() {
    var apps_ = {};
    var factories = {};
    var appHooks = {};
    // A namespace is a plain JavaScript Object.
    var namespace = {
        // Hack to prevent Babel from modifying the object returned
        // as the firebase namespace.
        __esModule: true,
        initializeApp: initializeApp,
        app: app,
        apps: null,
        Promise: Promise,
        SDK_VERSION: '4.8.0',
        INTERNAL: {
            registerService: registerService,
            createFirebaseNamespace: createFirebaseNamespace,
            extendNamespace: extendNamespace,
            createSubscribe: createSubscribe,
            ErrorFactory: ErrorFactory,
            removeApp: removeApp,
            factories: factories,
            useAsService: useAsService,
            Promise: Promise,
            deepExtend: deepExtend
        }
    };
    // Inject a circular default export to allow Babel users who were previously
    // using:
    //
    //   import firebase from 'firebase';
    //   which becomes: var firebase = require('firebase').default;
    //
    // instead of
    //
    //   import * as firebase from 'firebase';
    //   which becomes: var firebase = require('firebase');
    patchProperty(namespace, 'default', namespace);
    // firebase.apps is a read-only getter.
    Object.defineProperty(namespace, 'apps', {
        get: getApps
    });
    /**
     * Called by App.delete() - but before any services associated with the App
     * are deleted.
     */
    function removeApp(name) {
        var app = apps_[name];
        callAppHooks(app, 'delete');
        delete apps_[name];
    }
    /**
     * Get the App object for a given name (or DEFAULT).
     */
    function app(name) {
        name = name || DEFAULT_ENTRY_NAME;
        if (!firebaseApp_contains(apps_, name)) {
            firebaseApp_error('no-app', { name: name });
        }
        return apps_[name];
    }
    patchProperty(app, 'App', firebaseApp_FirebaseAppImpl);
    /**
     * Create a new App instance (name must be unique).
     */
    function initializeApp(options, name) {
        if (name === undefined) {
            name = DEFAULT_ENTRY_NAME;
        } else {
            if (typeof name !== 'string' || name === '') {
                firebaseApp_error('bad-app-name', { name: name + '' });
            }
        }
        if (firebaseApp_contains(apps_, name)) {
            firebaseApp_error('duplicate-app', { name: name });
        }
        var app = new firebaseApp_FirebaseAppImpl(options, name, namespace);
        apps_[name] = app;
        callAppHooks(app, 'create');
        return app;
    }
    /*
     * Return an array of all the non-deleted FirebaseApps.
     */
    function getApps() {
        // Make a copy so caller cannot mutate the apps list.
        return Object.keys(apps_).map(function (name) {
            return apps_[name];
        });
    }
    /*
     * Register a Firebase Service.
     *
     * firebase.INTERNAL.registerService()
     *
     * TODO: Implement serviceProperties.
     */
    function registerService(name, createService, serviceProperties, appHook, allowMultipleInstances) {
        // Cannot re-register a service that already exists
        if (factories[name]) {
            firebaseApp_error('duplicate-service', { name: name });
        }
        // Capture the service factory for later service instantiation
        factories[name] = createService;
        // Capture the appHook, if passed
        if (appHook) {
            appHooks[name] = appHook;
            // Run the **new** app hook on all existing apps
            getApps().forEach(function (app) {
                appHook('create', app);
            });
        }
        // The Service namespace is an accessor function ...
        var serviceNamespace = function serviceNamespace(appArg) {
            if (appArg === void 0) {
                appArg = app();
            }
            if (typeof appArg[name] !== 'function') {
                // Invalid argument.
                // This happens in the following case: firebase.storage('gs:/')
                firebaseApp_error('invalid-app-argument', { name: name });
            }
            // Forward service instance lookup to the FirebaseApp.
            return appArg[name]();
        };
        // ... and a container for service-level properties.
        if (serviceProperties !== undefined) {
            deepExtend(serviceNamespace, serviceProperties);
        }
        // Monkey-patch the serviceNamespace onto the firebase namespace
        namespace[name] = serviceNamespace;
        // Patch the FirebaseAppImpl prototype
        firebaseApp_FirebaseAppImpl.prototype[name] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var serviceFxn = this._getService.bind(this, name);
            return serviceFxn.apply(this, allowMultipleInstances ? args : []);
        };
        return serviceNamespace;
    }
    /**
     * Patch the top-level firebase namespace with additional properties.
     *
     * firebase.INTERNAL.extendNamespace()
     */
    function extendNamespace(props) {
        deepExtend(namespace, props);
    }
    function callAppHooks(app, eventName) {
        Object.keys(factories).forEach(function (serviceName) {
            // Ignore virtual services
            var factoryName = useAsService(app, serviceName);
            if (factoryName === null) {
                return;
            }
            if (appHooks[factoryName]) {
                appHooks[factoryName](eventName, app);
            }
        });
    }
    // Map the requested service to a registered service name
    // (used to map auth to serverAuth service when needed).
    function useAsService(app, name) {
        if (name === 'serverAuth') {
            return null;
        }
        var useService = name;
        var options = app.options;
        return useService;
    }
    return namespace;
}
function firebaseApp_error(code, args) {
    throw appErrors.create(code, args);
}
// TypeScript does not support non-string indexes!
// let errors: {[code: AppError: string} = {
var errors = {
    'no-app': "No Firebase App '{$name}' has been created - " + 'call Firebase App.initializeApp()',
    'bad-app-name': "Illegal App name: '{$name}",
    'duplicate-app': "Firebase App named '{$name}' already exists",
    'app-deleted': "Firebase App named '{$name}' already deleted",
    'duplicate-service': "Firebase service named '{$name}' already registered",
    'sa-not-supported': 'Initializing the Firebase SDK with a service ' + 'account is only allowed in a Node.js environment. On client ' + 'devices, you should instead initialize the SDK with an api key and ' + 'auth domain',
    'invalid-app-argument': 'firebase.{$name}() takes either no argument or a ' + 'Firebase App instance.'
};
var appErrors = new ErrorFactory('app', 'Firebase', errors);

//# sourceMappingURL=firebaseApp.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/app/dist/esm/index.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var esm_firebase = createFirebaseNamespace();
/* harmony default export */ var esm = (esm_firebase);

//# sourceMappingURL=index.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/core/version.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** The semver (www.semver.org) version of the SDK. */
var SDK_VERSION = esm.SDK_VERSION;

//# sourceMappingURL=version.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/util/log.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:no-console */


var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";
    LogLevel[LogLevel["ERROR"] = 1] = "ERROR";
    LogLevel[LogLevel["SILENT"] = 2] = "SILENT";
})(LogLevel || (LogLevel = {}));
var logLevel = LogLevel.ERROR;
// Helper methods are needed because variables can't be exported as read/write
function getLogLevel() {
    return logLevel;
}
function setLogLevel(newLevel) {
    logLevel = newLevel;
}
function debug(tag, msg) {
    var obj = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        obj[_i - 2] = arguments[_i];
    }
    if (logLevel <= LogLevel.DEBUG) {
        var time = new Date().toISOString();
        var args = obj.map(argToString);
        console.log.apply(console, ["Firestore (" + SDK_VERSION + ") " + time + " [" + tag + "]: " + msg].concat(args));
    }
}
function log_error(msg) {
    var obj = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        obj[_i - 1] = arguments[_i];
    }
    if (logLevel <= LogLevel.ERROR) {
        var time = new Date().toISOString();
        var args = obj.map(argToString);
        console.error.apply(console, ["Firestore (" + SDK_VERSION + ") " + time + ": " + msg].concat(args));
    }
}
/**
 * Converts an additional log parameter to a string representation.
 */
function argToString(obj) {
    if (typeof obj === 'string') {
        return obj;
    } else {
        var platform = platform_PlatformSupport.getPlatform();
        try {
            return platform.formatJSON(obj);
        } catch (e) {
            // Converting to JSON failed, just log the object directly
            return obj;
        }
    }
}

//# sourceMappingURL=log.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/util/assert.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * Unconditionally fails, throwing an Error with the given message.
 *
 * Returns any so it can be used in expressions:
 * @example
 * let futureVar = fail('not implemented yet');
 */
function fail(failure) {
  // Log the failure in addition to throw an exception, just in case the
  // exception is swallowed.
  var message = "FIRESTORE (" + SDK_VERSION + ") INTERNAL ASSERTION FAILED: " + failure;
  log_error(message);
  // NOTE: We don't use FirestoreError here because these are internal failures
  // that cannot be handled by the user. (Also it would create a circular
  // dependency between the error and assert modules which doesn't work.)
  throw new Error(message);
}
/**
 * Fails if the given assertion condition is false, throwing an Error with the
 * given message if it did.
 */
function assert_assert(assertion, message) {
  if (!assertion) {
    fail(message);
  }
}

//# sourceMappingURL=assert.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/platform/platform.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Provides singleton helpers where setup code can inject a platform at runtime.
 * setPlatform needs to be set before Firestore is used and must be set exactly
 * once.
 */
var platform_PlatformSupport = /** @class */function () {
    function PlatformSupport() {}
    PlatformSupport.setPlatform = function (platform) {
        if (PlatformSupport.platform) {
            fail('Platform already defined');
        }
        PlatformSupport.platform = platform;
    };
    PlatformSupport.getPlatform = function () {
        if (!PlatformSupport.platform) {
            fail('Platform not set');
        }
        return PlatformSupport.platform;
    };
    return PlatformSupport;
}();

/**
 * Returns the representation of an empty "proto" byte string for the
 * platform.
 */
function emptyByteString() {
    return platform_PlatformSupport.getPlatform().emptyByteString;
}

//# sourceMappingURL=platform.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/util/error.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var error___extends = this && this.__extends || function () {
  var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) {
      if (b.hasOwnProperty(p)) d[p] = b[p];
    }
  };
  return function (d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
// TODO(mcg): Change to a string enum once we've upgraded to typescript 2.4.
//  tslint:disable-next-line:variable-name Intended to look like a TS 2.4 enum
var Code = {
  // Causes are copied from:
  // https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h
  /** Not an error; returned on success. */
  OK: 'ok',
  /** The operation was cancelled (typically by the caller). */
  CANCELLED: 'cancelled',
  /** Unknown error or an error from a different error domain. */
  UNKNOWN: 'unknown',
  /**
   * Client specified an invalid argument. Note that this differs from
   * FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are
   * problematic regardless of the state of the system (e.g., a malformed file
   * name).
   */
  INVALID_ARGUMENT: 'invalid-argument',
  /**
   * Deadline expired before operation could complete. For operations that
   * change the state of the system, this error may be returned even if the
   * operation has completed successfully. For example, a successful response
   * from a server could have been delayed long enough for the deadline to
   * expire.
   */
  DEADLINE_EXCEEDED: 'deadline-exceeded',
  /** Some requested entity (e.g., file or directory) was not found. */
  NOT_FOUND: 'not-found',
  /**
   * Some entity that we attempted to create (e.g., file or directory) already
   * exists.
   */
  ALREADY_EXISTS: 'already-exists',
  /**
   * The caller does not have permission to execute the specified operation.
   * PERMISSION_DENIED must not be used for rejections caused by exhausting
   * some resource (use RESOURCE_EXHAUSTED instead for those errors).
   * PERMISSION_DENIED must not be used if the caller can not be identified
   * (use UNAUTHENTICATED instead for those errors).
   */
  PERMISSION_DENIED: 'permission-denied',
  /**
   * The request does not have valid authentication credentials for the
   * operation.
   */
  UNAUTHENTICATED: 'unauthenticated',
  /**
   * Some resource has been exhausted, perhaps a per-user quota, or perhaps the
   * entire file system is out of space.
   */
  RESOURCE_EXHAUSTED: 'resource-exhausted',
  /**
   * Operation was rejected because the system is not in a state required for
   * the operation's execution. For example, directory to be deleted may be
   * non-empty, an rmdir operation is applied to a non-directory, etc.
   *
   * A litmus test that may help a service implementor in deciding
   * between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:
   *  (a) Use UNAVAILABLE if the client can retry just the failing call.
   *  (b) Use ABORTED if the client should retry at a higher-level
   *      (e.g., restarting a read-modify-write sequence).
   *  (c) Use FAILED_PRECONDITION if the client should not retry until
   *      the system state has been explicitly fixed. E.g., if an "rmdir"
   *      fails because the directory is non-empty, FAILED_PRECONDITION
   *      should be returned since the client should not retry unless
   *      they have first fixed up the directory by deleting files from it.
   *  (d) Use FAILED_PRECONDITION if the client performs conditional
   *      REST Get/Update/Delete on a resource and the resource on the
   *      server does not match the condition. E.g., conflicting
   *      read-modify-write on the same resource.
   */
  FAILED_PRECONDITION: 'failed-precondition',
  /**
   * The operation was aborted, typically due to a concurrency issue like
   * sequencer check failures, transaction aborts, etc.
   *
   * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,
   * and UNAVAILABLE.
   */
  ABORTED: 'aborted',
  /**
   * Operation was attempted past the valid range. E.g., seeking or reading
   * past end of file.
   *
   * Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed
   * if the system state changes. For example, a 32-bit file system will
   * generate INVALID_ARGUMENT if asked to read at an offset that is not in the
   * range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from
   * an offset past the current file size.
   *
   * There is a fair bit of overlap between FAILED_PRECONDITION and
   * OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)
   * when it applies so that callers who are iterating through a space can
   * easily look for an OUT_OF_RANGE error to detect when they are done.
   */
  OUT_OF_RANGE: 'out-of-range',
  /** Operation is not implemented or not supported/enabled in this service. */
  UNIMPLEMENTED: 'unimplemented',
  /**
   * Internal errors. Means some invariants expected by underlying System has
   * been broken. If you see one of these errors, Something is very broken.
   */
  INTERNAL: 'internal',
  /**
   * The service is currently unavailable. This is a most likely a transient
   * condition and may be corrected by retrying with a backoff.
   *
   * See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,
   * and UNAVAILABLE.
   */
  UNAVAILABLE: 'unavailable',
  /** Unrecoverable data loss or corruption. */
  DATA_LOSS: 'data-loss'
};
/**
 * An error class used for Firestore-generated errors. Ideally we should be
 * using FirebaseError, but integrating with it is overly arduous at the moment,
 * so we define our own compatible error class (with a `name` of 'FirebaseError'
 * and compatible `code` and `message` fields.)
 */
var FirestoreError = /** @class */function (_super) {
  error___extends(FirestoreError, _super);
  function FirestoreError(code, message) {
    var _this = _super.call(this, message) || this;
    _this.code = code;
    _this.message = message;
    _this.name = 'FirebaseError';
    // HACK: We write a toString property directly because Error is not a real
    // class and so inheritance does not work correctly. We could alternatively
    // do the same "back-door inheritance" trick that FirebaseError does.
    _this.toString = function () {
      return _this.name + ": [code=" + _this.code + "]: " + _this.message;
    };
    return _this;
  }
  return FirestoreError;
}(Error);


//# sourceMappingURL=error.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/util/api.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// We are doing some heavy reflective stuff, lots of any casting necessary
/* tslint:disable:no-any */

/**
 * Helper function to prevent instantiation through the constructor.
 *
 * This method creates a new constructor that throws when it's invoked.
 * The prototype of that constructor is then set to the prototype of the hidden
 * "class" to expose all the prototype methods and allow for instanceof
 * checks.
 *
 * To also make all the static methods available, all properties of the
 * original constructor are copied to the new constructor.
 */
function makeConstructorPrivate(cls, optionalMessage) {
    function PublicConstructor() {
        var error = 'This constructor is private.';
        if (optionalMessage) {
            error += ' ';
            error += optionalMessage;
        }
        throw new FirestoreError(Code.INVALID_ARGUMENT, error);
    }
    // Make sure instanceof checks work and all methods are exposed on the public
    // constructor
    PublicConstructor.prototype = cls.prototype;
    // Copy any static methods/members
    for (var staticProperty in cls) {
        if (cls.hasOwnProperty(staticProperty)) {
            PublicConstructor[staticProperty] = cls[staticProperty];
        }
    }
    return PublicConstructor;
}

//# sourceMappingURL=api.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/util/obj.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function obj_contains(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}
function obj_get(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key) ? obj[key] : null;
}
function obj_size(obj) {
    var count = 0;
    for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            count++;
        }
    }
    return count;
}
/** Returns the given value if it's defined or the defaultValue otherwise. */
function defaulted(value, defaultValue) {
    return value !== undefined ? value : defaultValue;
}
function forEachNumber(obj, fn) {
    for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            var num = parseInt(key, 10);
            if (!isNaN(num)) {
                fn(num, obj[key]);
            }
        }
    }
}
function obj_forEach(obj, fn) {
    for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn(key, obj[key]);
        }
    }
}
function lookupOrInsert(obj, key, valFn) {
    if (!obj_contains(obj, key)) {
        obj[key] = valFn();
    }
    return obj[key];
}
function obj_isEmpty(obj) {
    assert_assert(obj != null && typeof obj === 'object', 'isEmpty() expects object parameter.');
    for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            return false;
        }
    }
    return true;
}
function shallowCopy(obj) {
    assert_assert(obj && typeof obj === 'object', 'shallowCopy() expects object parameter.');
    var result = {};
    for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            result[key] = obj[key];
        }
    }
    return result;
}

//# sourceMappingURL=obj.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/util/input_validation.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Validates the invocation of functionName has the exact number of arguments.
 *
 * Forward the magic "arguments" variable as second parameter on which the
 * parameter validation is performed:
 * validateExactNumberOfArgs('myFunction', arguments, 2);
 */
function validateExactNumberOfArgs(functionName, args, numberOfArgs) {
    if (args.length !== numberOfArgs) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() requires " + formatPlural(numberOfArgs, 'argument') + ', but was called with ' + formatPlural(args.length, 'argument') + '.');
    }
}
/**
 * Validates the invocation of functionName has at least the provided number of
 * arguments (but can have many more).
 *
 * Forward the magic "arguments" variable as second parameter on which the
 * parameter validation is performed:
 * validateAtLeastNumberOfArgs('myFunction', arguments, 2);
 */
function validateAtLeastNumberOfArgs(functionName, args, minNumberOfArgs) {
    if (args.length < minNumberOfArgs) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() requires at least " + formatPlural(minNumberOfArgs, 'argument') + ', but was called with ' + formatPlural(args.length, 'argument') + '.');
    }
}
/**
 * Validates the invocation of functionName has number of arguments between
 * the values provided.
 *
 * Forward the magic "arguments" variable as second parameter on which the
 * parameter validation is performed:
 * validateBetweenNumberOfArgs('myFunction', arguments, 2, 3);
 */
function validateBetweenNumberOfArgs(functionName, args, minNumberOfArgs, maxNumberOfArgs) {
    if (args.length < minNumberOfArgs || args.length > maxNumberOfArgs) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() requires between " + minNumberOfArgs + " and " + (maxNumberOfArgs + " arguments, but was called with ") + formatPlural(args.length, 'argument') + '.');
    }
}
/**
 * Validates the provided argument is an array and has as least the expected
 * number of elements.
 */
function validateNamedArrayAtLeastNumberOfElements(functionName, value, name, minNumberOfElements) {
    if (!(value instanceof Array) || value.length < minNumberOfElements) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() requires its " + name + " argument to be an " + 'array with at least ' + (formatPlural(minNumberOfElements, 'element') + "."));
    }
}
/**
 * Validates the provided positional argument has the native JavaScript type
 * using typeof checks.
 */
function validateArgType(functionName, type, position, argument) {
    validateType(functionName, type, ordinal(position) + " argument", argument);
}
/**
 * Validates the provided argument has the native JavaScript type using
 * typeof checks or is undefined.
 */
function validateOptionalArgType(functionName, type, position, argument) {
    if (argument !== undefined) {
        validateArgType(functionName, type, position, argument);
    }
}
/**
 * Validates the provided named option has the native JavaScript type using
 * typeof checks.
 */
function validateNamedType(functionName, type, optionName, argument) {
    validateType(functionName, type, optionName + " option", argument);
}
/**
 * Validates the provided named option has the native JavaScript type using
 * typeof checks or is undefined.
 */
function validateNamedOptionalType(functionName, type, optionName, argument) {
    if (argument !== undefined) {
        validateNamedType(functionName, type, optionName, argument);
    }
}
/** Helper to validate the type of a provided input. */
function validateType(functionName, type, inputName, input) {
    if (typeof input !== type || type === 'object' && !isPlainObject(input)) {
        var description = valueDescription(input);
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() requires its " + inputName + " " + ("to be of type " + type + ", but it was: " + description));
    }
}
/**
 * Returns true iff it's a non-null object without a custom prototype
 * (i.e. excludes Array, Date, etc.).
 */
function isPlainObject(input) {
    return typeof input === 'object' && input !== null && Object.getPrototypeOf(input) === Object.prototype;
}
/** Returns a string describing the type / value of the provided input. */
function valueDescription(input) {
    if (input === undefined) {
        return 'undefined';
    } else if (input === null) {
        return 'null';
    } else if (typeof input === 'string') {
        if (input.length > 20) {
            input = input.substring(0, 20) + "...";
        }
        return JSON.stringify(input);
    } else if (typeof input === 'number' || typeof input === 'boolean') {
        return '' + input;
    } else if (typeof input === 'object') {
        if (input instanceof Array) {
            return 'an array';
        } else {
            var customObjectName = tryGetCustomObjectType(input);
            if (customObjectName) {
                return "a custom " + customObjectName + " object";
            } else {
                return 'an object';
            }
        }
    } else if (typeof input === 'function') {
        return 'a function';
    } else {
        return fail('Unknown wrong type: ' + typeof input);
    }
}
/** Hacky method to try to get the constructor name for an object. */
function tryGetCustomObjectType(input) {
    if (input.constructor) {
        var funcNameRegex = /function\s+([^\s(]+)\s*\(/;
        var results = funcNameRegex.exec(input.constructor.toString());
        if (results && results.length > 1) {
            return results[1];
        }
    }
    return null;
}
/** Validates the provided argument is defined. */
function validateDefined(functionName, position, argument) {
    if (argument === undefined) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() requires a valid " + ordinal(position) + " " + "argument, but it was undefined.");
    }
}
/**
 * Validates the provided positional argument is an object, and its keys and
 * values match the expected keys and types provided in optionTypes.
 */
function validateOptionNames(functionName, options, optionNames) {
    obj_forEach(options, function (key, _) {
        if (optionNames.indexOf(key) < 0) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Unknown option '" + key + "' passed to function " + functionName + "(). " + 'Available options: ' + optionNames.join(', '));
        }
    });
}
/**
 * Helper method to throw an error that the provided argument did not pass
 * an instanceof check.
 */
function invalidClassError(functionName, type, position, argument) {
    var description = valueDescription(argument);
    return new FirestoreError(Code.INVALID_ARGUMENT, "Function " + functionName + "() requires its " + ordinal(position) + " " + ("argument to be a " + type + ", but it was: " + description));
}
/** Converts a number to its english word representation */
function ordinal(num) {
    switch (num) {
        case 1:
            return 'first';
        case 2:
            return 'second';
        case 3:
            return 'third';
        default:
            return num + 'th';
    }
}
/**
 * Formats the given word as plural conditionally given the preceding number.
 */
function formatPlural(num, str) {
    return num + " " + str + (num === 1 ? '' : 's');
}

//# sourceMappingURL=input_validation.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/util/misc.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// tslint:disable-next-line:class-as-namespace
var misc_AutoId = /** @class */function () {
    function AutoId() {}
    AutoId.newId = function () {
        // Alphanumeric characters
        var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        var autoId = '';
        for (var i = 0; i < 20; i++) {
            autoId += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        assert_assert(autoId.length === 20, 'Invalid auto ID: ' + autoId);
        return autoId;
    };
    return AutoId;
}();

function primitiveComparator(left, right) {
    if (left < right) return -1;
    if (left > right) return 1;
    return 0;
}
/** Helper to compare nullable (or undefined-able) objects using equals(). */
function equals(left, right) {
    if (left !== null && left !== undefined) {
        return !!(right && left.equals(right));
    } else {
        // HACK: Explicitly cast since TypeScript's type narrowing apparently isn't
        // smart enough.
        return left === right;
    }
}
/** Helper to compare arrays using equals(). */
function arrayEquals(left, right) {
    if (left.length !== right.length) {
        return false;
    }
    for (var i = 0; i < left.length; i++) {
        if (!left[i].equals(right[i])) {
            return false;
        }
    }
    return true;
}
/**
 * Returns the largest lexicographically smaller string of equal or smaller
 * length. Returns an empty string if there is no such predecessor (if the input
 * is empty).
 *
 * Strings returned from this method can be invalid UTF-16 but this is sufficent
 * in use for indexeddb because that depends on lexicographical ordering but
 * shouldn't be used elsewhere.
 */
function immediatePredecessor(s) {
    // We can decrement the last character in the string and be done
    // unless that character is 0 (0x0000), in which case we have to erase the
    // last character.
    var lastIndex = s.length - 1;
    if (s.length === 0) {
        // Special case the empty string.
        return '';
    } else if (s.charAt(lastIndex) === '\0') {
        return s.substring(0, lastIndex);
    } else {
        return s.substring(0, lastIndex) + String.fromCharCode(s.charCodeAt(lastIndex) - 1);
    }
}
/**
 * Returns the immediate lexicographically-following string. This is useful to
 * construct an inclusive range for indexeddb iterators.
 */
function immediateSuccessor(s) {
    // Return the input string, with an additional NUL byte appended.
    return s + '\0';
}

//# sourceMappingURL=misc.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/api/blob.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/** Helper function to assert Uint8Array is available at runtime. */
function assertUint8ArrayAvailable() {
    if (typeof Uint8Array === 'undefined') {
        throw new FirestoreError(Code.UNIMPLEMENTED, 'Uint8Arrays are not available in this environment.');
    }
}
/** Helper function to assert Base64 functions are available at runtime. */
function assertBase64Available() {
    if (!platform_PlatformSupport.getPlatform().base64Available) {
        throw new FirestoreError(Code.UNIMPLEMENTED, 'Blobs are unavailable in Firestore in this environment.');
    }
}
/**
 * Immutable class holding a blob (binary data).
 * This class is directly exposed in the public API.
 *
 * Note that while you can't hide the constructor in JavaScript code, we are
 * using the hack above to make sure no-one outside this module can call it.
 */
var blob_Blob = /** @class */function () {
    function Blob(binaryString) {
        assertBase64Available();
        this._binaryString = binaryString;
    }
    Blob.fromBase64String = function (base64) {
        validateExactNumberOfArgs('Blob.fromBase64String', arguments, 1);
        validateArgType('Blob.fromBase64String', 'string', 1, base64);
        assertBase64Available();
        try {
            var binaryString = platform_PlatformSupport.getPlatform().atob(base64);
            return new Blob(binaryString);
        } catch (e) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Failed to construct Blob from Base64 string: ' + e);
        }
    };
    Blob.fromUint8Array = function (array) {
        validateExactNumberOfArgs('Blob.fromUint8Array', arguments, 1);
        assertUint8ArrayAvailable();
        if (!(array instanceof Uint8Array)) {
            throw invalidClassError('Blob.fromUint8Array', 'Uint8Array', 1, array);
        }
        // We can't call array.map directly because it expects the return type to
        // be a Uint8Array, whereas we can convert it to a regular array by invoking
        // map on the Array prototype.
        var binaryString = Array.prototype.map.call(array, function (char) {
            return String.fromCharCode(char);
        }).join('');
        return new Blob(binaryString);
    };
    Blob.prototype.toBase64 = function () {
        validateExactNumberOfArgs('Blob.toBase64', arguments, 0);
        assertBase64Available();
        return platform_PlatformSupport.getPlatform().btoa(this._binaryString);
    };
    Blob.prototype.toUint8Array = function () {
        validateExactNumberOfArgs('Blob.toUint8Array', arguments, 0);
        assertUint8ArrayAvailable();
        var buffer = new Uint8Array(this._binaryString.length);
        for (var i = 0; i < this._binaryString.length; i++) {
            buffer[i] = this._binaryString.charCodeAt(i);
        }
        return buffer;
    };
    Blob.prototype.toString = function () {
        return 'Blob(base64: ' + this.toBase64() + ')';
    };
    /**
     * Actually private to JS consumers of our API, so this function is prefixed
     * with an underscore.
     */
    Blob.prototype._equals = function (other) {
        return this._binaryString === other._binaryString;
    };
    /**
     * Actually private to JS consumers of our API, so this function is prefixed
     * with an underscore.
     */
    Blob.prototype._compareTo = function (other) {
        return primitiveComparator(this._binaryString, other._binaryString);
    };
    return Blob;
}();

// Public instance that disallows construction at runtime. This constructor is
// used when exporting Blob on firebase.firestore.Blob and will be called Blob
// publicly. Internally we still use Blob which has a type checked private
// constructor. Note that Blob and PublicBlob can be used interchangeably in
// instanceof checks.
// For our internal TypeScript code PublicBlob doesn't exist as a type, and so
// we need to use Blob as type and export it too.
// tslint:disable-next-line:variable-name We're treating this as a class name.
var PublicBlob = makeConstructorPrivate(blob_Blob, 'Use Blob.fromUint8Array() or Blob.fromBase64String() instead.');

//# sourceMappingURL=blob.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/api/geo_point.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Immutable class representing a geo point as latitude-longitude pair.
 * This class is directly exposed in the public API, including its constructor.
 */
var geo_point_GeoPoint = /** @class */function () {
    function GeoPoint(latitude, longitude) {
        validateExactNumberOfArgs('GeoPoint', arguments, 2);
        validateArgType('GeoPoint', 'number', 1, latitude);
        validateArgType('GeoPoint', 'number', 2, longitude);
        if (!isFinite(latitude) || latitude < -90 || latitude > 90) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Latitude must be a number between -90 and 90, but was: ' + latitude);
        }
        if (!isFinite(longitude) || longitude < -180 || longitude > 180) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Longitude must be a number between -180 and 180, but was: ' + longitude);
        }
        this._lat = latitude;
        this._long = longitude;
    }
    Object.defineProperty(GeoPoint.prototype, "latitude", {
        /**
         * Returns the latitude of this geo point, a number between -90 and 90.
         */
        get: function get() {
            return this._lat;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GeoPoint.prototype, "longitude", {
        /**
         * Returns the longitude of this geo point, a number between -180 and 180.
         */
        get: function get() {
            return this._long;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Actually private to JS consumers of our API, so this function is prefixed
     * with an underscore.
     */
    GeoPoint.prototype._equals = function (other) {
        return this._lat === other._lat && this._long === other._long;
    };
    /**
     * Actually private to JS consumers of our API, so this function is prefixed
     * with an underscore.
     */
    GeoPoint.prototype._compareTo = function (other) {
        return primitiveComparator(this._lat, other._lat) || primitiveComparator(this._long, other._long);
    };
    return GeoPoint;
}();


//# sourceMappingURL=geo_point.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/core/database_info.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var DatabaseInfo = /** @class */function () {
    /**
     * Constructs a DatabaseInfo using the provided host, databaseId and
     * persistenceKey.
     *
     * @param databaseId The database to use.
     * @param persistenceKey A unique identifier for this Firestore's local
     * storage (used in conjunction with the databaseId).
     * @param host The Firestore backend host to connect to.
     * @param ssl Whether to use SSL when connecting.
     */
    function DatabaseInfo(databaseId, persistenceKey, host, ssl) {
        this.databaseId = databaseId;
        this.persistenceKey = persistenceKey;
        this.host = host;
        this.ssl = ssl;
    }
    return DatabaseInfo;
}();

/** The default database name for a project. */
var DEFAULT_DATABASE_NAME = '(default)';
/** Represents the database ID a Firestore client is associated with. */
var database_info_DatabaseId = /** @class */function () {
    function DatabaseId(projectId, database) {
        this.projectId = projectId;
        this.database = database ? database : DEFAULT_DATABASE_NAME;
    }
    Object.defineProperty(DatabaseId.prototype, "isDefaultDatabase", {
        get: function get() {
            return this.database === DEFAULT_DATABASE_NAME;
        },
        enumerable: true,
        configurable: true
    });
    DatabaseId.prototype.equals = function (other) {
        return other instanceof DatabaseId && other.projectId === this.projectId && other.database === this.database;
    };
    DatabaseId.prototype.compareTo = function (other) {
        return primitiveComparator(this.projectId, other.projectId) || primitiveComparator(this.database, other.database);
    };
    return DatabaseId;
}();


//# sourceMappingURL=database_info.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/model/path.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var path___extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();


var DOCUMENT_KEY_NAME = '__name__';
/**
 * Path represents an ordered sequence of string segments.
 */
var path_Path = /** @class */function () {
    function Path(segments, offset, length) {
        this.init(segments, offset, length);
    }
    /**
     * An initialization method that can be called from outside the constructor.
     * We need this so that we can have a non-static construct method that returns
     * the polymorphic `this` type.
     */
    Path.prototype.init = function (segments, offset, length) {
        if (offset === undefined) {
            offset = 0;
        } else if (offset > segments.length) {
            fail('offset ' + offset + ' out of range ' + segments.length);
        }
        if (length === undefined) {
            length = segments.length - offset;
        } else if (length > segments.length - offset) {
            fail('length ' + length + ' out of range ' + (segments.length - offset));
        }
        this.segments = segments;
        this.offset = offset;
        this.len = length;
    };
    /**
     * Constructs a new instance of Path using the same concrete type as `this`.
     * We need this instead of using the normal constructor, because polymorphic
     * `this` doesn't work on static methods.
     */
    Path.prototype.construct = function (segments, offset, length) {
        var path = Object.create(Object.getPrototypeOf(this));
        path.init(segments, offset, length);
        return path;
    };
    Object.defineProperty(Path.prototype, "length", {
        get: function get() {
            return this.len;
        },
        enumerable: true,
        configurable: true
    });
    Path.prototype.equals = function (other) {
        return Path.comparator(this, other) === 0;
    };
    Path.prototype.child = function (nameOrPath) {
        var segments = this.segments.slice(this.offset, this.limit());
        if (nameOrPath instanceof Path) {
            nameOrPath.forEach(function (segment) {
                segments.push(segment);
            });
        } else if (typeof nameOrPath === 'string') {
            segments.push(nameOrPath);
        } else {
            fail('Unknown parameter type for Path.child(): ' + nameOrPath);
        }
        return this.construct(segments);
    };
    /** The index of one past the last segment of the path. */
    Path.prototype.limit = function () {
        return this.offset + this.length;
    };
    Path.prototype.popFirst = function (size) {
        size = size === undefined ? 1 : size;
        assert_assert(this.length >= size, "Can't call popFirst() with less segments");
        return this.construct(this.segments, this.offset + size, this.length - size);
    };
    Path.prototype.popLast = function () {
        assert_assert(!this.isEmpty(), "Can't call popLast() on empty path");
        return this.construct(this.segments, this.offset, this.length - 1);
    };
    Path.prototype.firstSegment = function () {
        assert_assert(!this.isEmpty(), "Can't call firstSegment() on empty path");
        return this.segments[this.offset];
    };
    Path.prototype.lastSegment = function () {
        assert_assert(!this.isEmpty(), "Can't call lastSegment() on empty path");
        return this.segments[this.limit() - 1];
    };
    Path.prototype.get = function (index) {
        assert_assert(index < this.length, 'Index out of range');
        return this.segments[this.offset + index];
    };
    Path.prototype.isEmpty = function () {
        return this.length === 0;
    };
    Path.prototype.isPrefixOf = function (other) {
        if (other.length < this.length) {
            return false;
        }
        for (var i = 0; i < this.length; i++) {
            if (this.get(i) !== other.get(i)) {
                return false;
            }
        }
        return true;
    };
    Path.prototype.forEach = function (fn) {
        for (var i = this.offset, end = this.limit(); i < end; i++) {
            fn(this.segments[i]);
        }
    };
    Path.prototype.toArray = function () {
        return this.segments.slice(this.offset, this.limit());
    };
    Path.comparator = function (p1, p2) {
        var len = Math.min(p1.length, p2.length);
        for (var i = 0; i < len; i++) {
            var left = p1.get(i);
            var right = p2.get(i);
            if (left < right) return -1;
            if (left > right) return 1;
        }
        if (p1.length < p2.length) return -1;
        if (p1.length > p2.length) return 1;
        return 0;
    };
    return Path;
}();

/**
 * A slash-separated path for navigating resources (documents and collections)
 * within Firestore.
 */
var path_ResourcePath = /** @class */function (_super) {
    path___extends(ResourcePath, _super);
    function ResourcePath() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ResourcePath.prototype.canonicalString = function () {
        // NOTE: The client is ignorant of any path segments containing escape
        // sequences (e.g. __id123__) and just passes them through raw (they exist
        // for legacy reasons and should not be used frequently).
        return this.toArray().join('/');
    };
    ResourcePath.prototype.toString = function () {
        return this.canonicalString();
    };
    /**
     * Creates a resource path from the given slash-delimited string.
     */
    ResourcePath.fromString = function (path) {
        // NOTE: The client is ignorant of any path segments containing escape
        // sequences (e.g. __id123__) and just passes them through raw (they exist
        // for legacy reasons and should not be used frequently).
        if (path.indexOf('//') >= 0) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid path (" + path + "). Paths must not contain // in them.");
        }
        // We may still have an empty segment at the beginning or end if they had a
        // leading or trailing slash (which we allow).
        var segments = path.split('/').filter(function (segment) {
            return segment.length > 0;
        });
        return new ResourcePath(segments);
    };
    ResourcePath.EMPTY_PATH = new ResourcePath([]);
    return ResourcePath;
}(path_Path);

var identifierRegExp = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
/** A dot-separated path for navigating sub-objects within a document. */
var path_FieldPath = /** @class */function (_super) {
    path___extends(FieldPath, _super);
    function FieldPath() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns true if the string could be used as a segment in a field path
     * without escaping.
     */
    FieldPath.isValidIdentifier = function (segment) {
        return identifierRegExp.test(segment);
    };
    FieldPath.prototype.canonicalString = function () {
        return this.toArray().map(function (str) {
            str = str.replace('\\', '\\\\').replace('`', '\\`');
            if (!FieldPath.isValidIdentifier(str)) {
                str = '`' + str + '`';
            }
            return str;
        }).join('.');
    };
    FieldPath.prototype.toString = function () {
        return this.canonicalString();
    };
    /**
     * Returns true if this field references the key of a document.
     */
    FieldPath.prototype.isKeyField = function () {
        return this.length === 1 && this.get(0) === DOCUMENT_KEY_NAME;
    };
    /**
     * The field designating the key of a document.
     */
    FieldPath.keyField = function () {
        return new FieldPath([DOCUMENT_KEY_NAME]);
    };
    /**
     * Parses a field string from the given server-formatted string.
     *
     * - Splitting the empty string is not allowed (for now at least).
     * - Empty segments within the string (e.g. if there are two consecutive
     *   separators) are not allowed.
     *
     * TODO(b/37244157): we should make this more strict. Right now, it allows
     * non-identifier path components, even if they aren't escaped.
     */
    FieldPath.fromServerFormat = function (path) {
        var segments = [];
        var current = '';
        var i = 0;
        var addCurrentSegment = function addCurrentSegment() {
            if (current.length === 0) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid field path (" + path + "). Paths must not be empty, begin " + "with '.', end with '.', or contain '..'");
            }
            segments.push(current);
            current = '';
        };
        var inBackticks = false;
        while (i < path.length) {
            var c = path[i];
            if (c === '\\') {
                if (i + 1 === path.length) {
                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has trailing escape character: ' + path);
                }
                var next = path[i + 1];
                if (!(next === '\\' || next === '.' || next === '`')) {
                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Path has invalid escape sequence: ' + path);
                }
                current += next;
                i += 2;
            } else if (c === '`') {
                inBackticks = !inBackticks;
                i++;
            } else if (c === '.' && !inBackticks) {
                addCurrentSegment();
                i++;
            } else {
                current += c;
                i++;
            }
        }
        addCurrentSegment();
        if (inBackticks) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Unterminated ` in path: ' + path);
        }
        return new FieldPath(segments);
    };
    FieldPath.EMPTY_PATH = new FieldPath([]);
    return FieldPath;
}(path_Path);


//# sourceMappingURL=path.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/model/document_key.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var document_key_DocumentKey = /** @class */function () {
    function DocumentKey(path) {
        this.path = path;
        assert_assert(DocumentKey.isDocumentKey(path), 'Invalid DocumentKey with an odd number of segments: ' + path.toArray().join('/'));
    }
    DocumentKey.prototype.equals = function (other) {
        return other !== null && path_ResourcePath.comparator(this.path, other.path) === 0;
    };
    DocumentKey.prototype.toString = function () {
        return this.path.toString();
    };
    DocumentKey.comparator = function (k1, k2) {
        return path_ResourcePath.comparator(k1.path, k2.path);
    };
    DocumentKey.isDocumentKey = function (path) {
        return path.length % 2 === 0;
    };
    /**
     * Creates and returns a new document key with the given segments.
     *
     * @param path The segments of the path to the document
     * @return A new instance of DocumentKey
     */
    DocumentKey.fromSegments = function (segments) {
        return new DocumentKey(new path_ResourcePath(segments.slice()));
    };
    /**
     * Creates and returns a new document key using '/' to split the string into
     * segments.
     *
     * @param path The slash-separated path string to the document
     * @return A new instance of DocumentKey
     */
    DocumentKey.fromPathString = function (path) {
        return new DocumentKey(path_ResourcePath.fromString(path));
    };
    DocumentKey.EMPTY = new DocumentKey(new path_ResourcePath([]));
    return DocumentKey;
}();


//# sourceMappingURL=document_key.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/model/document.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var document_Document = /** @class */function () {
    function Document(key, version, data, options) {
        this.key = key;
        this.version = version;
        this.data = data;
        this.hasLocalMutations = options.hasLocalMutations;
    }
    Document.prototype.field = function (path) {
        return this.data.field(path);
    };
    Document.prototype.fieldValue = function (path) {
        var field = this.field(path);
        return field ? field.value() : undefined;
    };
    Document.prototype.value = function () {
        return this.data.value();
    };
    Document.prototype.equals = function (other) {
        return other instanceof Document && this.key.equals(other.key) && this.version.equals(other.version) && this.data.equals(other.data) && this.hasLocalMutations === other.hasLocalMutations;
    };
    Document.prototype.toString = function () {
        return "Document(" + this.key + ", " + this.version + ", " + this.data.toString() + ", " + ("{hasLocalMutations: " + this.hasLocalMutations + "})");
    };
    Document.compareByKey = function (d1, d2) {
        return document_key_DocumentKey.comparator(d1.key, d2.key);
    };
    Document.compareByField = function (field, d1, d2) {
        var v1 = d1.field(field);
        var v2 = d2.field(field);
        if (v1 !== undefined && v2 !== undefined) {
            return v1.compareTo(v2);
        } else {
            return fail("Trying to compare documents on fields that don't exist");
        }
    };
    return Document;
}();

/**
 * A class representing a deleted document.
 * Version is set to 0 if we don't point to any specific time, otherwise it
 * denotes time we know it didn't exist at.
 */
var document_NoDocument = /** @class */function () {
    function NoDocument(key, version) {
        this.key = key;
        this.version = version;
    }
    NoDocument.prototype.toString = function () {
        return "NoDocument(" + this.key + ", " + this.version + ")";
    };
    NoDocument.prototype.equals = function (other) {
        return other && other.version.equals(this.version) && other.key.equals(this.key);
    };
    NoDocument.compareByKey = function (d1, d2) {
        return document_key_DocumentKey.comparator(d1.key, d2.key);
    };
    return NoDocument;
}();


//# sourceMappingURL=document.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/util/sorted_map.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// An immutable sorted map implementation, based on a Left-leaning Red-Black
// tree.
var sorted_map_SortedMap = /** @class */function () {
    function SortedMap(comparator, root) {
        this.comparator = comparator;
        this.root = root ? root : sorted_map_LLRBNode.EMPTY;
    }
    // Returns a copy of the map, with the specified key/value added or replaced.
    SortedMap.prototype.insert = function (key, value) {
        return new SortedMap(this.comparator, this.root.insert(key, value, this.comparator).copy(null, null, sorted_map_LLRBNode.BLACK, null, null));
    };
    // Returns a copy of the map, with the specified key removed.
    SortedMap.prototype.remove = function (key) {
        return new SortedMap(this.comparator, this.root.remove(key, this.comparator).copy(null, null, sorted_map_LLRBNode.BLACK, null, null));
    };
    // Returns the value of the node with the given key, or null.
    SortedMap.prototype.get = function (key) {
        var node = this.root;
        while (!node.isEmpty()) {
            var cmp = this.comparator(key, node.key);
            if (cmp === 0) {
                return node.value;
            } else if (cmp < 0) {
                node = node.left;
            } else if (cmp > 0) {
                node = node.right;
            }
        }
        return null;
    };
    // Returns the key of the item *before* the specified key, or null if key is
    // the first item.
    SortedMap.prototype.getPredecessorKey = function (key) {
        var node = this.root;
        var rightParent = null;
        while (!node.isEmpty()) {
            var cmp = this.comparator(key, node.key);
            if (cmp === 0) {
                if (!node.left.isEmpty()) {
                    node = node.left;
                    while (!node.right.isEmpty()) {
                        node = node.right;
                    }return node.key;
                } else if (rightParent) {
                    return rightParent.key;
                } else {
                    return null; // first item.
                }
            } else if (cmp < 0) {
                node = node.left;
            } else if (cmp > 0) {
                rightParent = node;
                node = node.right;
            }
        }
        throw fail('Attempted to find predecessor key for a nonexistent key.' + '  What gives?');
    };
    // Returns the index of the element in this sorted map, or -1 if it doesn't
    // exist.
    SortedMap.prototype.indexOf = function (key) {
        // Number of nodes that were pruned when descending right
        var prunedNodes = 0;
        var node = this.root;
        while (!node.isEmpty()) {
            var cmp = this.comparator(key, node.key);
            if (cmp === 0) {
                return prunedNodes + node.left.size;
            } else if (cmp < 0) {
                node = node.left;
            } else {
                // Count all nodes left of the node plus the node itself
                prunedNodes += node.left.size + 1;
                node = node.right;
            }
        }
        // Node not found
        return -1;
    };
    SortedMap.prototype.isEmpty = function () {
        return this.root.isEmpty();
    };
    Object.defineProperty(SortedMap.prototype, "size", {
        // Returns the total number of nodes in the map.
        get: function get() {
            return this.root.size;
        },
        enumerable: true,
        configurable: true
    });
    // Returns the minimum key in the map.
    SortedMap.prototype.minKey = function () {
        return this.root.minKey();
    };
    // Returns the maximum key in the map.
    SortedMap.prototype.maxKey = function () {
        return this.root.maxKey();
    };
    // Traverses the map in key order and calls the specified action function
    // for each key/value pair. If action returns true, traversal is aborted.
    // Returns the first truthy value returned by action, or the last falsey
    // value returned by action.
    SortedMap.prototype.inorderTraversal = function (action) {
        return this.root.inorderTraversal(action);
    };
    SortedMap.prototype.forEach = function (fn) {
        this.inorderTraversal(function (k, v) {
            fn(k, v);
            return false;
        });
    };
    // Traverses the map in reverse key order and calls the specified action
    // function for each key/value pair. If action returns true, traversal is
    // aborted.
    // Returns the first truthy value returned by action, or the last falsey
    // value returned by action.
    SortedMap.prototype.reverseTraversal = function (action) {
        return this.root.reverseTraversal(action);
    };
    SortedMap.prototype.getIterator = function (resultGenerator) {
        return new sorted_map_SortedMapIterator(this.root, null, this.comparator, false, resultGenerator);
    };
    SortedMap.prototype.getIteratorFrom = function (key, resultGenerator) {
        return new sorted_map_SortedMapIterator(this.root, key, this.comparator, false, resultGenerator);
    };
    SortedMap.prototype.getReverseIterator = function (resultGenerator) {
        return new sorted_map_SortedMapIterator(this.root, null, this.comparator, true, resultGenerator);
    };
    SortedMap.prototype.getReverseIteratorFrom = function (key, resultGenerator) {
        return new sorted_map_SortedMapIterator(this.root, key, this.comparator, true, resultGenerator);
    };
    return SortedMap;
}(); // end SortedMap

// An iterator over an LLRBNode.
var sorted_map_SortedMapIterator = /** @class */function () {
    function SortedMapIterator(node, startKey, comparator, isReverse, resultGenerator) {
        this.resultGenerator = resultGenerator || null;
        this.isReverse = isReverse;
        this.nodeStack = [];
        var cmp = 1;
        while (!node.isEmpty()) {
            cmp = startKey ? comparator(node.key, startKey) : 1;
            // flip the comparison if we're going in reverse
            if (isReverse) cmp *= -1;
            if (cmp < 0) {
                // This node is less than our start key. ignore it
                if (this.isReverse) {
                    node = node.left;
                } else {
                    node = node.right;
                }
            } else if (cmp === 0) {
                // This node is exactly equal to our start key. Push it on the stack,
                // but stop iterating;
                this.nodeStack.push(node);
                break;
            } else {
                // This node is greater than our start key, add it to the stack and move
                // to the next one
                this.nodeStack.push(node);
                if (this.isReverse) {
                    node = node.right;
                } else {
                    node = node.left;
                }
            }
        }
    }
    SortedMapIterator.prototype.getNext = function () {
        assert_assert(this.nodeStack.length > 0, 'getNext() called on iterator when hasNext() is false.');
        var node = this.nodeStack.pop();
        var result;
        if (this.resultGenerator) result = this.resultGenerator(node.key, node.value);else result = { key: node.key, value: node.value };
        if (this.isReverse) {
            node = node.left;
            while (!node.isEmpty()) {
                this.nodeStack.push(node);
                node = node.right;
            }
        } else {
            node = node.right;
            while (!node.isEmpty()) {
                this.nodeStack.push(node);
                node = node.left;
            }
        }
        return result;
    };
    SortedMapIterator.prototype.hasNext = function () {
        return this.nodeStack.length > 0;
    };
    SortedMapIterator.prototype.peek = function () {
        if (this.nodeStack.length === 0) return null;
        var node = this.nodeStack[this.nodeStack.length - 1];
        if (this.resultGenerator) {
            return this.resultGenerator(node.key, node.value);
        } else {
            return { key: node.key, value: node.value };
        }
    };
    return SortedMapIterator;
}(); // end SortedMapIterator

// Represents a node in a Left-leaning Red-Black tree.
var sorted_map_LLRBNode = /** @class */function () {
    function LLRBNode(key, value, color, left, right) {
        this.key = key;
        this.value = value;
        this.color = color != null ? color : LLRBNode.RED;
        this.left = left != null ? left : LLRBNode.EMPTY;
        this.right = right != null ? right : LLRBNode.EMPTY;
        this.size = this.left.size + 1 + this.right.size;
    }
    // Returns a copy of the current node, optionally replacing pieces of it.
    LLRBNode.prototype.copy = function (key, value, color, left, right) {
        return new LLRBNode(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);
    };
    LLRBNode.prototype.isEmpty = function () {
        return false;
    };
    // Traverses the tree in key order and calls the specified action function
    // for each node. If action returns true, traversal is aborted.
    // Returns the first truthy value returned by action, or the last falsey
    // value returned by action.
    LLRBNode.prototype.inorderTraversal = function (action) {
        return this.left.inorderTraversal(action) || action(this.key, this.value) || this.right.inorderTraversal(action);
    };
    // Traverses the tree in reverse key order and calls the specified action
    // function for each node. If action returns true, traversal is aborted.
    // Returns the first truthy value returned by action, or the last falsey
    // value returned by action.
    LLRBNode.prototype.reverseTraversal = function (action) {
        return this.right.reverseTraversal(action) || action(this.key, this.value) || this.left.reverseTraversal(action);
    };
    // Returns the minimum node in the tree.
    LLRBNode.prototype.min = function () {
        if (this.left.isEmpty()) {
            return this;
        } else {
            return this.left.min();
        }
    };
    // Returns the maximum key in the tree.
    LLRBNode.prototype.minKey = function () {
        return this.min().key;
    };
    // Returns the maximum key in the tree.
    LLRBNode.prototype.maxKey = function () {
        if (this.right.isEmpty()) {
            return this.key;
        } else {
            return this.right.maxKey();
        }
    };
    // Returns new tree, with the key/value added.
    LLRBNode.prototype.insert = function (key, value, comparator) {
        var n = this;
        var cmp = comparator(key, n.key);
        if (cmp < 0) {
            n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);
        } else if (cmp === 0) {
            n = n.copy(null, value, null, null, null);
        } else {
            n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));
        }
        return n.fixUp();
    };
    LLRBNode.prototype.removeMin = function () {
        if (this.left.isEmpty()) {
            return LLRBNode.EMPTY;
        }
        var n = this;
        if (!n.left.isRed() && !n.left.left.isRed()) n = n.moveRedLeft();
        n = n.copy(null, null, null, n.left.removeMin(), null);
        return n.fixUp();
    };
    // Returns new tree, with the specified item removed.
    LLRBNode.prototype.remove = function (key, comparator) {
        var smallest;
        var n = this;
        if (comparator(key, n.key) < 0) {
            if (!n.left.isEmpty() && !n.left.isRed() && !n.left.left.isRed()) {
                n = n.moveRedLeft();
            }
            n = n.copy(null, null, null, n.left.remove(key, comparator), null);
        } else {
            if (n.left.isRed()) n = n.rotateRight();
            if (!n.right.isEmpty() && !n.right.isRed() && !n.right.left.isRed()) {
                n = n.moveRedRight();
            }
            if (comparator(key, n.key) === 0) {
                if (n.right.isEmpty()) {
                    return LLRBNode.EMPTY;
                } else {
                    smallest = n.right.min();
                    n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin());
                }
            }
            n = n.copy(null, null, null, null, n.right.remove(key, comparator));
        }
        return n.fixUp();
    };
    LLRBNode.prototype.isRed = function () {
        return this.color;
    };
    // Returns new tree after performing any needed rotations.
    LLRBNode.prototype.fixUp = function () {
        var n = this;
        if (n.right.isRed() && !n.left.isRed()) n = n.rotateLeft();
        if (n.left.isRed() && n.left.left.isRed()) n = n.rotateRight();
        if (n.left.isRed() && n.right.isRed()) n = n.colorFlip();
        return n;
    };
    LLRBNode.prototype.moveRedLeft = function () {
        var n = this.colorFlip();
        if (n.right.left.isRed()) {
            n = n.copy(null, null, null, null, n.right.rotateRight());
            n = n.rotateLeft();
            n = n.colorFlip();
        }
        return n;
    };
    LLRBNode.prototype.moveRedRight = function () {
        var n = this.colorFlip();
        if (n.left.left.isRed()) {
            n = n.rotateRight();
            n = n.colorFlip();
        }
        return n;
    };
    LLRBNode.prototype.rotateLeft = function () {
        var nl = this.copy(null, null, LLRBNode.RED, null, this.right.left);
        return this.right.copy(null, null, this.color, nl, null);
    };
    LLRBNode.prototype.rotateRight = function () {
        var nr = this.copy(null, null, LLRBNode.RED, this.left.right, null);
        return this.left.copy(null, null, this.color, null, nr);
    };
    LLRBNode.prototype.colorFlip = function () {
        var left = this.left.copy(null, null, !this.left.color, null, null);
        var right = this.right.copy(null, null, !this.right.color, null, null);
        return this.copy(null, null, !this.color, left, right);
    };
    // For testing.
    LLRBNode.prototype.checkMaxDepth = function () {
        var blackDepth = this.check();
        if (Math.pow(2.0, blackDepth) <= this.size + 1) {
            return true;
        } else {
            return false;
        }
    };
    // In a balanced RB tree, the black-depth (number of black nodes) from root to
    // leaves is equal on both sides.  This function verifies that or asserts.
    LLRBNode.prototype.check = function () {
        if (this.isRed() && this.left.isRed()) {
            throw fail('Red node has red child(' + this.key + ',' + this.value + ')');
        }
        if (this.right.isRed()) {
            throw fail('Right child of (' + this.key + ',' + this.value + ') is red');
        }
        var blackDepth = this.left.check();
        if (blackDepth !== this.right.check()) {
            throw fail('Black depths differ');
        } else {
            return blackDepth + (this.isRed() ? 0 : 1);
        }
    };
    LLRBNode.EMPTY = null;
    LLRBNode.RED = true;
    LLRBNode.BLACK = false;
    return LLRBNode;
}(); // end LLRBNode

// Represents an empty node (a leaf node in the Red-Black Tree).
var LLRBEmptyNode = /** @class */function () {
    function LLRBEmptyNode() {
        this.size = 0;
    }
    // Returns a copy of the current node.
    LLRBEmptyNode.prototype.copy = function (key, value, color, left, right) {
        return this;
    };
    // Returns a copy of the tree, with the specified key/value added.
    LLRBEmptyNode.prototype.insert = function (key, value, comparator) {
        return new sorted_map_LLRBNode(key, value);
    };
    // Returns a copy of the tree, with the specified key removed.
    LLRBEmptyNode.prototype.remove = function (key, comparator) {
        return this;
    };
    LLRBEmptyNode.prototype.isEmpty = function () {
        return true;
    };
    LLRBEmptyNode.prototype.inorderTraversal = function (action) {
        return false;
    };
    LLRBEmptyNode.prototype.reverseTraversal = function (action) {
        return false;
    };
    LLRBEmptyNode.prototype.minKey = function () {
        return null;
    };
    LLRBEmptyNode.prototype.maxKey = function () {
        return null;
    };
    LLRBEmptyNode.prototype.isRed = function () {
        return false;
    };
    // For testing.
    LLRBEmptyNode.prototype.checkMaxDepth = function () {
        return true;
    };
    LLRBEmptyNode.prototype.check = function () {
        return 0;
    };
    return LLRBEmptyNode;
}(); // end LLRBEmptyNode

sorted_map_LLRBNode.EMPTY = new LLRBEmptyNode();

//# sourceMappingURL=sorted_map.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/model/field_value.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var field_value___extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();




var TypeOrder;
(function (TypeOrder) {
    // This order is defined by the backend.
    TypeOrder[TypeOrder["NullValue"] = 0] = "NullValue";
    TypeOrder[TypeOrder["BooleanValue"] = 1] = "BooleanValue";
    TypeOrder[TypeOrder["NumberValue"] = 2] = "NumberValue";
    TypeOrder[TypeOrder["TimestampValue"] = 3] = "TimestampValue";
    TypeOrder[TypeOrder["StringValue"] = 4] = "StringValue";
    TypeOrder[TypeOrder["BlobValue"] = 5] = "BlobValue";
    TypeOrder[TypeOrder["RefValue"] = 6] = "RefValue";
    TypeOrder[TypeOrder["GeoPointValue"] = 7] = "GeoPointValue";
    TypeOrder[TypeOrder["ArrayValue"] = 8] = "ArrayValue";
    TypeOrder[TypeOrder["ObjectValue"] = 9] = "ObjectValue";
})(TypeOrder || (TypeOrder = {}));
/**
 * A field value represents a datatype as stored by Firestore.
 */
var field_value_FieldValue = /** @class */function () {
    function FieldValue() {}
    FieldValue.prototype.toString = function () {
        var val = this.value();
        return val === null ? 'null' : val.toString();
    };
    FieldValue.prototype.defaultCompareTo = function (other) {
        assert_assert(this.typeOrder !== other.typeOrder, 'Default compareTo should not be used for values of same type.');
        var cmp = primitiveComparator(this.typeOrder, other.typeOrder);
        return cmp;
    };
    return FieldValue;
}();

var NullValue = /** @class */function (_super) {
    field_value___extends(NullValue, _super);
    function NullValue() {
        var _this = _super.call(this) || this;
        _this.typeOrder = TypeOrder.NullValue;
        // internalValue is unused but we add it to work around
        // https://github.com/Microsoft/TypeScript/issues/15585
        _this.internalValue = null;
        return _this;
    }
    NullValue.prototype.value = function () {
        return null;
    };
    NullValue.prototype.equals = function (other) {
        return other instanceof NullValue;
    };
    NullValue.prototype.compareTo = function (other) {
        if (other instanceof NullValue) {
            return 0;
        }
        return this.defaultCompareTo(other);
    };
    NullValue.INSTANCE = new NullValue();
    return NullValue;
}(field_value_FieldValue);

var field_value_BooleanValue = /** @class */function (_super) {
    field_value___extends(BooleanValue, _super);
    function BooleanValue(internalValue) {
        var _this = _super.call(this) || this;
        _this.internalValue = internalValue;
        _this.typeOrder = TypeOrder.BooleanValue;
        return _this;
    }
    BooleanValue.prototype.value = function () {
        return this.internalValue;
    };
    BooleanValue.prototype.equals = function (other) {
        return other instanceof BooleanValue && this.internalValue === other.internalValue;
    };
    BooleanValue.prototype.compareTo = function (other) {
        if (other instanceof BooleanValue) {
            return primitiveComparator(this, other);
        }
        return this.defaultCompareTo(other);
    };
    BooleanValue.of = function (value) {
        return value ? BooleanValue.TRUE : BooleanValue.FALSE;
    };
    BooleanValue.TRUE = new BooleanValue(true);
    BooleanValue.FALSE = new BooleanValue(false);
    return BooleanValue;
}(field_value_FieldValue);

/** Base class for IntegerValue and DoubleValue. */
var NumberValue = /** @class */function (_super) {
    field_value___extends(NumberValue, _super);
    function NumberValue(internalValue) {
        var _this = _super.call(this) || this;
        _this.internalValue = internalValue;
        _this.typeOrder = TypeOrder.NumberValue;
        return _this;
    }
    NumberValue.prototype.value = function () {
        return this.internalValue;
    };
    NumberValue.prototype.compareTo = function (other) {
        if (other instanceof NumberValue) {
            return numericComparator(this.internalValue, other.internalValue);
        }
        return this.defaultCompareTo(other);
    };
    return NumberValue;
}(field_value_FieldValue);

/** Utility function to compare doubles (using Firestore semantics for NaN). */
function numericComparator(left, right) {
    if (left < right) {
        return -1;
    } else if (left > right) {
        return 1;
    } else if (left === right) {
        return 0;
    } else {
        // one or both are NaN.
        if (isNaN(left)) {
            return isNaN(right) ? 0 : -1;
        } else {
            return 1;
        }
    }
}
/**
 * Utility function to check numbers for equality using Firestore semantics
 * (NaN === NaN, -0.0 !== 0.0).
 */
function numericEquals(left, right) {
    // Implemented based on Object.is() polyfill from
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
    if (left === right) {
        // +0 != -0
        return left !== 0 || 1 / left === 1 / right;
    } else {
        // NaN == NaN
        return left !== left && right !== right;
    }
}
var IntegerValue = /** @class */function (_super) {
    field_value___extends(IntegerValue, _super);
    function IntegerValue(internalValue) {
        return _super.call(this, internalValue) || this;
    }
    IntegerValue.prototype.equals = function (other) {
        // NOTE: DoubleValue and IntegerValue instances may compareTo() the same,
        // but that doesn't make them equal via equals().
        if (other instanceof IntegerValue) {
            return numericEquals(this.internalValue, other.internalValue);
        } else {
            return false;
        }
    };
    return IntegerValue;
}(NumberValue);

var DoubleValue = /** @class */function (_super) {
    field_value___extends(DoubleValue, _super);
    function DoubleValue(internalValue) {
        var _this = _super.call(this, internalValue) || this;
        _this.internalValue = internalValue;
        return _this;
    }
    DoubleValue.prototype.equals = function (other) {
        // NOTE: DoubleValue and IntegerValue instances may compareTo() the same,
        // but that doesn't make them equal via equals().
        if (other instanceof DoubleValue) {
            return numericEquals(this.internalValue, other.internalValue);
        } else {
            return false;
        }
    };
    DoubleValue.NAN = new DoubleValue(NaN);
    DoubleValue.POSITIVE_INFINITY = new DoubleValue(Infinity);
    DoubleValue.NEGATIVE_INFINITY = new DoubleValue(-Infinity);
    return DoubleValue;
}(NumberValue);

// TODO(b/37267885): Add truncation support
var field_value_StringValue = /** @class */function (_super) {
    field_value___extends(StringValue, _super);
    function StringValue(internalValue) {
        var _this = _super.call(this) || this;
        _this.internalValue = internalValue;
        _this.typeOrder = TypeOrder.StringValue;
        return _this;
    }
    StringValue.prototype.value = function () {
        return this.internalValue;
    };
    StringValue.prototype.equals = function (other) {
        return other instanceof StringValue && this.internalValue === other.internalValue;
    };
    StringValue.prototype.compareTo = function (other) {
        if (other instanceof StringValue) {
            return primitiveComparator(this.internalValue, other.internalValue);
        }
        return this.defaultCompareTo(other);
    };
    return StringValue;
}(field_value_FieldValue);

var TimestampValue = /** @class */function (_super) {
    field_value___extends(TimestampValue, _super);
    function TimestampValue(internalValue) {
        var _this = _super.call(this) || this;
        _this.internalValue = internalValue;
        _this.typeOrder = TypeOrder.TimestampValue;
        return _this;
    }
    TimestampValue.prototype.value = function () {
        return this.internalValue.toDate();
    };
    TimestampValue.prototype.equals = function (other) {
        return other instanceof TimestampValue && this.internalValue.equals(other.internalValue);
    };
    TimestampValue.prototype.compareTo = function (other) {
        if (other instanceof TimestampValue) {
            return this.internalValue.compareTo(other.internalValue);
        } else if (other instanceof ServerTimestampValue) {
            // Concrete timestamps come before server timestamps.
            return -1;
        } else {
            return this.defaultCompareTo(other);
        }
    };
    return TimestampValue;
}(field_value_FieldValue);

/**
 * Represents a locally-applied ServerTimestamp.
 *
 * Notes:
 * - ServerTimestampValue instances are created as the result of applying a
 *   TransformMutation (see TransformMutation.applyTo()). They can only exist in
 *   the local view of a document. Therefore they do not need to be parsed or
 *   serialized.
 * - When evaluated locally (e.g. for snapshot.data()), they evaluate to null.
 * - With respect to other ServerTimestampValues, they sort by their
 *   localWriteTime.
 */
var ServerTimestampValue = /** @class */function (_super) {
    field_value___extends(ServerTimestampValue, _super);
    function ServerTimestampValue(localWriteTime) {
        var _this = _super.call(this) || this;
        _this.localWriteTime = localWriteTime;
        _this.typeOrder = TypeOrder.TimestampValue;
        return _this;
    }
    ServerTimestampValue.prototype.value = function () {
        return null;
    };
    ServerTimestampValue.prototype.equals = function (other) {
        return other instanceof ServerTimestampValue && this.localWriteTime.equals(other.localWriteTime);
    };
    ServerTimestampValue.prototype.compareTo = function (other) {
        if (other instanceof ServerTimestampValue) {
            return this.localWriteTime.compareTo(other.localWriteTime);
        } else if (other instanceof TimestampValue) {
            // Server timestamps come after all concrete timestamps.
            return 1;
        } else {
            return this.defaultCompareTo(other);
        }
    };
    ServerTimestampValue.prototype.toString = function () {
        return '<ServerTimestamp localTime=' + this.localWriteTime.toString() + '>';
    };
    return ServerTimestampValue;
}(field_value_FieldValue);

var BlobValue = /** @class */function (_super) {
    field_value___extends(BlobValue, _super);
    function BlobValue(internalValue) {
        var _this = _super.call(this) || this;
        _this.internalValue = internalValue;
        _this.typeOrder = TypeOrder.BlobValue;
        return _this;
    }
    BlobValue.prototype.value = function () {
        return this.internalValue;
    };
    BlobValue.prototype.equals = function (other) {
        return other instanceof BlobValue && this.internalValue._equals(other.internalValue);
    };
    BlobValue.prototype.compareTo = function (other) {
        if (other instanceof BlobValue) {
            return this.internalValue._compareTo(other.internalValue);
        }
        return this.defaultCompareTo(other);
    };
    return BlobValue;
}(field_value_FieldValue);

var field_value_RefValue = /** @class */function (_super) {
    field_value___extends(RefValue, _super);
    function RefValue(databaseId, key) {
        var _this = _super.call(this) || this;
        _this.databaseId = databaseId;
        _this.key = key;
        _this.typeOrder = TypeOrder.RefValue;
        return _this;
    }
    RefValue.prototype.value = function () {
        return this.key;
    };
    RefValue.prototype.equals = function (other) {
        if (other instanceof RefValue) {
            return this.key.equals(other.key) && this.databaseId.equals(other.databaseId);
        } else {
            return false;
        }
    };
    RefValue.prototype.compareTo = function (other) {
        if (other instanceof RefValue) {
            var cmp = this.databaseId.compareTo(other.databaseId);
            return cmp !== 0 ? cmp : document_key_DocumentKey.comparator(this.key, other.key);
        }
        return this.defaultCompareTo(other);
    };
    return RefValue;
}(field_value_FieldValue);

var GeoPointValue = /** @class */function (_super) {
    field_value___extends(GeoPointValue, _super);
    function GeoPointValue(internalValue) {
        var _this = _super.call(this) || this;
        _this.internalValue = internalValue;
        _this.typeOrder = TypeOrder.GeoPointValue;
        return _this;
    }
    GeoPointValue.prototype.value = function () {
        return this.internalValue;
    };
    GeoPointValue.prototype.equals = function (other) {
        return other instanceof GeoPointValue && this.internalValue._equals(other.internalValue);
    };
    GeoPointValue.prototype.compareTo = function (other) {
        if (other instanceof GeoPointValue) {
            return this.internalValue._compareTo(other.internalValue);
        }
        return this.defaultCompareTo(other);
    };
    return GeoPointValue;
}(field_value_FieldValue);

var field_value_ObjectValue = /** @class */function (_super) {
    field_value___extends(ObjectValue, _super);
    function ObjectValue(internalValue) {
        var _this = _super.call(this) || this;
        _this.internalValue = internalValue;
        _this.typeOrder = TypeOrder.ObjectValue;
        return _this;
    }
    ObjectValue.prototype.value = function () {
        var result = {};
        this.internalValue.inorderTraversal(function (key, val) {
            result[key] = val.value();
        });
        return result;
    };
    ObjectValue.prototype.forEach = function (action) {
        this.internalValue.inorderTraversal(action);
    };
    ObjectValue.prototype.equals = function (other) {
        if (other instanceof ObjectValue) {
            var it1 = this.internalValue.getIterator();
            var it2 = other.internalValue.getIterator();
            while (it1.hasNext() && it2.hasNext()) {
                var next1 = it1.getNext();
                var next2 = it2.getNext();
                if (next1.key !== next2.key || !next1.value.equals(next2.value)) {
                    return false;
                }
            }
            return !it1.hasNext() && !it2.hasNext();
        }
        return false;
    };
    ObjectValue.prototype.compareTo = function (other) {
        if (other instanceof ObjectValue) {
            var it1 = this.internalValue.getIterator();
            var it2 = other.internalValue.getIterator();
            while (it1.hasNext() && it2.hasNext()) {
                var next1 = it1.getNext();
                var next2 = it2.getNext();
                var cmp = primitiveComparator(next1.key, next2.key) || next1.value.compareTo(next2.value);
                if (cmp) {
                    return cmp;
                }
            }
            // Only equal if both iterators are exhausted
            return primitiveComparator(it1.hasNext(), it2.hasNext());
        } else {
            return this.defaultCompareTo(other);
        }
    };
    ObjectValue.prototype.set = function (path, to) {
        assert_assert(!path.isEmpty(), 'Cannot set field for empty path on ObjectValue');
        if (path.length === 1) {
            return this.setChild(path.firstSegment(), to);
        } else {
            var child = this.child(path.firstSegment());
            if (!(child instanceof ObjectValue)) {
                child = ObjectValue.EMPTY;
            }
            var newChild = child.set(path.popFirst(), to);
            return this.setChild(path.firstSegment(), newChild);
        }
    };
    ObjectValue.prototype.delete = function (path) {
        assert_assert(!path.isEmpty(), 'Cannot delete field for empty path on ObjectValue');
        if (path.length === 1) {
            return new ObjectValue(this.internalValue.remove(path.firstSegment()));
        } else {
            // nested field
            var child = this.child(path.firstSegment());
            if (child instanceof ObjectValue) {
                var newChild = child.delete(path.popFirst());
                return new ObjectValue(this.internalValue.insert(path.firstSegment(), newChild));
            } else {
                // Don't actually change a primitive value to an object for a delete
                return this;
            }
        }
    };
    ObjectValue.prototype.contains = function (path) {
        return this.field(path) !== undefined;
    };
    ObjectValue.prototype.field = function (path) {
        assert_assert(!path.isEmpty(), "Can't get field of empty path");
        var field = this;
        path.forEach(function (pathSegment) {
            if (field instanceof ObjectValue) {
                field = field.internalValue.get(pathSegment) || undefined;
            } else {
                field = undefined;
            }
        });
        return field;
    };
    ObjectValue.prototype.toString = function () {
        return JSON.stringify(this.value());
    };
    ObjectValue.prototype.child = function (childName) {
        return this.internalValue.get(childName) || undefined;
    };
    ObjectValue.prototype.setChild = function (childName, value) {
        return new ObjectValue(this.internalValue.insert(childName, value));
    };
    ObjectValue.EMPTY = new ObjectValue(new sorted_map_SortedMap(primitiveComparator));
    return ObjectValue;
}(field_value_FieldValue);

var field_value_ArrayValue = /** @class */function (_super) {
    field_value___extends(ArrayValue, _super);
    function ArrayValue(internalValue) {
        var _this = _super.call(this) || this;
        _this.internalValue = internalValue;
        _this.typeOrder = TypeOrder.ArrayValue;
        return _this;
    }
    ArrayValue.prototype.value = function () {
        return this.internalValue.map(function (v) {
            return v.value();
        });
    };
    ArrayValue.prototype.forEach = function (action) {
        this.internalValue.forEach(action);
    };
    ArrayValue.prototype.equals = function (other) {
        if (other instanceof ArrayValue) {
            if (this.internalValue.length !== other.internalValue.length) {
                return false;
            }
            for (var i = 0; i < this.internalValue.length; i++) {
                if (!this.internalValue[i].equals(other.internalValue[i])) {
                    return false;
                }
            }
            return true;
        }
        return false;
    };
    ArrayValue.prototype.compareTo = function (other) {
        if (other instanceof ArrayValue) {
            var minLength = Math.min(this.internalValue.length, other.internalValue.length);
            for (var i = 0; i < minLength; i++) {
                var cmp = this.internalValue[i].compareTo(other.internalValue[i]);
                if (cmp) {
                    return cmp;
                }
            }
            return primitiveComparator(this.internalValue.length, other.internalValue.length);
        } else {
            return this.defaultCompareTo(other);
        }
    };
    ArrayValue.prototype.toString = function () {
        return JSON.stringify(this.value());
    };
    return ArrayValue;
}(field_value_FieldValue);


//# sourceMappingURL=field_value.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/util/types.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// Untyped Number alias we can use to check for ES6 methods / properties.
// tslint:disable-next-line:no-any variable-name
var NumberAsAny = Number;
/**
 * Minimum safe integer in Javascript because of floating point precision.
 * Added to not rely on ES6 features.
 */
var MIN_SAFE_INTEGER = NumberAsAny.MIN_SAFE_INTEGER || -(Math.pow(2, 53) - 1);
/**
 * Maximum safe integer in Javascript because of floating point precision.
 * Added to not rely on ES6 features.
 */
var MAX_SAFE_INTEGER = NumberAsAny.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;
/**
 * Returns whether an number is an integer, uses native implementation if
 * available.
 * Added to not rely on ES6 features.
 * @param value The value to test for being an integer
 */
var isInteger = NumberAsAny.isInteger || function (value) {
  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;
};
/**
 * Returns whether a variable is either undefined or null.
 */
function isNullOrUndefined(value) {
  return value === null || value === undefined;
}
/**
 * Returns whether a value is an integer and in the safe integer range
 * @param value The value to test for being an integer and in the safe range
 */
function isSafeInteger(value) {
  return isInteger(value) && value <= MAX_SAFE_INTEGER && value >= MIN_SAFE_INTEGER;
}
/**
 * Safely checks if the number is NaN.
 */
function safeIsNaN(value) {
  if (NumberAsAny.IsNaN) {
    return NumberAsAny.IsNaN(value);
  } else {
    return typeof value === 'number' && isNaN(value);
  }
}

//# sourceMappingURL=types.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/core/query.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







var query_Query = /** @class */function () {
    function Query(path, explicitOrderBy, filters, limit, startAt, endAt) {
        if (explicitOrderBy === void 0) {
            explicitOrderBy = [];
        }
        if (filters === void 0) {
            filters = [];
        }
        if (limit === void 0) {
            limit = null;
        }
        if (startAt === void 0) {
            startAt = null;
        }
        if (endAt === void 0) {
            endAt = null;
        }
        this.path = path;
        this.explicitOrderBy = explicitOrderBy;
        this.filters = filters;
        this.limit = limit;
        this.startAt = startAt;
        this.endAt = endAt;
        this.memoizedCanonicalId = null;
        this.memoizedOrderBy = null;
        if (this.startAt) {
            this.assertValidBound(this.startAt);
        }
        if (this.endAt) {
            this.assertValidBound(this.endAt);
        }
    }
    Query.atPath = function (path) {
        return new Query(path);
    };
    Object.defineProperty(Query.prototype, "orderBy", {
        get: function get() {
            if (this.memoizedOrderBy === null) {
                var inequalityField = this.getInequalityFilterField();
                var firstOrderByField = this.getFirstOrderByField();
                if (inequalityField !== null && firstOrderByField === null) {
                    // In order to implicitly add key ordering, we must also add the
                    // inequality filter field for it to be a valid query.
                    // Note that the default inequality field and key ordering is ascending.
                    if (inequalityField.isKeyField()) {
                        this.memoizedOrderBy = [KEY_ORDERING_ASC];
                    } else {
                        this.memoizedOrderBy = [new query_OrderBy(inequalityField), KEY_ORDERING_ASC];
                    }
                } else {
                    assert_assert(inequalityField === null || firstOrderByField !== null && inequalityField.equals(firstOrderByField), 'First orderBy should match inequality field.');
                    this.memoizedOrderBy = [];
                    var foundKeyOrdering = false;
                    for (var _i = 0, _a = this.explicitOrderBy; _i < _a.length; _i++) {
                        var orderBy = _a[_i];
                        this.memoizedOrderBy.push(orderBy);
                        if (orderBy.field.isKeyField()) {
                            foundKeyOrdering = true;
                        }
                    }
                    if (!foundKeyOrdering) {
                        // The order of the implicit key ordering always matches the last
                        // explicit order by
                        var lastDirection = this.explicitOrderBy.length > 0 ? this.explicitOrderBy[this.explicitOrderBy.length - 1].dir : Direction.ASCENDING;
                        this.memoizedOrderBy.push(lastDirection === Direction.ASCENDING ? KEY_ORDERING_ASC : KEY_ORDERING_DESC);
                    }
                }
            }
            return this.memoizedOrderBy;
        },
        enumerable: true,
        configurable: true
    });
    Query.prototype.addFilter = function (filter) {
        assert_assert(this.getInequalityFilterField() == null || !(filter instanceof query_RelationFilter) || !filter.isInequality() || filter.field.equals(this.getInequalityFilterField()), 'Query must only have one inequality field.');
        assert_assert(!document_key_DocumentKey.isDocumentKey(this.path), 'No filtering allowed for document query');
        var newFilters = this.filters.concat([filter]);
        return new Query(this.path, this.explicitOrderBy.slice(), newFilters, this.limit, this.startAt, this.endAt);
    };
    Query.prototype.addOrderBy = function (orderBy) {
        assert_assert(!document_key_DocumentKey.isDocumentKey(this.path), 'No ordering allowed for document query');
        assert_assert(!this.startAt && !this.endAt, 'Bounds must be set after orderBy');
        // TODO(dimond): validate that orderBy does not list the same key twice.
        var newOrderBy = this.explicitOrderBy.concat([orderBy]);
        return new Query(this.path, newOrderBy, this.filters.slice(), this.limit, this.startAt, this.endAt);
    };
    Query.prototype.withLimit = function (limit) {
        return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), limit, this.startAt, this.endAt);
    };
    Query.prototype.withStartAt = function (bound) {
        return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, bound, this.endAt);
    };
    Query.prototype.withEndAt = function (bound) {
        return new Query(this.path, this.explicitOrderBy.slice(), this.filters.slice(), this.limit, this.startAt, bound);
    };
    // TODO(b/29183165): This is used to get a unique string from a query to, for
    // example, use as a dictionary key, but the implementation is subject to
    // collisions. Make it collision-free.
    Query.prototype.canonicalId = function () {
        if (this.memoizedCanonicalId === null) {
            var canonicalId = this.path.canonicalString();
            canonicalId += '|f:';
            for (var _i = 0, _a = this.filters; _i < _a.length; _i++) {
                var filter = _a[_i];
                canonicalId += filter.canonicalId();
                canonicalId += ',';
            }
            canonicalId += '|ob:';
            // TODO(dimond): make this collision resistant
            for (var _b = 0, _c = this.orderBy; _b < _c.length; _b++) {
                var orderBy = _c[_b];
                canonicalId += orderBy.canonicalId();
                canonicalId += ',';
            }
            if (!isNullOrUndefined(this.limit)) {
                canonicalId += '|l:';
                canonicalId += this.limit;
            }
            if (this.startAt) {
                canonicalId += '|lb:';
                canonicalId += this.startAt.canonicalId();
            }
            if (this.endAt) {
                canonicalId += '|ub:';
                canonicalId += this.endAt.canonicalId();
            }
            this.memoizedCanonicalId = canonicalId;
        }
        return this.memoizedCanonicalId;
    };
    Query.prototype.toString = function () {
        var str = 'Query(' + this.path.canonicalString();
        if (this.filters.length > 0) {
            str += ", filters: [" + this.filters.join(', ') + "]";
        }
        if (!isNullOrUndefined(this.limit)) {
            str += ', limit: ' + this.limit;
        }
        if (this.explicitOrderBy.length > 0) {
            str += ", orderBy: [" + this.explicitOrderBy.join(', ') + "]";
        }
        if (this.startAt) {
            str += ', startAt: ' + this.startAt.canonicalId();
        }
        if (this.endAt) {
            str += ', endAt: ' + this.endAt.canonicalId();
        }
        return str + ')';
    };
    Query.prototype.equals = function (other) {
        if (this.limit !== other.limit) {
            return false;
        }
        if (this.orderBy.length !== other.orderBy.length) {
            return false;
        }
        for (var i = 0; i < this.orderBy.length; i++) {
            if (!this.orderBy[i].equals(other.orderBy[i])) {
                return false;
            }
        }
        if (this.filters.length !== other.filters.length) {
            return false;
        }
        for (var i = 0; i < this.filters.length; i++) {
            if (!this.filters[i].equals(other.filters[i])) {
                return false;
            }
        }
        if (!this.path.equals(other.path)) {
            return false;
        }
        if (this.startAt !== null ? !this.startAt.equals(other.startAt) : other.startAt !== null) {
            return false;
        }
        return this.endAt !== null ? this.endAt.equals(other.endAt) : other.endAt === null;
    };
    Query.prototype.docComparator = function (d1, d2) {
        var comparedOnKeyField = false;
        for (var _i = 0, _a = this.orderBy; _i < _a.length; _i++) {
            var orderBy = _a[_i];
            var comp = orderBy.compare(d1, d2);
            if (comp !== 0) return comp;
            comparedOnKeyField = comparedOnKeyField || orderBy.field.isKeyField();
        }
        // Assert that we actually compared by key
        assert_assert(comparedOnKeyField, "orderBy used that doesn't compare on key field");
        return 0;
    };
    Query.prototype.matches = function (doc) {
        return this.matchesAncestor(doc) && this.matchesOrderBy(doc) && this.matchesFilters(doc) && this.matchesBounds(doc);
    };
    Query.prototype.hasLimit = function () {
        return !isNullOrUndefined(this.limit);
    };
    Query.prototype.getFirstOrderByField = function () {
        return this.explicitOrderBy.length > 0 ? this.explicitOrderBy[0].field : null;
    };
    Query.prototype.getInequalityFilterField = function () {
        for (var _i = 0, _a = this.filters; _i < _a.length; _i++) {
            var filter = _a[_i];
            if (filter instanceof query_RelationFilter && filter.isInequality()) {
                return filter.field;
            }
        }
        return null;
    };
    Query.prototype.isDocumentQuery = function () {
        return document_key_DocumentKey.isDocumentKey(this.path) && this.filters.length === 0;
    };
    Query.prototype.matchesAncestor = function (doc) {
        var docPath = doc.key.path;
        if (document_key_DocumentKey.isDocumentKey(this.path)) {
            // exact match for document queries
            return this.path.equals(docPath);
        } else {
            // shallow ancestor queries by default
            return this.path.isPrefixOf(docPath) && this.path.length === docPath.length - 1;
        }
    };
    /**
     * A document must have a value for every ordering clause in order to show up
     * in the results.
     */
    Query.prototype.matchesOrderBy = function (doc) {
        for (var _i = 0, _a = this.explicitOrderBy; _i < _a.length; _i++) {
            var orderBy = _a[_i];
            // order by key always matches
            if (!orderBy.field.isKeyField() && doc.field(orderBy.field) === undefined) {
                return false;
            }
        }
        return true;
    };
    Query.prototype.matchesFilters = function (doc) {
        for (var _i = 0, _a = this.filters; _i < _a.length; _i++) {
            var filter = _a[_i];
            if (!filter.matches(doc)) {
                return false;
            }
        }
        return true;
    };
    /**
     * Makes sure a document is within the bounds, if provided.
     */
    Query.prototype.matchesBounds = function (doc) {
        if (this.startAt && !this.startAt.sortsBeforeDocument(this.orderBy, doc)) {
            return false;
        }
        if (this.endAt && this.endAt.sortsBeforeDocument(this.orderBy, doc)) {
            return false;
        }
        return true;
    };
    Query.prototype.assertValidBound = function (bound) {
        assert_assert(bound.position.length <= this.orderBy.length, 'Bound is longer than orderBy');
    };
    return Query;
}();

var query_RelationOp = /** @class */function () {
    function RelationOp(name) {
        this.name = name;
    }
    RelationOp.fromString = function (op) {
        switch (op) {
            case '<':
                return RelationOp.LESS_THAN;
            case '<=':
                return RelationOp.LESS_THAN_OR_EQUAL;
            case '==':
                return RelationOp.EQUAL;
            case '>=':
                return RelationOp.GREATER_THAN_OR_EQUAL;
            case '>':
                return RelationOp.GREATER_THAN;
            default:
                return fail('Unknown relation: ' + op);
        }
    };
    RelationOp.prototype.toString = function () {
        return this.name;
    };
    RelationOp.prototype.equals = function (other) {
        return this.name === other.name;
    };
    RelationOp.LESS_THAN = new RelationOp('<');
    RelationOp.LESS_THAN_OR_EQUAL = new RelationOp('<=');
    RelationOp.EQUAL = new RelationOp('==');
    RelationOp.GREATER_THAN = new RelationOp('>');
    RelationOp.GREATER_THAN_OR_EQUAL = new RelationOp('>=');
    return RelationOp;
}();

var query_RelationFilter = /** @class */function () {
    function RelationFilter(field, op, value) {
        this.field = field;
        this.op = op;
        this.value = value;
    }
    RelationFilter.prototype.matches = function (doc) {
        if (this.field.isKeyField()) {
            assert_assert(this.value instanceof field_value_RefValue, 'Comparing on key, but filter value not a RefValue');
            var refValue = this.value;
            var comparison = document_key_DocumentKey.comparator(doc.key, refValue.key);
            return this.matchesComparison(comparison);
        } else {
            var val = doc.field(this.field);
            return val !== undefined && this.matchesValue(val);
        }
    };
    RelationFilter.prototype.matchesValue = function (value) {
        // Only compare types with matching backend order (such as double and int).
        if (this.value.typeOrder !== value.typeOrder) {
            return false;
        }
        return this.matchesComparison(value.compareTo(this.value));
    };
    RelationFilter.prototype.matchesComparison = function (comparison) {
        switch (this.op) {
            case query_RelationOp.LESS_THAN:
                return comparison < 0;
            case query_RelationOp.LESS_THAN_OR_EQUAL:
                return comparison <= 0;
            case query_RelationOp.EQUAL:
                return comparison === 0;
            case query_RelationOp.GREATER_THAN:
                return comparison > 0;
            case query_RelationOp.GREATER_THAN_OR_EQUAL:
                return comparison >= 0;
            default:
                return fail('Unknown relation op' + this.op);
        }
    };
    RelationFilter.prototype.isInequality = function () {
        return this.op !== query_RelationOp.EQUAL;
    };
    RelationFilter.prototype.canonicalId = function () {
        // TODO(b/29183165): Technically, this won't be unique if two values have
        // the same description, such as the int 3 and the string "3". So we should
        // add the types in here somehow, too.
        return this.field.canonicalString() + this.op.toString() + this.value.toString();
    };
    RelationFilter.prototype.equals = function (other) {
        if (other instanceof RelationFilter) {
            return this.op.equals(other.op) && this.field.equals(other.field) && this.value.equals(other.value);
        } else {
            return false;
        }
    };
    RelationFilter.prototype.toString = function () {
        return this.field.canonicalString() + " " + this.op + " " + this.value.value();
    };
    return RelationFilter;
}();

/**
 * Filter that matches 'null' values.
 */
var NullFilter = /** @class */function () {
    function NullFilter(field) {
        this.field = field;
    }
    NullFilter.prototype.matches = function (doc) {
        var val = doc.field(this.field);
        return val !== undefined && val.value() === null;
    };
    NullFilter.prototype.canonicalId = function () {
        return this.field.canonicalString() + ' IS null';
    };
    NullFilter.prototype.toString = function () {
        return this.field.canonicalString() + " IS null";
    };
    NullFilter.prototype.equals = function (other) {
        if (other instanceof NullFilter) {
            return this.field.equals(other.field);
        } else {
            return false;
        }
    };
    return NullFilter;
}();

/**
 * Filter that matches 'NaN' values.
 */
var NanFilter = /** @class */function () {
    function NanFilter(field) {
        this.field = field;
    }
    NanFilter.prototype.matches = function (doc) {
        var val = doc.field(this.field).value();
        return typeof val === 'number' && isNaN(val);
    };
    NanFilter.prototype.canonicalId = function () {
        return this.field.canonicalString() + ' IS NaN';
    };
    NanFilter.prototype.toString = function () {
        return this.field.canonicalString() + " IS NaN";
    };
    NanFilter.prototype.equals = function (other) {
        if (other instanceof NanFilter) {
            return this.field.equals(other.field);
        } else {
            return false;
        }
    };
    return NanFilter;
}();

/**
 * Creates a filter based on the provided arguments.
 */
function fieldFilter(field, op, value) {
    if (value.equals(NullValue.INSTANCE)) {
        if (op !== query_RelationOp.EQUAL) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You can only perform equals ' + 'comparisons on null.');
        }
        return new NullFilter(field);
    } else if (value.equals(DoubleValue.NAN)) {
        if (op !== query_RelationOp.EQUAL) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You can only perform equals ' + 'comparisons on NaN.');
        }
        return new NanFilter(field);
    } else {
        return new query_RelationFilter(field, op, value);
    }
}
/**
 * The direction of sorting in an order by.
 */
var Direction = /** @class */function () {
    function Direction(name) {
        this.name = name;
    }
    Direction.prototype.toString = function () {
        return this.name;
    };
    Direction.ASCENDING = new Direction('asc');
    Direction.DESCENDING = new Direction('desc');
    return Direction;
}();

/**
 * Represents a bound of a query.
 *
 * The bound is specified with the given components representing a position and
 * whether it's just before or just after the position (relative to whatever the
 * query order is).
 *
 * The position represents a logical index position for a query. It's a prefix
 * of values for the (potentially implicit) order by clauses of a query.
 *
 * Bound provides a function to determine whether a document comes before or
 * after a bound. This is influenced by whether the position is just before or
 * just after the provided values.
 */
var query_Bound = /** @class */function () {
    function Bound(position, before) {
        this.position = position;
        this.before = before;
    }
    Bound.prototype.canonicalId = function () {
        // TODO(b/29183165): Make this collision robust.
        var canonicalId = this.before ? 'b:' : 'a:';
        for (var _i = 0, _a = this.position; _i < _a.length; _i++) {
            var component = _a[_i];
            canonicalId += component.toString();
        }
        return canonicalId;
    };
    /**
     * Returns true if a document sorts before a bound using the provided sort
     * order.
     */
    Bound.prototype.sortsBeforeDocument = function (orderBy, doc) {
        assert_assert(this.position.length <= orderBy.length, "Bound has more components than query's orderBy");
        var comparison = 0;
        for (var i = 0; i < this.position.length; i++) {
            var orderByComponent = orderBy[i];
            var component = this.position[i];
            if (orderByComponent.field.isKeyField()) {
                assert_assert(component instanceof field_value_RefValue, 'Bound has a non-key value where the key path is being used.');
                comparison = document_key_DocumentKey.comparator(component.key, doc.key);
            } else {
                var docValue = doc.field(orderByComponent.field);
                assert_assert(docValue !== undefined, 'Field should exist since document matched the orderBy already.');
                comparison = component.compareTo(docValue);
            }
            if (orderByComponent.dir === Direction.DESCENDING) {
                comparison = comparison * -1;
            }
            if (comparison !== 0) {
                break;
            }
        }
        return this.before ? comparison <= 0 : comparison < 0;
    };
    Bound.prototype.equals = function (other) {
        if (other === null) {
            return false;
        }
        if (this.before !== other.before || this.position.length !== other.position.length) {
            return false;
        }
        for (var i = 0; i < this.position.length; i++) {
            var thisPosition = this.position[i];
            var otherPosition = other.position[i];
            return thisPosition.equals(otherPosition);
        }
        return true;
    };
    return Bound;
}();

/**
 * An ordering on a field, in some Direction. Direction defaults to ASCENDING.
 */
var query_OrderBy = /** @class */function () {
    function OrderBy(field, dir) {
        this.field = field;
        if (dir === undefined) {
            dir = Direction.ASCENDING;
        }
        this.dir = dir;
        this.isKeyOrderBy = field.isKeyField();
    }
    OrderBy.prototype.compare = function (d1, d2) {
        var comparison = this.isKeyOrderBy ? document_Document.compareByKey(d1, d2) : document_Document.compareByField(this.field, d1, d2);
        switch (this.dir) {
            case Direction.ASCENDING:
                return comparison;
            case Direction.DESCENDING:
                return -1 * comparison;
            default:
                return fail('Unknown direction: ' + this.dir);
        }
    };
    OrderBy.prototype.canonicalId = function () {
        // TODO(b/29183165): Make this collision robust.
        return this.field.canonicalString() + this.dir.toString();
    };
    OrderBy.prototype.toString = function () {
        return this.field.canonicalString() + " (" + this.dir + ")";
    };
    OrderBy.prototype.equals = function (other) {
        return this.dir === other.dir && this.field.equals(other.field);
    };
    return OrderBy;
}();

var KEY_ORDERING_ASC = new query_OrderBy(path_FieldPath.keyField(), Direction.ASCENDING);
var KEY_ORDERING_DESC = new query_OrderBy(path_FieldPath.keyField(), Direction.DESCENDING);

//# sourceMappingURL=query.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/core/timestamp.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


// A RegExp matching ISO 8601 UTC timestamps with optional fraction.
var isoRegExp = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
var timestamp_Timestamp = /** @class */function () {
    function Timestamp(seconds, nanos) {
        this.seconds = seconds;
        this.nanos = nanos;
        assert_assert(nanos >= 0, 'timestamp nanoseconds out of range: ' + nanos);
        assert_assert(nanos < 1e9, 'timestamp nanoseconds out of range' + nanos);
        // Midnight at the beginning of 1/1/1 is the earliest Firestore supports.
        assert_assert(seconds >= -62135596800, 'timestamp seconds out of range: ' + seconds);
        // This will break in the year 10,000.
        assert_assert(seconds < 253402300800, 'timestamp seconds out of range' + seconds);
    }
    Timestamp.now = function () {
        return Timestamp.fromEpochMilliseconds(Date.now());
    };
    Timestamp.fromDate = function (date) {
        return Timestamp.fromEpochMilliseconds(date.getTime());
    };
    Timestamp.fromEpochMilliseconds = function (milliseconds) {
        var seconds = Math.floor(milliseconds / 1000);
        var nanos = (milliseconds - seconds * 1000) * 1e6;
        return new Timestamp(seconds, nanos);
    };
    Timestamp.fromISOString = function (utc) {
        // The date string can have higher precision (nanos) than the Date class
        // (millis), so we do some custom parsing here.
        // Parse the nanos right out of the string.
        var nanos = 0;
        var fraction = isoRegExp.exec(utc);
        assert_assert(!!fraction, 'invalid timestamp: ' + utc);
        if (fraction[1]) {
            // Pad the fraction out to 9 digits (nanos).
            var nanoStr = fraction[1];
            nanoStr = (nanoStr + '000000000').substr(0, 9);
            nanos = parseInt(nanoStr, 10);
        }
        // Parse the date to get the seconds.
        var date = new Date(utc);
        var seconds = Math.floor(date.getTime() / 1000);
        return new Timestamp(seconds, nanos);
    };
    Timestamp.prototype.toDate = function () {
        return new Date(this.toEpochMilliseconds());
    };
    Timestamp.prototype.toEpochMilliseconds = function () {
        return this.seconds * 1000 + this.nanos / 1e6;
    };
    Timestamp.prototype.compareTo = function (other) {
        if (this.seconds === other.seconds) {
            return primitiveComparator(this.nanos, other.nanos);
        }
        return primitiveComparator(this.seconds, other.seconds);
    };
    Timestamp.prototype.equals = function (other) {
        return other.seconds === this.seconds && other.nanos === this.nanos;
    };
    Timestamp.prototype.toString = function () {
        return 'Timestamp(seconds=' + this.seconds + ', nanos=' + this.nanos + ')';
    };
    return Timestamp;
}();


//# sourceMappingURL=timestamp.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/core/snapshot_version.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A version of a document in Firestore. This corresponds to the version
 * timestamp, such as update_time or read_time.
 */
var snapshot_version_SnapshotVersion = /** @class */function () {
    function SnapshotVersion(timestamp) {
        this.timestamp = timestamp;
    }
    // TODO(b/34176344): Once we no longer need to use the old alpha protos,
    // delete this constructor and use a timestamp-backed version everywhere.
    SnapshotVersion.fromMicroseconds = function (value) {
        var seconds = Math.floor(value / 1e6);
        var nanos = value % 1e6 * 1e3;
        return new SnapshotVersion(new timestamp_Timestamp(seconds, nanos));
    };
    SnapshotVersion.fromTimestamp = function (value) {
        return new SnapshotVersion(value);
    };
    SnapshotVersion.forDeletedDoc = function () {
        return SnapshotVersion.MIN;
    };
    SnapshotVersion.prototype.compareTo = function (other) {
        return this.timestamp.compareTo(other.timestamp);
    };
    SnapshotVersion.prototype.equals = function (other) {
        return this.timestamp.equals(other.timestamp);
    };
    /** Returns a number representation of the version for use in spec tests. */
    SnapshotVersion.prototype.toMicroseconds = function () {
        // Convert to microseconds.
        return this.timestamp.seconds * 1e6 + this.timestamp.nanos / 1000;
    };
    SnapshotVersion.prototype.toString = function () {
        return 'SnapshotVersion(' + this.timestamp.toString() + ')';
    };
    SnapshotVersion.prototype.toTimestamp = function () {
        return this.timestamp;
    };
    SnapshotVersion.MIN = new SnapshotVersion(new timestamp_Timestamp(0, 0));
    return SnapshotVersion;
}();


//# sourceMappingURL=snapshot_version.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/local/query_data.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/** An enumeration of the different purposes we have for queries. */
var QueryPurpose;
(function (QueryPurpose) {
  /** A regular, normal query. */
  QueryPurpose[QueryPurpose["Listen"] = 0] = "Listen";
  /**
   * The query was used to refill a query after an existence filter mismatch.
   */
  QueryPurpose[QueryPurpose["ExistenceFilterMismatch"] = 1] = "ExistenceFilterMismatch";
  /** The query was used to resolve a limbo document. */
  QueryPurpose[QueryPurpose["LimboResolution"] = 2] = "LimboResolution";
})(QueryPurpose || (QueryPurpose = {}));
/**
 * An immutable set of metadata that the local store tracks for each query.
 */
var query_data_QueryData = /** @class */function () {
  function QueryData(
  /** The query being listened to. */
  query,
  /**
   * The target ID to which the query corresponds; Assigned by the
   * LocalStore for user listens and by the SyncEngine for limbo watches.
   */
  targetId,
  /** The purpose of the query. */
  purpose,
  /** The latest snapshot version seen for this target. */
  snapshotVersion,
  /**
   * An opaque, server-assigned token that allows watching a query to be
   * resumed after disconnecting without retransmitting all the data that
   * matches the query. The resume token essentially identifies a point in
   * time from which the server should resume sending results.
   */
  resumeToken) {
    if (snapshotVersion === void 0) {
      snapshotVersion = snapshot_version_SnapshotVersion.MIN;
    }
    if (resumeToken === void 0) {
      resumeToken = emptyByteString();
    }
    this.query = query;
    this.targetId = targetId;
    this.purpose = purpose;
    this.snapshotVersion = snapshotVersion;
    this.resumeToken = resumeToken;
  }
  /**
   * Creates a new query data instance with an updated snapshot version and
   * resume token.
   */
  QueryData.prototype.update = function (updated) {
    return new QueryData(this.query, this.targetId, this.purpose, updated.snapshotVersion, updated.resumeToken);
  };
  QueryData.prototype.equals = function (other) {
    return this.targetId === other.targetId && this.purpose === other.purpose && this.snapshotVersion.equals(other.snapshotVersion) && this.resumeToken === other.resumeToken && this.query.equals(other.query);
  };
  return QueryData;
}();


//# sourceMappingURL=query_data.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/model/mutation.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var mutation___extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();





/**
 * Provides a set of fields that can be used to partially patch a document.
 * FieldMask is used in conjunction with ObjectValue.
 * Examples:
 *   foo - Overwrites foo entirely with the provided value. If foo is not
 *         present in the companion ObjectValue, the field is deleted.
 *   foo.bar - Overwrites only the field bar of the object foo.
 *             If foo is not an object, foo is replaced with an object
 *             containing foo
 */
var mutation_FieldMask = /** @class */function () {
    function FieldMask(fields) {
        this.fields = fields;
        // TODO(dimond): validation of FieldMask
    }
    FieldMask.prototype.equals = function (other) {
        return arrayEquals(this.fields, other.fields);
    };
    return FieldMask;
}();

/** Transforms a value into a server-generated timestamp. */
var ServerTimestampTransform = /** @class */function () {
    function ServerTimestampTransform() {}
    ServerTimestampTransform.prototype.equals = function (other) {
        return other instanceof ServerTimestampTransform;
    };
    ServerTimestampTransform.instance = new ServerTimestampTransform();
    return ServerTimestampTransform;
}();

/** A field path and the TransformOperation to perform upon it. */
var FieldTransform = /** @class */function () {
    function FieldTransform(field, transform) {
        this.field = field;
        this.transform = transform;
    }
    FieldTransform.prototype.equals = function (other) {
        return this.field.equals(other.field) && this.transform.equals(other.transform);
    };
    return FieldTransform;
}();

/** The result of successfully applying a mutation to the backend. */
var MutationResult = /** @class */function () {
    function MutationResult(
    /**
     * The version at which the mutation was committed or null for a delete.
     */
    version,
    /**
     * The resulting fields returned from the backend after a
     * TransformMutation has been committed. Contains one FieldValue for each
     * FieldTransform that was in the mutation.
     *
     * Will be null if the mutation was not a TransformMutation.
     */
    transformResults) {
        this.version = version;
        this.transformResults = transformResults;
    }
    return MutationResult;
}();

var MutationType;
(function (MutationType) {
    MutationType[MutationType["Set"] = 0] = "Set";
    MutationType[MutationType["Patch"] = 1] = "Patch";
    MutationType[MutationType["Transform"] = 2] = "Transform";
    MutationType[MutationType["Delete"] = 3] = "Delete";
})(MutationType || (MutationType = {}));
/**
 * Encodes a precondition for a mutation. This follows the model that the
 * backend accepts with the special case of an explicit "empty" precondition
 * (meaning no precondition).
 */
var mutation_Precondition = /** @class */function () {
    function Precondition(updateTime, exists) {
        this.updateTime = updateTime;
        this.exists = exists;
        assert_assert(updateTime === undefined || exists === undefined, 'Precondition can specify "exists" or "updateTime" but not both');
    }
    /** Creates a new Precondition with an exists flag. */
    Precondition.exists = function (exists) {
        return new Precondition(undefined, exists);
    };
    /** Creates a new Precondition based on a version a document exists at. */
    Precondition.updateTime = function (version) {
        return new Precondition(version);
    };
    Object.defineProperty(Precondition.prototype, "isNone", {
        /** Returns whether this Precondition is empty. */
        get: function get() {
            return this.updateTime === undefined && this.exists === undefined;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns true if the preconditions is valid for the given document
     * (or null if no document is available).
     */
    Precondition.prototype.isValidFor = function (maybeDoc) {
        if (this.updateTime !== undefined) {
            return maybeDoc instanceof document_Document && maybeDoc.version.equals(this.updateTime);
        } else if (this.exists !== undefined) {
            if (this.exists) {
                return maybeDoc instanceof document_Document;
            } else {
                return maybeDoc === null || maybeDoc instanceof document_NoDocument;
            }
        } else {
            assert_assert(this.isNone, 'Precondition should be empty');
            return true;
        }
    };
    Precondition.prototype.equals = function (other) {
        return equals(this.updateTime, other.updateTime) && this.exists === other.exists;
    };
    Precondition.NONE = new Precondition();
    return Precondition;
}();

/**
 * A mutation describes a self-contained change to a document. Mutations can
 * create, replace, delete, and update subsets of documents.
 *
 * Mutations not only act on the value of the document but also it version.
 * In the case of Set, Patch, and Transform mutations we preserve the existing
 * version. In the case of Delete mutations, we reset the version to 0.
 *
 * Here's the expected transition table.
 *
 * MUTATION           APPLIED TO            RESULTS IN
 *
 * SetMutation        Document(v3)          Document(v3)
 * SetMutation        NoDocument(v3)        Document(v0)
 * SetMutation        null                  Document(v0)
 * PatchMutation      Document(v3)          Document(v3)
 * PatchMutation      NoDocument(v3)        NoDocument(v3)
 * PatchMutation      null                  null
 * TransformMutation  Document(v3)          Document(v3)
 * TransformMutation  NoDocument(v3)        NoDocument(v3)
 * TransformMutation  null                  null
 * DeleteMutation     Document(v3)          NoDocument(v0)
 * DeleteMutation     NoDocument(v3)        NoDocument(v0)
 * DeleteMutation     null                  NoDocument(v0)
 *
 * Note that TransformMutations don't create Documents (in the case of being
 * applied to a NoDocument), even though they would on the backend. This is
 * because the client always combines the TransformMutation with a SetMutation
 * or PatchMutation and we only want to apply the transform if the prior
 * mutation resulted in a Document (always true for a SetMutation, but not
 * necessarily for a PatchMutation).
 *
 * ## Subclassing Notes
 *
 * Subclasses of Mutation need to implement applyToRemoteDocument() and
 * applyToLocalView() to implement the actual behavior of applying the mutation
 * to some source document.
 */
var mutation_Mutation = /** @class */function () {
    function Mutation() {}
    Mutation.prototype.verifyKeyMatches = function (maybeDoc) {
        if (maybeDoc != null) {
            assert_assert(maybeDoc.key.equals(this.key), 'Can only apply a mutation to a document with the same key');
        }
    };
    /**
     * Returns the version from the given document for use as the result of a
     * mutation. Mutations are defined to return the version of the base document
     * only if it is an existing document. Deleted and unknown documents have a
     * post-mutation version of SnapshotVersion.MIN.
     */
    Mutation.getPostMutationVersion = function (maybeDoc) {
        if (maybeDoc instanceof document_Document) {
            return maybeDoc.version;
        } else {
            return snapshot_version_SnapshotVersion.MIN;
        }
    };
    return Mutation;
}();

/**
 * A mutation that creates or replaces the document at the given key with the
 * object value contents.
 */
var mutation_SetMutation = /** @class */function (_super) {
    mutation___extends(SetMutation, _super);
    function SetMutation(key, value, precondition) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.value = value;
        _this.precondition = precondition;
        _this.type = MutationType.Set;
        return _this;
    }
    SetMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {
        this.verifyKeyMatches(maybeDoc);
        assert_assert(mutationResult.transformResults == null, 'Transform results received by SetMutation.');
        // Unlike applyToLocalView, if we're applying a mutation to a remote
        // document the server has accepted the mutation so the precondition must
        // have held.
        var version = mutation_Mutation.getPostMutationVersion(maybeDoc);
        return new document_Document(this.key, version, this.value, {
            hasLocalMutations: false
        });
    };
    SetMutation.prototype.applyToLocalView = function (maybeDoc, localWriteTime) {
        this.verifyKeyMatches(maybeDoc);
        if (!this.precondition.isValidFor(maybeDoc)) {
            return maybeDoc;
        }
        var version = mutation_Mutation.getPostMutationVersion(maybeDoc);
        return new document_Document(this.key, version, this.value, {
            hasLocalMutations: true
        });
    };
    SetMutation.prototype.equals = function (other) {
        return other instanceof SetMutation && this.key.equals(other.key) && this.value.equals(other.value) && this.precondition.equals(other.precondition);
    };
    return SetMutation;
}(mutation_Mutation);

/**
 * A mutation that modifies fields of the document at the given key with the
 * given values. The values are applied through a field mask:
 *
 *  * When a field is in both the mask and the values, the corresponding field
 *    is updated.
 *  * When a field is in neither the mask nor the values, the corresponding
 *    field is unmodified.
 *  * When a field is in the mask but not in the values, the corresponding field
 *    is deleted.
 *  * When a field is not in the mask but is in the values, the values map is
 *    ignored.
 */
var mutation_PatchMutation = /** @class */function (_super) {
    mutation___extends(PatchMutation, _super);
    function PatchMutation(key, data, fieldMask, precondition) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.data = data;
        _this.fieldMask = fieldMask;
        _this.precondition = precondition;
        _this.type = MutationType.Patch;
        return _this;
    }
    PatchMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {
        this.verifyKeyMatches(maybeDoc);
        assert_assert(mutationResult.transformResults == null, 'Transform results received by PatchMutation.');
        // TODO(mcg): Relax enforcement of this precondition
        //
        // We shouldn't actually enforce the precondition since it already passed on
        // the backend, but we may not have a local version of the document to
        // patch, so we use the precondition to prevent incorrectly putting a
        // partial document into our cache.
        if (!this.precondition.isValidFor(maybeDoc)) {
            return maybeDoc;
        }
        var version = mutation_Mutation.getPostMutationVersion(maybeDoc);
        var newData = this.patchDocument(maybeDoc);
        return new document_Document(this.key, version, newData, {
            hasLocalMutations: false
        });
    };
    PatchMutation.prototype.applyToLocalView = function (maybeDoc, localWriteTime) {
        this.verifyKeyMatches(maybeDoc);
        if (!this.precondition.isValidFor(maybeDoc)) {
            return maybeDoc;
        }
        var version = mutation_Mutation.getPostMutationVersion(maybeDoc);
        var newData = this.patchDocument(maybeDoc);
        return new document_Document(this.key, version, newData, {
            hasLocalMutations: true
        });
    };
    PatchMutation.prototype.equals = function (other) {
        return other instanceof PatchMutation && this.key.equals(other.key) && this.fieldMask.equals(other.fieldMask) && this.precondition.equals(other.precondition);
    };
    /**
     * Patches the data of document if available or creates a new document. Note
     * that this does not check whether or not the precondition of this patch
     * holds.
     */
    PatchMutation.prototype.patchDocument = function (maybeDoc) {
        var data;
        if (maybeDoc instanceof document_Document) {
            data = maybeDoc.data;
        } else {
            data = field_value_ObjectValue.EMPTY;
        }
        return this.patchObject(data);
    };
    PatchMutation.prototype.patchObject = function (data) {
        for (var _i = 0, _a = this.fieldMask.fields; _i < _a.length; _i++) {
            var fieldPath = _a[_i];
            var newValue = this.data.field(fieldPath);
            if (newValue !== undefined) {
                data = data.set(fieldPath, newValue);
            } else {
                data = data.delete(fieldPath);
            }
        }
        return data;
    };
    return PatchMutation;
}(mutation_Mutation);

/**
 * A mutation that modifies specific fields of the document with transform
 * operations. Currently the only supported transform is a server timestamp, but
 * IP Address, increment(n), etc. could be supported in the future.
 *
 * It is somewhat similar to a PatchMutation in that it patches specific fields
 * and has no effect when applied to a null or NoDocument (see comment on
 * Mutation for rationale).
 */
var mutation_TransformMutation = /** @class */function (_super) {
    mutation___extends(TransformMutation, _super);
    function TransformMutation(key, fieldTransforms) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.fieldTransforms = fieldTransforms;
        _this.type = MutationType.Transform;
        // NOTE: We set a precondition of exists: true as a safety-check, since we
        // always combine TransformMutations with a SetMutation or PatchMutation which
        // (if successful) should end up with an existing document.
        _this.precondition = mutation_Precondition.exists(true);
        return _this;
    }
    TransformMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {
        this.verifyKeyMatches(maybeDoc);
        assert_assert(mutationResult.transformResults != null, 'Transform results missing for TransformMutation.');
        var transformResults = mutationResult.transformResults;
        // TODO(mcg): Relax enforcement of this precondition
        //
        // We shouldn't actually enforce the precondition since it already passed on
        // the backend, but we may not have a local version of the document to
        // patch, so we use the precondition to prevent incorrectly putting a
        // partial document into our cache.
        if (!this.precondition.isValidFor(maybeDoc)) {
            return maybeDoc;
        }
        var doc = this.requireDocument(maybeDoc);
        var newData = this.transformObject(doc.data, transformResults);
        return new document_Document(this.key, doc.version, newData, {
            hasLocalMutations: false
        });
    };
    TransformMutation.prototype.applyToLocalView = function (maybeDoc, localWriteTime) {
        this.verifyKeyMatches(maybeDoc);
        if (!this.precondition.isValidFor(maybeDoc)) {
            return maybeDoc;
        }
        var doc = this.requireDocument(maybeDoc);
        var transformResults = this.localTransformResults(localWriteTime);
        var newData = this.transformObject(doc.data, transformResults);
        return new document_Document(this.key, doc.version, newData, {
            hasLocalMutations: true
        });
    };
    TransformMutation.prototype.equals = function (other) {
        return other instanceof TransformMutation && this.key.equals(other.key) && arrayEquals(this.fieldTransforms, other.fieldTransforms) && this.precondition.equals(other.precondition);
    };
    /**
     * Asserts that the given MaybeDocument is actually a Document and verifies
     * that it matches the key for this mutation. Since we only support
     * transformations with precondition exists this method is guaranteed to be
     * safe.
     */
    TransformMutation.prototype.requireDocument = function (maybeDoc) {
        assert_assert(maybeDoc instanceof document_Document, 'Unknown MaybeDocument type ' + maybeDoc);
        var doc = maybeDoc;
        assert_assert(doc.key.equals(this.key), 'Can only transform a document with the same key');
        return doc;
    };
    /**
     * Creates a list of "transform results" (a transform result is a field value
     * representing the result of applying a transform) for use when applying a
     * TransformMutation locally.
     *
     * @param localWriteTime The local time of the transform mutation (used to
     *     generate ServerTimestampValues).
     * @return The transform results list.
     */
    TransformMutation.prototype.localTransformResults = function (localWriteTime) {
        var transformResults = [];
        for (var _i = 0, _a = this.fieldTransforms; _i < _a.length; _i++) {
            var fieldTransform = _a[_i];
            var transform = fieldTransform.transform;
            if (transform instanceof ServerTimestampTransform) {
                transformResults.push(new ServerTimestampValue(localWriteTime));
            } else {
                return fail('Encountered unknown transform: ' + transform);
            }
        }
        return transformResults;
    };
    TransformMutation.prototype.transformObject = function (data, transformResults) {
        assert_assert(transformResults.length === this.fieldTransforms.length, 'TransformResults length mismatch.');
        for (var i = 0; i < this.fieldTransforms.length; i++) {
            var fieldTransform = this.fieldTransforms[i];
            var transform = fieldTransform.transform;
            var fieldPath = fieldTransform.field;
            if (transform instanceof ServerTimestampTransform) {
                data = data.set(fieldPath, transformResults[i]);
            } else {
                return fail('Encountered unknown transform: ' + transform);
            }
        }
        return data;
    };
    return TransformMutation;
}(mutation_Mutation);

/** A mutation that deletes the document at the given key. */
var mutation_DeleteMutation = /** @class */function (_super) {
    mutation___extends(DeleteMutation, _super);
    function DeleteMutation(key, precondition) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.precondition = precondition;
        _this.type = MutationType.Delete;
        return _this;
    }
    DeleteMutation.prototype.applyToRemoteDocument = function (maybeDoc, mutationResult) {
        this.verifyKeyMatches(maybeDoc);
        assert_assert(mutationResult.transformResults == null, 'Transform results received by DeleteMutation.');
        // Unlike applyToLocalView, if we're applying a mutation to a remote
        // document the server has accepted the mutation so the precondition must
        // have held.
        return new document_NoDocument(this.key, snapshot_version_SnapshotVersion.MIN);
    };
    DeleteMutation.prototype.applyToLocalView = function (maybeDoc, localWriteTime) {
        this.verifyKeyMatches(maybeDoc);
        if (!this.precondition.isValidFor(maybeDoc)) {
            return maybeDoc;
        }
        if (maybeDoc) {
            assert_assert(maybeDoc.key.equals(this.key), 'Can only apply mutation to document with same key');
        }
        return new document_NoDocument(this.key, snapshot_version_SnapshotVersion.forDeletedDoc());
    };
    DeleteMutation.prototype.equals = function (other) {
        return other instanceof DeleteMutation && this.key.equals(other.key) && this.precondition.equals(other.precondition);
    };
    return DeleteMutation;
}(mutation_Mutation);


//# sourceMappingURL=mutation.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/remote/existence_filter.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ExistenceFilter = /** @class */function () {
    // TODO(b/33078163): just use simplest form of existence filter for now
    function ExistenceFilter(count) {
        this.count = count;
    }
    ExistenceFilter.prototype.equals = function (other) {
        return other && other.count === this.count;
    };
    return ExistenceFilter;
}();


//# sourceMappingURL=existence_filter.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/remote/rpc_error.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Error Codes describing the different ways GRPC can fail. These are copied
 * directly from GRPC's sources here:
 *
 * https://github.com/grpc/grpc/blob/bceec94ea4fc5f0085d81235d8e1c06798dc341a/include/grpc%2B%2B/impl/codegen/status_code_enum.h
 *
 * Important! The names of these identifiers matter because the string forms
 * are used for reverse lookups from the webchannel stream. Do NOT change the
 * names of these identifiers.
 */
var RpcCode;
(function (RpcCode) {
    RpcCode[RpcCode["OK"] = 0] = "OK";
    RpcCode[RpcCode["CANCELLED"] = 1] = "CANCELLED";
    RpcCode[RpcCode["UNKNOWN"] = 2] = "UNKNOWN";
    RpcCode[RpcCode["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
    RpcCode[RpcCode["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
    RpcCode[RpcCode["NOT_FOUND"] = 5] = "NOT_FOUND";
    RpcCode[RpcCode["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
    RpcCode[RpcCode["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
    RpcCode[RpcCode["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
    RpcCode[RpcCode["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
    RpcCode[RpcCode["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
    RpcCode[RpcCode["ABORTED"] = 10] = "ABORTED";
    RpcCode[RpcCode["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
    RpcCode[RpcCode["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
    RpcCode[RpcCode["INTERNAL"] = 13] = "INTERNAL";
    RpcCode[RpcCode["UNAVAILABLE"] = 14] = "UNAVAILABLE";
    RpcCode[RpcCode["DATA_LOSS"] = 15] = "DATA_LOSS";
})(RpcCode || (RpcCode = {}));
function isPermanentError(code) {
    switch (code) {
        case Code.OK:
            return fail('Treated status OK as error');
        case Code.CANCELLED:
        case Code.UNKNOWN:
        case Code.DEADLINE_EXCEEDED:
        case Code.RESOURCE_EXHAUSTED:
        case Code.INTERNAL:
        case Code.UNAVAILABLE:
        // Unauthenticated means something went wrong with our token and we need
        // to retry with new credentials which will happen automatically.
        // TODO(b/37325376): Give up after second unauthenticated error.
        case Code.UNAUTHENTICATED:
            return false;
        case Code.INVALID_ARGUMENT:
        case Code.NOT_FOUND:
        case Code.ALREADY_EXISTS:
        case Code.PERMISSION_DENIED:
        case Code.FAILED_PRECONDITION:
        // Aborted might be retried in some scenarios, but that is dependant on
        // the context and should handled individually by the calling code.
        // See https://cloud.google.com/apis/design/errors.
        case Code.ABORTED:
        case Code.OUT_OF_RANGE:
        case Code.UNIMPLEMENTED:
        case Code.DATA_LOSS:
            return true;
        default:
            return fail('Unknown status code: ' + code);
    }
}
/**
 * Maps an error Code from a GRPC status identifier like 'NOT_FOUND'.
 *
 * @returns The Code equivalent to the given status string or undefined if
 *     there is no match.
 */
function mapCodeFromRpcStatus(status) {
    // tslint:disable-next-line:no-any lookup by string
    var code = RpcCode[status];
    if (code === undefined) {
        return undefined;
    }
    return mapCodeFromRpcCode(code);
}
/**
 * Maps an error Code from GRPC status code number, like 0, 1, or 14. These
 * are not the same as HTTP status codes.
 *
 * @returns The Code equivalent to the given GRPC status code. Fails if there
 *     is no match.
 */
function mapCodeFromRpcCode(code) {
    if (code === undefined) {
        // This shouldn't normally happen, but in certain error cases (like trying
        // to send invalid proto messages) we may get an error with no GRPC code.
        log_error('GRPC error has no .code');
        return Code.UNKNOWN;
    }
    switch (code) {
        case RpcCode.OK:
            return Code.OK;
        case RpcCode.CANCELLED:
            return Code.CANCELLED;
        case RpcCode.UNKNOWN:
            return Code.UNKNOWN;
        case RpcCode.DEADLINE_EXCEEDED:
            return Code.DEADLINE_EXCEEDED;
        case RpcCode.RESOURCE_EXHAUSTED:
            return Code.RESOURCE_EXHAUSTED;
        case RpcCode.INTERNAL:
            return Code.INTERNAL;
        case RpcCode.UNAVAILABLE:
            return Code.UNAVAILABLE;
        case RpcCode.UNAUTHENTICATED:
            return Code.UNAUTHENTICATED;
        case RpcCode.INVALID_ARGUMENT:
            return Code.INVALID_ARGUMENT;
        case RpcCode.NOT_FOUND:
            return Code.NOT_FOUND;
        case RpcCode.ALREADY_EXISTS:
            return Code.ALREADY_EXISTS;
        case RpcCode.PERMISSION_DENIED:
            return Code.PERMISSION_DENIED;
        case RpcCode.FAILED_PRECONDITION:
            return Code.FAILED_PRECONDITION;
        case RpcCode.ABORTED:
            return Code.ABORTED;
        case RpcCode.OUT_OF_RANGE:
            return Code.OUT_OF_RANGE;
        case RpcCode.UNIMPLEMENTED:
            return Code.UNIMPLEMENTED;
        case RpcCode.DATA_LOSS:
            return Code.DATA_LOSS;
        default:
            return fail('Unknown status code: ' + code);
    }
}
/**
 * Maps an RPC code from a Code. This is the reverse operation from
 * mapCodeFromRpcCode and should really only be used in tests.
 */
function mapRpcCodeFromCode(code) {
    if (code === undefined) {
        return RpcCode.OK;
    }
    switch (code) {
        case Code.OK:
            return RpcCode.OK;
        case Code.CANCELLED:
            return RpcCode.CANCELLED;
        case Code.UNKNOWN:
            return RpcCode.UNKNOWN;
        case Code.DEADLINE_EXCEEDED:
            return RpcCode.DEADLINE_EXCEEDED;
        case Code.RESOURCE_EXHAUSTED:
            return RpcCode.RESOURCE_EXHAUSTED;
        case Code.INTERNAL:
            return RpcCode.INTERNAL;
        case Code.UNAVAILABLE:
            return RpcCode.UNAVAILABLE;
        case Code.UNAUTHENTICATED:
            return RpcCode.UNAUTHENTICATED;
        case Code.INVALID_ARGUMENT:
            return RpcCode.INVALID_ARGUMENT;
        case Code.NOT_FOUND:
            return RpcCode.NOT_FOUND;
        case Code.ALREADY_EXISTS:
            return RpcCode.ALREADY_EXISTS;
        case Code.PERMISSION_DENIED:
            return RpcCode.PERMISSION_DENIED;
        case Code.FAILED_PRECONDITION:
            return RpcCode.FAILED_PRECONDITION;
        case Code.ABORTED:
            return RpcCode.ABORTED;
        case Code.OUT_OF_RANGE:
            return RpcCode.OUT_OF_RANGE;
        case Code.UNIMPLEMENTED:
            return RpcCode.UNIMPLEMENTED;
        case Code.DATA_LOSS:
            return RpcCode.DATA_LOSS;
        default:
            return fail('Unknown status code: ' + code);
    }
}
/**
 * Converts an HTTP Status Code to the equivalent error code.
 *
 * @param status An HTTP Status Code, like 200, 404, 503, etc.
 * @returns The equivalent Code. Unknown status codes are mapped to
 *     Code.UNKNOWN.
 */
function mapCodeFromHttpStatus(status) {
    // The canonical error codes for Google APIs [1] specify mapping onto HTTP
    // status codes but the mapping is not bijective. In each case of ambiguity
    // this function chooses a primary error.
    //
    // [1]
    // https://github.com/googleapis/googleapis/blob/master/google/rpc/code.proto
    switch (status) {
        case 200:
            // OK
            return Code.OK;
        case 400:
            // Bad Request
            return Code.INVALID_ARGUMENT;
        // Other possibilities based on the forward mapping
        // return Code.FAILED_PRECONDITION;
        // return Code.OUT_OF_RANGE;
        case 401:
            // Unauthorized
            return Code.UNAUTHENTICATED;
        case 403:
            // Forbidden
            return Code.PERMISSION_DENIED;
        case 404:
            // Not Found
            return Code.NOT_FOUND;
        case 409:
            // Conflict
            return Code.ABORTED;
        // Other possibilities:
        // return Code.ALREADY_EXISTS;
        case 416:
            // Range Not Satisfiable
            return Code.OUT_OF_RANGE;
        case 429:
            // Too Many Requests
            return Code.RESOURCE_EXHAUSTED;
        case 499:
            // Client Closed Request
            return Code.CANCELLED;
        case 500:
            // Internal Server Error
            return Code.UNKNOWN;
        // Other possibilities:
        // return Code.INTERNAL;
        // return Code.DATA_LOSS;
        case 501:
            // Unimplemented
            return Code.UNIMPLEMENTED;
        case 503:
            // Service Unavailable
            return Code.UNAVAILABLE;
        case 504:
            // Gateway Timeout
            return Code.DEADLINE_EXCEEDED;
        default:
            if (status >= 200 && status < 300) return Code.OK;
            if (status >= 400 && status < 500) return Code.FAILED_PRECONDITION;
            if (status >= 500 && status < 600) return Code.INTERNAL;
            return Code.UNKNOWN;
    }
}

//# sourceMappingURL=rpc_error.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/util/sorted_set.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * SortedSet is an immutable (copy-on-write) collection that holds elements
 * in order specified by the provided comparator.
 *
 * NOTE: if provided comparator returns 0 for two elements, we consider them to
 * be equal!
 */
var sorted_set_SortedSet = /** @class */function () {
    function SortedSet(comparator) {
        this.comparator = comparator;
        this.data = new sorted_map_SortedMap(this.comparator);
    }
    /**
     * Creates a SortedSet from the keys of the map.
     * This is currently implemented as an O(n) copy.
     */
    SortedSet.fromMapKeys = function (map) {
        var keys = new SortedSet(map.comparator);
        map.forEach(function (key) {
            keys = keys.add(key);
        });
        return keys;
    };
    SortedSet.prototype.has = function (elem) {
        return this.data.get(elem) !== null;
    };
    SortedSet.prototype.first = function () {
        return this.data.minKey();
    };
    SortedSet.prototype.last = function () {
        return this.data.maxKey();
    };
    Object.defineProperty(SortedSet.prototype, "size", {
        get: function get() {
            return this.data.size;
        },
        enumerable: true,
        configurable: true
    });
    SortedSet.prototype.indexOf = function (elem) {
        return this.data.indexOf(elem);
    };
    /** Iterates elements in order defined by "comparator" */
    SortedSet.prototype.forEach = function (cb) {
        this.data.inorderTraversal(function (k, v) {
            cb(k);
            return false;
        });
    };
    /** Iterates over `elem`s such that: range[0] <= elem < range[1]. */
    SortedSet.prototype.forEachInRange = function (range, cb) {
        var iter = this.data.getIteratorFrom(range[0]);
        while (iter.hasNext()) {
            var elem = iter.getNext();
            if (this.comparator(elem.key, range[1]) >= 0) return;
            cb(elem.key);
        }
    };
    /**
     * Iterates over `elem`s such that: start <= elem until false is returned.
     */
    SortedSet.prototype.forEachWhile = function (cb, start) {
        var iter;
        if (start !== undefined) {
            iter = this.data.getIteratorFrom(start);
        } else {
            iter = this.data.getIterator();
        }
        while (iter.hasNext()) {
            var elem = iter.getNext();
            var result = cb(elem.key);
            if (!result) return;
        }
    };
    /** Finds the least element greater than or equal to `elem`. */
    SortedSet.prototype.firstAfterOrEqual = function (elem) {
        var iter = this.data.getIteratorFrom(elem);
        return iter.hasNext() ? iter.getNext().key : null;
    };
    /** Inserts or updates an element */
    SortedSet.prototype.add = function (elem) {
        return this.copy(this.data.remove(elem).insert(elem, true));
    };
    /** Deletes an element */
    SortedSet.prototype.delete = function (elem) {
        if (!this.has(elem)) return this;
        return this.copy(this.data.remove(elem));
    };
    SortedSet.prototype.isEmpty = function () {
        return this.data.isEmpty();
    };
    SortedSet.prototype.unionWith = function (other) {
        var result = this;
        other.forEach(function (elem) {
            result = result.add(elem);
        });
        return result;
    };
    SortedSet.prototype.equals = function (other) {
        if (!(other instanceof SortedSet)) return false;
        if (this.size !== other.size) return false;
        var thisIt = this.data.getIterator();
        var otherIt = other.data.getIterator();
        while (thisIt.hasNext()) {
            var thisElem = thisIt.getNext().key;
            var otherElem = otherIt.getNext().key;
            if (this.comparator(thisElem, otherElem) !== 0) return false;
        }
        return true;
    };
    SortedSet.prototype.toString = function () {
        var result = [];
        this.forEach(function (elem) {
            return result.push(elem);
        });
        return 'SortedSet(' + result.toString() + ')';
    };
    SortedSet.prototype.copy = function (data) {
        var result = new SortedSet(this.comparator);
        result.data = data;
        return result;
    };
    return SortedSet;
}();


//# sourceMappingURL=sorted_set.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/model/collections.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var EMPTY_MAYBE_DOCUMENT_MAP = new sorted_map_SortedMap(document_key_DocumentKey.comparator);
function maybeDocumentMap() {
    return EMPTY_MAYBE_DOCUMENT_MAP;
}
var EMPTY_DOCUMENT_MAP = new sorted_map_SortedMap(document_key_DocumentKey.comparator);
function documentMap() {
    return EMPTY_DOCUMENT_MAP;
}
var EMPTY_DOCUMENT_VERSION_MAP = new sorted_map_SortedMap(document_key_DocumentKey.comparator);
function documentVersionMap() {
    return EMPTY_DOCUMENT_VERSION_MAP;
}
var EMPTY_DOCUMENT_KEY_SET = new sorted_set_SortedSet(document_key_DocumentKey.comparator);
function documentKeySet() {
    return EMPTY_DOCUMENT_KEY_SET;
}

//# sourceMappingURL=collections.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/remote/remote_event.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * An event from the RemoteStore. It is split into targetChanges (changes to the
 * state or the set of documents in our watched targets) and documentUpdates
 * (changes to the actual documents).
 */
var remote_event_RemoteEvent = /** @class */function () {
    function RemoteEvent(
    /**
     * The snapshot version this event brings us up to, or MIN if not set.
     */
    snapshotVersion,
    /**
     * A map from target to changes to the target. See TargetChange.
     */
    targetChanges,
    /**
     * A set of which documents have changed or been deleted, along with the
     * doc's new values (if not deleted).
     */
    documentUpdates) {
        this.snapshotVersion = snapshotVersion;
        this.targetChanges = targetChanges;
        this.documentUpdates = documentUpdates;
    }
    RemoteEvent.prototype.addDocumentUpdate = function (doc) {
        this.documentUpdates = this.documentUpdates.insert(doc.key, doc);
    };
    RemoteEvent.prototype.handleExistenceFilterMismatch = function (targetId) {
        /*
         * An existence filter mismatch will reset the query and we need to reset
         * the mapping to contain no documents and an empty resume token.
         *
         * Note:
         *   * The reset mapping is empty, specifically forcing the consumer of the
         *     change to forget all keys for this targetID;
         *   * The resume snapshot for this target must be reset
         *   * The target must be unacked because unwatching and rewatching
         *     introduces a race for changes.
         */
        this.targetChanges[targetId] = {
            mapping: new ResetMapping(),
            snapshotVersion: snapshot_version_SnapshotVersion.MIN,
            currentStatusUpdate: CurrentStatusUpdate.MarkNotCurrent,
            resumeToken: emptyByteString()
        };
    };
    return RemoteEvent;
}();

/**
 * Represents an update to the current status of a target, either explicitly
 * having no new state, or the new value to set. Note "current" has special
 * meaning for in the RPC protocol that implies that a target is both up-to-date
 * and consistent with the rest of the watch stream.
 */
var CurrentStatusUpdate;
(function (CurrentStatusUpdate) {
    /** The current status is not affected and should not be modified. */
    CurrentStatusUpdate[CurrentStatusUpdate["None"] = 0] = "None";
    /** The target must be marked as no longer "current". */
    CurrentStatusUpdate[CurrentStatusUpdate["MarkNotCurrent"] = 1] = "MarkNotCurrent";
    /** The target must be marked as "current". */
    CurrentStatusUpdate[CurrentStatusUpdate["MarkCurrent"] = 2] = "MarkCurrent";
})(CurrentStatusUpdate || (CurrentStatusUpdate = {}));
var EMPTY_KEY_SET = documentKeySet();
var ResetMapping = /** @class */function () {
    function ResetMapping() {
        this.docs = EMPTY_KEY_SET;
    }
    Object.defineProperty(ResetMapping.prototype, "documents", {
        get: function get() {
            return this.docs;
        },
        enumerable: true,
        configurable: true
    });
    ResetMapping.prototype.add = function (key) {
        this.docs = this.docs.add(key);
    };
    ResetMapping.prototype.delete = function (key) {
        this.docs = this.docs.delete(key);
    };
    ResetMapping.prototype.equals = function (other) {
        return other !== null && this.docs.equals(other.docs);
    };
    return ResetMapping;
}();

var UpdateMapping = /** @class */function () {
    function UpdateMapping() {
        this.addedDocuments = EMPTY_KEY_SET;
        this.removedDocuments = EMPTY_KEY_SET;
    }
    UpdateMapping.prototype.applyToKeySet = function (keys) {
        var result = keys;
        this.addedDocuments.forEach(function (key) {
            return result = result.add(key);
        });
        this.removedDocuments.forEach(function (key) {
            return result = result.delete(key);
        });
        return result;
    };
    UpdateMapping.prototype.add = function (key) {
        this.addedDocuments = this.addedDocuments.add(key);
        this.removedDocuments = this.removedDocuments.delete(key);
    };
    UpdateMapping.prototype.delete = function (key) {
        this.addedDocuments = this.addedDocuments.delete(key);
        this.removedDocuments = this.removedDocuments.add(key);
    };
    UpdateMapping.prototype.equals = function (other) {
        return other !== null && this.addedDocuments.equals(other.addedDocuments) && this.removedDocuments.equals(other.removedDocuments);
    };
    return UpdateMapping;
}();


//# sourceMappingURL=remote_event.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/remote/watch_change.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Represents a changed document and a list of target ids to which this change
 * applies.
 *
 * If document has been deleted NoDocument will be provided.
 */
var DocumentWatchChange = /** @class */function () {
    function DocumentWatchChange(
    /** The new document applies to all of these targets. */
    updatedTargetIds,
    /** The new document is removed from all of these targets. */
    removedTargetIds,
    /** The key of the document for this change. */
    key,
    /**
     * The new document or NoDocument if it was deleted. Is null if the
     * document went out of view without the server sending a new document.
     */
    newDoc) {
        this.updatedTargetIds = updatedTargetIds;
        this.removedTargetIds = removedTargetIds;
        this.key = key;
        this.newDoc = newDoc;
    }
    return DocumentWatchChange;
}();

var ExistenceFilterChange = /** @class */function () {
    function ExistenceFilterChange(targetId, existenceFilter) {
        this.targetId = targetId;
        this.existenceFilter = existenceFilter;
    }
    return ExistenceFilterChange;
}();

var WatchTargetChangeState;
(function (WatchTargetChangeState) {
    WatchTargetChangeState[WatchTargetChangeState["NoChange"] = 0] = "NoChange";
    WatchTargetChangeState[WatchTargetChangeState["Added"] = 1] = "Added";
    WatchTargetChangeState[WatchTargetChangeState["Removed"] = 2] = "Removed";
    WatchTargetChangeState[WatchTargetChangeState["Current"] = 3] = "Current";
    WatchTargetChangeState[WatchTargetChangeState["Reset"] = 4] = "Reset";
})(WatchTargetChangeState || (WatchTargetChangeState = {}));
var watch_change_WatchTargetChange = /** @class */function () {
    function WatchTargetChange(
    /** What kind of change occurred to the watch target. */
    state,
    /** The target IDs that were added/removed/set. */
    targetIds,
    /**
     * An opaque, server-assigned token that allows watching a query to be
     * resumed after disconnecting without retransmitting all the data that
     * matches the query. The resume token essentially identifies a point in
     * time from which the server should resume sending results.
     */
    resumeToken,
    /** An RPC error indicating why the watch failed. */
    cause) {
        if (resumeToken === void 0) {
            resumeToken = emptyByteString();
        }
        if (cause === void 0) {
            cause = null;
        }
        this.state = state;
        this.targetIds = targetIds;
        this.resumeToken = resumeToken;
        this.cause = cause;
    }
    return WatchTargetChange;
}();

/**
 * A helper class to accumulate watch changes into a RemoteEvent and other
 * target information.
 */
var watch_change_WatchChangeAggregator = /** @class */function () {
    function WatchChangeAggregator(snapshotVersion, listenTargets, pendingTargetResponses) {
        this.snapshotVersion = snapshotVersion;
        this.listenTargets = listenTargets;
        /** The existence filter - if any - for the given target IDs. */
        this.existenceFilters = {};
        /** Keeps track of the current target mappings */
        this.targetChanges = {};
        /** Keeps track of document to update */
        this.documentUpdates = maybeDocumentMap();
        /** Whether this aggregator was frozen and can no longer be modified */
        this.frozen = false;
        this.pendingTargetResponses = shallowCopy(pendingTargetResponses);
    }
    /** Aggregates a watch change into the current state */
    WatchChangeAggregator.prototype.add = function (watchChange) {
        assert_assert(!this.frozen, 'Trying to modify frozen WatchChangeAggregator.');
        if (watchChange instanceof DocumentWatchChange) {
            this.addDocumentChange(watchChange);
        } else if (watchChange instanceof watch_change_WatchTargetChange) {
            this.addTargetChange(watchChange);
        } else if (watchChange instanceof ExistenceFilterChange) {
            this.addExistenceFilterChange(watchChange);
        } else {
            fail('Unknown watch change: ' + watchChange);
        }
    };
    /** Aggregates all provided watch changes to the current state in order */
    WatchChangeAggregator.prototype.addChanges = function (watchChanges) {
        var _this = this;
        assert_assert(!this.frozen, 'Trying to modify frozen WatchChangeAggregator.');
        watchChanges.forEach(function (change) {
            return _this.add(change);
        });
    };
    /**
     * Converts the current state into a remote event with the snapshot version
     * provided via the constructor.
     */
    WatchChangeAggregator.prototype.createRemoteEvent = function () {
        var _this = this;
        var targetChanges = this.targetChanges;
        // Remove all the non-active targets from the remote event.
        forEachNumber(this.targetChanges, function (targetId) {
            if (!_this.isActiveTarget(targetId)) {
                delete targetChanges[targetId];
            }
        });
        // Mark this aggregator as frozen so no further modifications are made
        this.frozen = true;
        return new remote_event_RemoteEvent(this.snapshotVersion, targetChanges, this.documentUpdates);
    };
    WatchChangeAggregator.prototype.ensureTargetChange = function (targetId) {
        var change = this.targetChanges[targetId];
        if (!change) {
            // Create an UpdateMapping by default, since resets are always explicit.
            change = {
                currentStatusUpdate: CurrentStatusUpdate.None,
                snapshotVersion: this.snapshotVersion,
                mapping: new UpdateMapping(),
                resumeToken: emptyByteString()
            };
            this.targetChanges[targetId] = change;
        }
        return change;
    };
    /**
     * We need to wait for watch to ack targets before we process those events,
     * so to know if a target is active, there must be no pending acks we're
     * waiting for and it must be in the current list of targets that the client
     * cares about.
     *
     * This method is visible for testing.
     */
    WatchChangeAggregator.prototype.isActiveTarget = function (targetId) {
        return !obj_contains(this.pendingTargetResponses, targetId) && obj_contains(this.listenTargets, targetId);
    };
    WatchChangeAggregator.prototype.addDocumentChange = function (docChange) {
        var relevant = false;
        for (var _i = 0, _a = docChange.updatedTargetIds; _i < _a.length; _i++) {
            var targetId = _a[_i];
            if (this.isActiveTarget(targetId)) {
                var change = this.ensureTargetChange(targetId);
                change.mapping.add(docChange.key);
                relevant = true;
            }
        }
        for (var _b = 0, _c = docChange.removedTargetIds; _b < _c.length; _b++) {
            var targetId = _c[_b];
            if (this.isActiveTarget(targetId)) {
                var change = this.ensureTargetChange(targetId);
                change.mapping.delete(docChange.key);
                relevant = true;
            }
        }
        // Only update the document if there is a new document to replace to an
        // active target that is being listened to, this might be just a target
        // update instead.
        if (docChange.newDoc && relevant) {
            this.documentUpdates = this.documentUpdates.insert(docChange.key, docChange.newDoc);
        }
    };
    WatchChangeAggregator.prototype.addTargetChange = function (targetChange) {
        var _this = this;
        targetChange.targetIds.forEach(function (targetId) {
            var change = _this.ensureTargetChange(targetId);
            switch (targetChange.state) {
                case WatchTargetChangeState.NoChange:
                    if (_this.isActiveTarget(targetId)) {
                        // Creating the change above satisfies the semantics of no-change.
                        applyResumeToken(change, targetChange.resumeToken);
                    }
                    break;
                case WatchTargetChangeState.Added:
                    // We need to decrement the number of pending acks needed from watch
                    // for this targetId.
                    _this.recordTargetResponse(targetId);
                    if (!obj_contains(_this.pendingTargetResponses, targetId)) {
                        // We have a freshly added target, so we need to reset any state
                        // that we had previously This can happen e.g. when remove and add
                        // back a target for existence filter mismatches.
                        change.mapping = new UpdateMapping();
                        change.currentStatusUpdate = CurrentStatusUpdate.None;
                        delete _this.existenceFilters[targetId];
                    }
                    applyResumeToken(change, targetChange.resumeToken);
                    break;
                case WatchTargetChangeState.Removed:
                    // We need to keep track of removed targets to we can
                    // post-filter and remove any target changes.
                    // We need to decrement the number of pending acks needed from watch
                    // for this targetId.
                    _this.recordTargetResponse(targetId);
                    assert_assert(!targetChange.cause, 'WatchChangeAggregator does not handle errored targets');
                    break;
                case WatchTargetChangeState.Current:
                    if (_this.isActiveTarget(targetId)) {
                        change.currentStatusUpdate = CurrentStatusUpdate.MarkCurrent;
                        applyResumeToken(change, targetChange.resumeToken);
                    }
                    break;
                case WatchTargetChangeState.Reset:
                    if (_this.isActiveTarget(targetId)) {
                        // Overwrite any existing target mapping with a reset
                        // mapping. Every subsequent update will modify the reset
                        // mapping, not an update mapping.
                        change.mapping = new ResetMapping();
                        applyResumeToken(change, targetChange.resumeToken);
                    }
                    break;
                default:
                    fail('Unknown target watch change state: ' + targetChange.state);
            }
        });
    };
    /**
     * Record that we get a watch target add/remove by decrementing the number of
     * pending target responses that we have.
     */
    WatchChangeAggregator.prototype.recordTargetResponse = function (targetId) {
        var newCount = (this.pendingTargetResponses[targetId] || 0) - 1;
        if (newCount === 0) {
            delete this.pendingTargetResponses[targetId];
        } else {
            this.pendingTargetResponses[targetId] = newCount;
        }
    };
    WatchChangeAggregator.prototype.addExistenceFilterChange = function (change) {
        if (this.isActiveTarget(change.targetId)) {
            this.existenceFilters[change.targetId] = change.existenceFilter;
        }
    };
    return WatchChangeAggregator;
}();

/**
 * Applies the resume token to the TargetChange, but only when it has a new
 * value. null and empty resumeTokens are discarded.
 */
function applyResumeToken(change, resumeToken) {
    if (resumeToken.length > 0) {
        change.resumeToken = resumeToken;
    }
}

//# sourceMappingURL=watch_change.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/remote/serializer.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



















var DIRECTIONS = function () {
    var dirs = {};
    dirs[Direction.ASCENDING.name] = 'ASCENDING';
    dirs[Direction.DESCENDING.name] = 'DESCENDING';
    return dirs;
}();
var OPERATORS = function () {
    var ops = {};
    ops[query_RelationOp.LESS_THAN.name] = 'LESS_THAN';
    ops[query_RelationOp.LESS_THAN_OR_EQUAL.name] = 'LESS_THAN_OR_EQUAL';
    ops[query_RelationOp.GREATER_THAN.name] = 'GREATER_THAN';
    ops[query_RelationOp.GREATER_THAN_OR_EQUAL.name] = 'GREATER_THAN_OR_EQUAL';
    ops[query_RelationOp.EQUAL.name] = 'EQUAL';
    return ops;
}();
function assertPresent(value, description) {
    assert_assert(!isNullOrUndefined(value), description + ' is missing');
}
function parseInt64(value) {
    // TODO(bjornick): Handle int64 greater than 53 bits.
    if (typeof value === 'number') {
        return value;
    } else if (typeof value === 'string') {
        return parseInt(value, 10);
    } else {
        return fail("can't parse " + value);
    }
}
/**
 * Generates JsonObject values for the Datastore API suitable for sending to
 * either GRPC stub methods or via the JSON/HTTP REST API.
 * TODO(klimt): We can remove the databaseId argument if we keep the full
 * resource name in documents.
 */
var serializer_JsonProtoSerializer = /** @class */function () {
    function JsonProtoSerializer(databaseId, options) {
        this.databaseId = databaseId;
        this.options = options;
    }
    JsonProtoSerializer.prototype.emptyByteString = function () {
        if (this.options.useProto3Json) {
            return '';
        } else {
            return new Uint8Array(0);
        }
    };
    JsonProtoSerializer.prototype.unsafeCastProtoByteString = function (byteString) {
        // byteStrings can be either string or UInt8Array, but the typings say
        // it's always a string. Cast as string to avoid type check failing
        return byteString;
    };
    JsonProtoSerializer.prototype.fromRpcStatus = function (status) {
        var code = status.code === undefined ? Code.UNKNOWN : mapCodeFromRpcCode(status.code);
        return new FirestoreError(code, status.message || '');
    };
    /**
     * Returns a value for a number (or undefined) that's appropriate to put into
     * a google.protobuf.Int32Value proto.
     * DO NOT USE THIS FOR ANYTHING ELSE.
     * This method cheats. It's typed as returning "number" because that's what
     * our generated proto interfaces say Int32Value must be. But GRPC actually
     * expects a { value: <number> } struct.
     */
    JsonProtoSerializer.prototype.toInt32Value = function (val) {
        if (!isNullOrUndefined(val)) {
            return { value: val };
        } else {
            return undefined;
        }
    };
    /**
     * Returns a number (or null) from a google.protobuf.Int32Value proto.
     * DO NOT USE THIS FOR ANYTHING ELSE.
     * This method cheats. It's typed as accepting "number" because that's what
     * our generated proto interfaces say Int32Value must be, but it actually
     * accepts { value: number } to match our serialization in toInt32Value().
     */
    JsonProtoSerializer.prototype.fromInt32Value = function (val) {
        var result;
        if (typeof val === 'object') {
            result = val.value;
        } else {
            // We accept raw numbers (without the {value: ... } wrapper) for
            // compatibility with legacy persisted data.
            result = val;
        }
        return isNullOrUndefined(result) ? null : result;
    };
    /**
     * Returns a value for a Date that's appropriate to put into a proto.
     * DO NOT USE THIS FOR ANYTHING ELSE.
     * This method cheats. It's typed as returning "string" because that's what
     * our generated proto interfaces say dates must be. But it's easier and safer
     * to actually return a Timestamp proto.
     */
    JsonProtoSerializer.prototype.toTimestamp = function (timestamp) {
        return {
            seconds: timestamp.seconds,
            nanos: timestamp.nanos
            // tslint:disable-next-line:no-any
        };
    };
    JsonProtoSerializer.prototype.fromTimestamp = function (date) {
        // The json interface (for the browser) will return an iso timestamp string,
        // while the proto js library (for node) will return a
        // google.protobuf.Timestamp instance.
        if (typeof date === 'string') {
            // TODO(b/37282237): Use strings for Proto3 timestamps
            // assert(this.options.useProto3Json,
            //   'The timestamp string format requires Proto3.');
            return timestamp_Timestamp.fromISOString(date);
        } else {
            assert_assert(!!date, 'Cannot deserialize null or undefined timestamp.');
            // TODO(b/37282237): Use strings for Proto3 timestamps
            // assert(!this.options.useProto3Json,
            //   'The timestamp instance format requires Proto JS.');
            var seconds = parseInt64(date.seconds || '0');
            var nanos = date.nanos || 0;
            return new timestamp_Timestamp(seconds, nanos);
        }
    };
    /**
     * Returns a value for bytes that's appropriate to put in a proto.
     * DO NOT USE THIS FOR ANYTHING ELSE.
     * This method cheats. It's typed as returning "string" because that's what
     * our generated proto interfaces say bytes must be. But it should return
     * an Uint8Array in Node.
     */
    JsonProtoSerializer.prototype.toBytes = function (bytes) {
        if (this.options.useProto3Json) {
            return bytes.toBase64();
        } else {
            // The typings say it's a string, but it needs to be a Uint8Array in Node.
            return this.unsafeCastProtoByteString(bytes.toUint8Array());
        }
    };
    /**
     * Parse the blob from the protos into the internal Blob class. Note that the
     * typings assume all blobs are strings, but they are actually Uint8Arrays
     * on Node.
     */
    JsonProtoSerializer.prototype.fromBlob = function (blob) {
        if (typeof blob === 'string') {
            assert_assert(this.options.useProto3Json, 'Expected bytes to be passed in as Uint8Array, but got a string instead.');
            return blob_Blob.fromBase64String(blob);
        } else {
            assert_assert(!this.options.useProto3Json, 'Expected bytes to be passed in as string, but got something else instead.');
            return blob_Blob.fromUint8Array(blob);
        }
    };
    JsonProtoSerializer.prototype.toVersion = function (version) {
        return this.toTimestamp(version.toTimestamp());
    };
    JsonProtoSerializer.prototype.fromVersion = function (version) {
        assert_assert(!!version, "Trying to deserialize version that isn't set");
        return snapshot_version_SnapshotVersion.fromTimestamp(this.fromTimestamp(version));
    };
    JsonProtoSerializer.prototype.toResourceName = function (databaseId, path) {
        return this.fullyQualifiedPrefixPath(databaseId).child('documents').child(path).canonicalString();
    };
    JsonProtoSerializer.prototype.fromResourceName = function (name) {
        var resource = path_ResourcePath.fromString(name);
        assert_assert(this.isValidResourceName(resource), 'Tried to deserialize invalid key ' + resource.toString());
        return resource;
    };
    JsonProtoSerializer.prototype.toName = function (key) {
        return this.toResourceName(this.databaseId, key.path);
    };
    JsonProtoSerializer.prototype.fromName = function (name) {
        var resource = this.fromResourceName(name);
        assert_assert(resource.get(1) === this.databaseId.projectId, 'Tried to deserialize key from different project: ' + resource.get(1) + ' vs ' + this.databaseId.projectId);
        assert_assert(!resource.get(3) && !this.databaseId.database || resource.get(3) === this.databaseId.database, 'Tried to deserialize key from different database: ' + resource.get(3) + ' vs ' + this.databaseId.database);
        return new document_key_DocumentKey(this.extractLocalPathFromResourceName(resource));
    };
    JsonProtoSerializer.prototype.toQueryPath = function (path) {
        if (path.length === 0) {
            // If the path is empty, the backend requires we leave off the /documents
            // at the end.
            return this.encodedDatabaseId;
        }
        return this.toResourceName(this.databaseId, path);
    };
    JsonProtoSerializer.prototype.fromQueryPath = function (name) {
        var resourceName = this.fromResourceName(name);
        if (resourceName.length === 4) {
            return path_ResourcePath.EMPTY_PATH;
        }
        return this.extractLocalPathFromResourceName(resourceName);
    };
    Object.defineProperty(JsonProtoSerializer.prototype, "encodedDatabaseId", {
        get: function get() {
            var path = new path_ResourcePath(['projects', this.databaseId.projectId, 'databases', this.databaseId.database]);
            return path.canonicalString();
        },
        enumerable: true,
        configurable: true
    });
    JsonProtoSerializer.prototype.fullyQualifiedPrefixPath = function (databaseId) {
        return new path_ResourcePath(['projects', databaseId.projectId, 'databases', databaseId.database]);
    };
    JsonProtoSerializer.prototype.extractLocalPathFromResourceName = function (resourceName) {
        assert_assert(resourceName.length > 4 && resourceName.get(4) === 'documents', 'tried to deserialize invalid key ' + resourceName.toString());
        return resourceName.popFirst(5);
    };
    JsonProtoSerializer.prototype.isValidResourceName = function (path) {
        // Resource names have at least 4 components (project ID, database ID)
        return path.length >= 4 && path.get(0) === 'projects' && path.get(2) === 'databases';
    };
    JsonProtoSerializer.prototype.toValue = function (val) {
        if (val instanceof NullValue) {
            return { nullValue: 'NULL_VALUE' };
        } else if (val instanceof field_value_BooleanValue) {
            return { booleanValue: val.value() };
        } else if (val instanceof IntegerValue) {
            return { integerValue: '' + val.value() };
        } else if (val instanceof DoubleValue) {
            var doubleValue = val.value();
            if (this.options.useProto3Json) {
                // Proto 3 let's us encode NaN and Infinity as string values as
                // expected by the backend. This is currently not checked by our unit
                // tests because they rely on protobuf.js.
                if (isNaN(doubleValue)) {
                    return { doubleValue: 'NaN' };
                } else if (doubleValue === Infinity) {
                    return { doubleValue: 'Infinity' };
                } else if (doubleValue === -Infinity) {
                    return { doubleValue: '-Infinity' };
                }
            }
            return { doubleValue: val.value() };
        } else if (val instanceof field_value_StringValue) {
            return { stringValue: val.value() };
        } else if (val instanceof field_value_ObjectValue) {
            return { mapValue: this.toMapValue(val) };
        } else if (val instanceof field_value_ArrayValue) {
            return { arrayValue: this.toArrayValue(val) };
        } else if (val instanceof TimestampValue) {
            return {
                timestampValue: this.toTimestamp(val.internalValue)
            };
        } else if (val instanceof GeoPointValue) {
            return {
                geoPointValue: {
                    latitude: val.value().latitude,
                    longitude: val.value().longitude
                }
            };
        } else if (val instanceof BlobValue) {
            return {
                bytesValue: this.toBytes(val.value())
            };
        } else if (val instanceof field_value_RefValue) {
            return {
                referenceValue: this.toResourceName(val.databaseId, val.key.path)
            };
        } else {
            return fail('Unknown FieldValue ' + JSON.stringify(val));
        }
    };
    JsonProtoSerializer.prototype.fromValue = function (obj) {
        var _this = this;
        // tslint:disable-next-line:no-any
        var type = obj['value_type'];
        if (hasTag(obj, type, 'nullValue')) {
            return NullValue.INSTANCE;
        } else if (hasTag(obj, type, 'booleanValue')) {
            return field_value_BooleanValue.of(obj.booleanValue);
        } else if (hasTag(obj, type, 'integerValue')) {
            return new IntegerValue(parseInt64(obj.integerValue));
        } else if (hasTag(obj, type, 'doubleValue')) {
            if (this.options.useProto3Json) {
                // Proto 3 uses the string values 'NaN' and 'Infinity'.
                if (obj.doubleValue === 'NaN') {
                    return DoubleValue.NAN;
                } else if (obj.doubleValue === 'Infinity') {
                    return DoubleValue.POSITIVE_INFINITY;
                } else if (obj.doubleValue === '-Infinity') {
                    return DoubleValue.NEGATIVE_INFINITY;
                }
            }
            return new DoubleValue(obj.doubleValue);
        } else if (hasTag(obj, type, 'stringValue')) {
            return new field_value_StringValue(obj.stringValue);
        } else if (hasTag(obj, type, 'mapValue')) {
            return this.fromFields(obj.mapValue.fields || {});
        } else if (hasTag(obj, type, 'arrayValue')) {
            // "values" is not present if the array is empty
            assertPresent(obj.arrayValue, 'arrayValue');
            var values = obj.arrayValue.values || [];
            return new field_value_ArrayValue(values.map(function (v) {
                return _this.fromValue(v);
            }));
        } else if (hasTag(obj, type, 'timestampValue')) {
            assertPresent(obj.timestampValue, 'timestampValue');
            return new TimestampValue(this.fromTimestamp(obj.timestampValue));
        } else if (hasTag(obj, type, 'geoPointValue')) {
            assertPresent(obj.geoPointValue, 'geoPointValue');
            var latitude = obj.geoPointValue.latitude || 0;
            var longitude = obj.geoPointValue.longitude || 0;
            return new GeoPointValue(new geo_point_GeoPoint(latitude, longitude));
        } else if (hasTag(obj, type, 'bytesValue')) {
            assertPresent(obj.bytesValue, 'bytesValue');
            var blob = this.fromBlob(obj.bytesValue);
            return new BlobValue(blob);
        } else if (hasTag(obj, type, 'referenceValue')) {
            assertPresent(obj.referenceValue, 'referenceValue');
            var resourceName = this.fromResourceName(obj.referenceValue);
            var dbId = new database_info_DatabaseId(resourceName.get(1), resourceName.get(3));
            var key = new document_key_DocumentKey(this.extractLocalPathFromResourceName(resourceName));
            return new field_value_RefValue(dbId, key);
        } else {
            return fail('Unknown Value proto ' + JSON.stringify(obj));
        }
    };
    /** Creates an api.Document from key and fields (but no create/update time) */
    JsonProtoSerializer.prototype.toMutationDocument = function (key, fields) {
        return {
            name: this.toName(key),
            fields: this.toFields(fields)
        };
    };
    JsonProtoSerializer.prototype.toDocument = function (document) {
        assert_assert(!document.hasLocalMutations, "Can't serialize documents with mutations.");
        return {
            name: this.toName(document.key),
            fields: this.toFields(document.data),
            updateTime: this.toTimestamp(document.version.toTimestamp())
        };
    };
    JsonProtoSerializer.prototype.fromDocument = function (document) {
        return new document_Document(this.fromName(document.name), this.fromVersion(document.updateTime), this.fromFields(document.fields || {}), { hasLocalMutations: false });
    };
    JsonProtoSerializer.prototype.toFields = function (fields) {
        var _this = this;
        var result = {};
        fields.forEach(function (key, value) {
            result[key] = _this.toValue(value);
        });
        return result;
    };
    JsonProtoSerializer.prototype.fromFields = function (object) {
        var _this = this;
        // Proto map<string, Value> gets mapped to Object, so cast it.
        var map = object;
        var result = field_value_ObjectValue.EMPTY;
        obj_forEach(map, function (key, value) {
            result = result.set(new path_FieldPath([key]), _this.fromValue(value));
        });
        return result;
    };
    JsonProtoSerializer.prototype.toMapValue = function (map) {
        return {
            fields: this.toFields(map)
        };
    };
    JsonProtoSerializer.prototype.toArrayValue = function (array) {
        var _this = this;
        var result = [];
        array.forEach(function (value) {
            result.push(_this.toValue(value));
        });
        return { values: result };
    };
    JsonProtoSerializer.prototype.fromFound = function (doc) {
        assert_assert(!!doc.found, 'Tried to deserialize a found document from a missing document.');
        assertPresent(doc.found.name, 'doc.found.name');
        assertPresent(doc.found.updateTime, 'doc.found.updateTime');
        var key = this.fromName(doc.found.name);
        var version = this.fromVersion(doc.found.updateTime);
        var fields = this.fromFields(doc.found.fields || {});
        return new document_Document(key, version, fields, { hasLocalMutations: false });
    };
    JsonProtoSerializer.prototype.fromMissing = function (result) {
        assert_assert(!!result.missing, 'Tried to deserialize a missing document from a found document.');
        assert_assert(!!result.readTime, 'Tried to deserialize a missing document without a read time.');
        var key = this.fromName(result.missing);
        var version = this.fromVersion(result.readTime);
        return new document_NoDocument(key, version);
    };
    JsonProtoSerializer.prototype.fromMaybeDocument = function (result) {
        // tslint:disable-next-line:no-any
        var type = result['result'];
        if (hasTag(result, type, 'found')) {
            return this.fromFound(result);
        } else if (hasTag(result, type, 'missing')) {
            return this.fromMissing(result);
        }
        return fail('invalid batch get response: ' + JSON.stringify(result));
    };
    JsonProtoSerializer.prototype.toWatchTargetChangeState = function (state) {
        switch (state) {
            case WatchTargetChangeState.Added:
                return 'ADD';
            case WatchTargetChangeState.Current:
                return 'CURRENT';
            case WatchTargetChangeState.NoChange:
                return 'NO_CHANGE';
            case WatchTargetChangeState.Removed:
                return 'REMOVE';
            case WatchTargetChangeState.Reset:
                return 'RESET';
            default:
                return fail('Unknown WatchTargetChangeState: ' + state);
        }
    };
    JsonProtoSerializer.prototype.toTestWatchChange = function (watchChange) {
        if (watchChange instanceof ExistenceFilterChange) {
            return {
                filter: {
                    count: watchChange.existenceFilter.count,
                    targetId: watchChange.targetId
                }
            };
        }
        if (watchChange instanceof DocumentWatchChange) {
            if (watchChange.newDoc instanceof document_Document) {
                var doc = watchChange.newDoc;
                return {
                    documentChange: {
                        document: {
                            name: this.toName(doc.key),
                            fields: this.toFields(doc.data),
                            updateTime: this.toVersion(doc.version)
                        },
                        targetIds: watchChange.updatedTargetIds,
                        removedTargetIds: watchChange.removedTargetIds
                    }
                };
            } else if (watchChange.newDoc instanceof document_NoDocument) {
                var doc = watchChange.newDoc;
                return {
                    documentDelete: {
                        document: this.toName(doc.key),
                        readTime: this.toVersion(doc.version),
                        removedTargetIds: watchChange.removedTargetIds
                    }
                };
            } else if (watchChange.newDoc === null) {
                return {
                    documentRemove: {
                        document: this.toName(watchChange.key),
                        removedTargetIds: watchChange.removedTargetIds
                    }
                };
            }
        }
        if (watchChange instanceof watch_change_WatchTargetChange) {
            var cause = undefined;
            if (watchChange.cause) {
                cause = {
                    code: mapRpcCodeFromCode(watchChange.cause.code),
                    message: watchChange.cause.message
                };
            }
            return {
                targetChange: {
                    targetChangeType: this.toWatchTargetChangeState(watchChange.state),
                    targetIds: watchChange.targetIds,
                    resumeToken: this.unsafeCastProtoByteString(watchChange.resumeToken),
                    cause: cause
                }
            };
        }
        return fail('Unrecognized watch change: ' + JSON.stringify(watchChange));
    };
    JsonProtoSerializer.prototype.fromWatchChange = function (change) {
        // tslint:disable-next-line:no-any
        var type = change['response_type'];
        var watchChange;
        if (hasTag(change, type, 'targetChange')) {
            assertPresent(change.targetChange, 'targetChange');
            // proto3 default value is unset in JSON (undefined), so use 'NO_CHANGE'
            // if unset
            var state = this.fromWatchTargetChangeState(change.targetChange.targetChangeType || 'NO_CHANGE');
            var targetIds = change.targetChange.targetIds || [];
            var resumeToken = change.targetChange.resumeToken || this.emptyByteString();
            var causeProto = change.targetChange.cause;
            var cause = causeProto && this.fromRpcStatus(causeProto);
            watchChange = new watch_change_WatchTargetChange(state, targetIds, resumeToken, cause || null);
        } else if (hasTag(change, type, 'documentChange')) {
            assertPresent(change.documentChange, 'documentChange');
            assertPresent(change.documentChange.document, 'documentChange.name');
            assertPresent(change.documentChange.document.name, 'documentChange.document.name');
            assertPresent(change.documentChange.document.updateTime, 'documentChange.document.updateTime');
            var entityChange = change.documentChange;
            var key = this.fromName(entityChange.document.name);
            var version = this.fromVersion(entityChange.document.updateTime);
            var fields = this.fromFields(entityChange.document.fields || {});
            var doc = new document_Document(key, version, fields, {
                hasLocalMutations: false
            });
            var updatedTargetIds = entityChange.targetIds || [];
            var removedTargetIds = entityChange.removedTargetIds || [];
            watchChange = new DocumentWatchChange(updatedTargetIds, removedTargetIds, doc.key, doc);
        } else if (hasTag(change, type, 'documentDelete')) {
            assertPresent(change.documentDelete, 'documentDelete');
            assertPresent(change.documentDelete.document, 'documentDelete.document');
            var docDelete = change.documentDelete;
            var key = this.fromName(docDelete.document);
            var version = docDelete.readTime ? this.fromVersion(docDelete.readTime) : snapshot_version_SnapshotVersion.forDeletedDoc();
            var doc = new document_NoDocument(key, version);
            var removedTargetIds = docDelete.removedTargetIds || [];
            watchChange = new DocumentWatchChange([], removedTargetIds, doc.key, doc);
        } else if (hasTag(change, type, 'documentRemove')) {
            assertPresent(change.documentRemove, 'documentRemove');
            assertPresent(change.documentRemove.document, 'documentRemove');
            var docRemove = change.documentRemove;
            var key = this.fromName(docRemove.document);
            var removedTargetIds = docRemove.removedTargetIds || [];
            watchChange = new DocumentWatchChange([], removedTargetIds, key, null);
        } else if (hasTag(change, type, 'filter')) {
            // TODO(dimond): implement existence filter parsing with strategy.
            assertPresent(change.filter, 'filter');
            assertPresent(change.filter.targetId, 'filter.targetId');
            var filter = change.filter;
            var count = filter.count || 0;
            var existenceFilter = new ExistenceFilter(count);
            var targetId = filter.targetId;
            watchChange = new ExistenceFilterChange(targetId, existenceFilter);
        } else {
            return fail('Unknown change type ' + JSON.stringify(change));
        }
        return watchChange;
    };
    JsonProtoSerializer.prototype.fromWatchTargetChangeState = function (state) {
        if (state === 'NO_CHANGE') {
            return WatchTargetChangeState.NoChange;
        } else if (state === 'ADD') {
            return WatchTargetChangeState.Added;
        } else if (state === 'REMOVE') {
            return WatchTargetChangeState.Removed;
        } else if (state === 'CURRENT') {
            return WatchTargetChangeState.Current;
        } else if (state === 'RESET') {
            return WatchTargetChangeState.Reset;
        } else {
            return fail('Got unexpected TargetChange.state: ' + state);
        }
    };
    JsonProtoSerializer.prototype.versionFromListenResponse = function (change) {
        // We have only reached a consistent snapshot for the entire stream if there
        // is a read_time set and it applies to all targets (i.e. the list of
        // targets is empty). The backend is guaranteed to send such responses.
        // tslint:disable-next-line:no-any
        var type = change['response_type'];
        if (!hasTag(change, type, 'targetChange')) {
            return snapshot_version_SnapshotVersion.MIN;
        }
        var targetChange = change.targetChange;
        if (targetChange.targetIds && targetChange.targetIds.length) {
            return snapshot_version_SnapshotVersion.MIN;
        }
        if (!targetChange.readTime) {
            return snapshot_version_SnapshotVersion.MIN;
        }
        return this.fromVersion(targetChange.readTime);
    };
    JsonProtoSerializer.prototype.toMutation = function (mutation) {
        var _this = this;
        var result;
        if (mutation instanceof mutation_SetMutation) {
            result = {
                update: this.toMutationDocument(mutation.key, mutation.value)
            };
        } else if (mutation instanceof mutation_DeleteMutation) {
            result = { delete: this.toName(mutation.key) };
        } else if (mutation instanceof mutation_PatchMutation) {
            result = {
                update: this.toMutationDocument(mutation.key, mutation.data),
                updateMask: this.toDocumentMask(mutation.fieldMask)
            };
        } else if (mutation instanceof mutation_TransformMutation) {
            result = {
                transform: {
                    document: this.toName(mutation.key),
                    fieldTransforms: mutation.fieldTransforms.map(function (transform) {
                        return _this.toFieldTransform(transform);
                    })
                }
            };
        } else {
            return fail('Unknown mutation type ' + mutation.type);
        }
        if (!mutation.precondition.isNone) {
            result.currentDocument = this.toPrecondition(mutation.precondition);
        }
        return result;
    };
    JsonProtoSerializer.prototype.fromMutation = function (proto) {
        var _this = this;
        var precondition = proto.currentDocument ? this.fromPrecondition(proto.currentDocument) : mutation_Precondition.NONE;
        if (proto.update) {
            assertPresent(proto.update.name, 'name');
            var key = this.fromName(proto.update.name);
            var value = this.fromFields(proto.update.fields || {});
            if (proto.updateMask) {
                var fieldMask = this.fromDocumentMask(proto.updateMask);
                return new mutation_PatchMutation(key, value, fieldMask, precondition);
            } else {
                return new mutation_SetMutation(key, value, precondition);
            }
        } else if (proto.delete) {
            var key = this.fromName(proto.delete);
            return new mutation_DeleteMutation(key, precondition);
        } else if (proto.transform) {
            var key = this.fromName(proto.transform.document);
            var fieldTransforms = proto.transform.fieldTransforms.map(function (transform) {
                return _this.fromFieldTransform(transform);
            });
            assert_assert(precondition.exists === true, 'Transforms only support precondition "exists == true"');
            return new mutation_TransformMutation(key, fieldTransforms);
        } else {
            return fail('unknown mutation proto: ' + JSON.stringify(proto));
        }
    };
    JsonProtoSerializer.prototype.toPrecondition = function (precondition) {
        assert_assert(!precondition.isNone, "Can't serialize an empty precondition");
        if (precondition.updateTime !== undefined) {
            return {
                updateTime: this.toVersion(precondition.updateTime)
            };
        } else if (precondition.exists !== undefined) {
            return { exists: precondition.exists };
        } else {
            return fail('Unknown precondition');
        }
    };
    JsonProtoSerializer.prototype.fromPrecondition = function (precondition) {
        if (precondition.updateTime !== undefined) {
            return mutation_Precondition.updateTime(this.fromVersion(precondition.updateTime));
        } else if (precondition.exists !== undefined) {
            return mutation_Precondition.exists(precondition.exists);
        } else {
            return mutation_Precondition.NONE;
        }
    };
    JsonProtoSerializer.prototype.fromWriteResult = function (proto) {
        var _this = this;
        // NOTE: Deletes don't have an updateTime.
        var version = proto.updateTime ? this.fromVersion(proto.updateTime) : null;
        var transformResults = null;
        if (proto.transformResults && proto.transformResults.length > 0) {
            transformResults = proto.transformResults.map(function (result) {
                return _this.fromValue(result);
            });
        }
        return new MutationResult(version, transformResults);
    };
    JsonProtoSerializer.prototype.fromWriteResults = function (protos) {
        var _this = this;
        return (protos || []).map(function (proto) {
            return _this.fromWriteResult(proto);
        });
    };
    JsonProtoSerializer.prototype.toFieldTransform = function (fieldTransform) {
        assert_assert(fieldTransform.transform instanceof ServerTimestampTransform, 'Unknown transform: ' + fieldTransform.transform);
        return {
            fieldPath: fieldTransform.field.canonicalString(),
            setToServerValue: 'REQUEST_TIME'
        };
    };
    JsonProtoSerializer.prototype.fromFieldTransform = function (proto) {
        assert_assert(proto.setToServerValue === 'REQUEST_TIME', 'Unknown transform proto: ' + JSON.stringify(proto));
        var fieldPath = path_FieldPath.fromServerFormat(proto.fieldPath);
        return new FieldTransform(fieldPath, ServerTimestampTransform.instance);
    };
    JsonProtoSerializer.prototype.toDocumentsTarget = function (query) {
        return { documents: [this.toQueryPath(query.path)] };
    };
    JsonProtoSerializer.prototype.fromDocumentsTarget = function (documentsTarget) {
        var count = documentsTarget.documents.length;
        assert_assert(count === 1, 'DocumentsTarget contained other than 1 document: ' + count);
        var name = documentsTarget.documents[0];
        return query_Query.atPath(this.fromQueryPath(name));
    };
    JsonProtoSerializer.prototype.toQueryTarget = function (query) {
        // Dissect the path into parent, collectionId, and optional key filter.
        var result = { structuredQuery: {} };
        if (query.path.isEmpty()) {
            result.parent = this.toQueryPath(path_ResourcePath.EMPTY_PATH);
        } else {
            var path = query.path;
            assert_assert(path.length % 2 !== 0, 'Document queries with filters are not supported.');
            result.parent = this.toQueryPath(path.popLast());
            result.structuredQuery.from = [{ collectionId: path.lastSegment() }];
        }
        var where = this.toFilter(query.filters);
        if (where) {
            result.structuredQuery.where = where;
        }
        var orderBy = this.toOrder(query.orderBy);
        if (orderBy) {
            result.structuredQuery.orderBy = orderBy;
        }
        var limit = this.toInt32Value(query.limit);
        if (limit !== undefined) {
            result.structuredQuery.limit = limit;
        }
        if (query.startAt) {
            result.structuredQuery.startAt = this.toCursor(query.startAt);
        }
        if (query.endAt) {
            result.structuredQuery.endAt = this.toCursor(query.endAt);
        }
        return result;
    };
    JsonProtoSerializer.prototype.fromQueryTarget = function (target) {
        var path = this.fromQueryPath(target.parent);
        var query = target.structuredQuery;
        var fromCount = query.from ? query.from.length : 0;
        if (fromCount > 0) {
            assert_assert(fromCount === 1, 'StructuredQuery.from with more than one collection is not supported.');
            var from = query.from[0];
            path = path.child(from.collectionId);
        }
        var filterBy = [];
        if (query.where) {
            filterBy = this.fromFilter(query.where);
        }
        var orderBy = [];
        if (query.orderBy) {
            orderBy = this.fromOrder(query.orderBy);
        }
        var limit = null;
        if (query.limit) {
            limit = this.fromInt32Value(query.limit);
        }
        var startAt = null;
        if (query.startAt) {
            startAt = this.fromCursor(query.startAt);
        }
        var endAt = null;
        if (query.endAt) {
            endAt = this.fromCursor(query.endAt);
        }
        return new query_Query(path, orderBy, filterBy, limit, startAt, endAt);
    };
    JsonProtoSerializer.prototype.toListenRequestLabels = function (queryData) {
        var value = this.toLabel(queryData.purpose);
        if (value == null) {
            return null;
        } else {
            return {
                'goog-listen-tags': value
            };
        }
    };
    JsonProtoSerializer.prototype.toLabel = function (purpose) {
        switch (purpose) {
            case QueryPurpose.Listen:
                return null;
            case QueryPurpose.ExistenceFilterMismatch:
                return 'existence-filter-mismatch';
            case QueryPurpose.LimboResolution:
                return 'limbo-document';
            default:
                return fail('Unrecognized query purpose: ' + purpose);
        }
    };
    JsonProtoSerializer.prototype.toTarget = function (queryData) {
        var result;
        var query = queryData.query;
        if (query.isDocumentQuery()) {
            result = { documents: this.toDocumentsTarget(query) };
        } else {
            result = { query: this.toQueryTarget(query) };
        }
        result.targetId = queryData.targetId;
        if (queryData.resumeToken.length > 0) {
            result.resumeToken = this.unsafeCastProtoByteString(queryData.resumeToken);
        }
        return result;
    };
    JsonProtoSerializer.prototype.toFilter = function (filters) {
        var _this = this;
        if (filters.length === 0) return;
        var protos = filters.map(function (filter) {
            return filter instanceof query_RelationFilter ? _this.toRelationFilter(filter) : _this.toUnaryFilter(filter);
        });
        if (protos.length === 1) {
            return protos[0];
        }
        return { compositeFilter: { op: 'AND', filters: protos } };
    };
    JsonProtoSerializer.prototype.fromFilter = function (filter) {
        var _this = this;
        if (!filter) {
            return [];
        } else if (filter.unaryFilter !== undefined) {
            return [this.fromUnaryFilter(filter)];
        } else if (filter.fieldFilter !== undefined) {
            return [this.fromRelationFilter(filter)];
        } else if (filter.compositeFilter !== undefined) {
            return filter.compositeFilter.filters.map(function (f) {
                return _this.fromFilter(f);
            }).reduce(function (accum, current) {
                return accum.concat(current);
            });
        } else {
            return fail('Unknown filter: ' + JSON.stringify(filter));
        }
    };
    JsonProtoSerializer.prototype.toOrder = function (orderBys) {
        var _this = this;
        if (orderBys.length === 0) return;
        return orderBys.map(function (order) {
            return _this.toPropertyOrder(order);
        });
    };
    JsonProtoSerializer.prototype.fromOrder = function (orderBys) {
        var _this = this;
        return orderBys.map(function (order) {
            return _this.fromPropertyOrder(order);
        });
    };
    JsonProtoSerializer.prototype.toCursor = function (cursor) {
        var _this = this;
        return {
            before: cursor.before,
            values: cursor.position.map(function (component) {
                return _this.toValue(component);
            })
        };
    };
    JsonProtoSerializer.prototype.fromCursor = function (cursor) {
        var _this = this;
        var before = !!cursor.before;
        var position = cursor.values.map(function (component) {
            return _this.fromValue(component);
        });
        return new query_Bound(position, before);
    };
    // visible for testing
    JsonProtoSerializer.prototype.toDirection = function (dir) {
        return DIRECTIONS[dir.name];
    };
    // visible for testing
    JsonProtoSerializer.prototype.fromDirection = function (dir) {
        switch (dir) {
            case 'ASCENDING':
                return Direction.ASCENDING;
            case 'DESCENDING':
                return Direction.DESCENDING;
            default:
                return undefined;
        }
    };
    // visible for testing
    JsonProtoSerializer.prototype.toOperatorName = function (op) {
        return OPERATORS[op.name];
    };
    JsonProtoSerializer.prototype.fromOperatorName = function (op) {
        switch (op) {
            case 'EQUAL':
                return query_RelationOp.EQUAL;
            case 'GREATER_THAN':
                return query_RelationOp.GREATER_THAN;
            case 'GREATER_THAN_OR_EQUAL':
                return query_RelationOp.GREATER_THAN_OR_EQUAL;
            case 'LESS_THAN':
                return query_RelationOp.LESS_THAN;
            case 'LESS_THAN_OR_EQUAL':
                return query_RelationOp.LESS_THAN_OR_EQUAL;
            case 'OPERATOR_UNSPECIFIED':
                return fail('Unspecified relation');
            default:
                return fail('Unknown relation');
        }
    };
    JsonProtoSerializer.prototype.toFieldPathReference = function (path) {
        return { fieldPath: path.canonicalString() };
    };
    JsonProtoSerializer.prototype.fromFieldPathReference = function (fieldReference) {
        return path_FieldPath.fromServerFormat(fieldReference.fieldPath);
    };
    // visible for testing
    JsonProtoSerializer.prototype.toPropertyOrder = function (orderBy) {
        return {
            field: this.toFieldPathReference(orderBy.field),
            direction: this.toDirection(orderBy.dir)
        };
    };
    JsonProtoSerializer.prototype.fromPropertyOrder = function (orderBy) {
        return new query_OrderBy(this.fromFieldPathReference(orderBy.field), this.fromDirection(orderBy.direction));
    };
    // visible for testing
    JsonProtoSerializer.prototype.toRelationFilter = function (filter) {
        if (filter instanceof query_RelationFilter) {
            return {
                fieldFilter: {
                    field: this.toFieldPathReference(filter.field),
                    op: this.toOperatorName(filter.op),
                    value: this.toValue(filter.value)
                }
            };
        } else {
            return fail('Unrecognized filter: ' + JSON.stringify(filter));
        }
    };
    JsonProtoSerializer.prototype.fromRelationFilter = function (filter) {
        return new query_RelationFilter(this.fromFieldPathReference(filter.fieldFilter.field), this.fromOperatorName(filter.fieldFilter.op), this.fromValue(filter.fieldFilter.value));
    };
    // visible for testing
    JsonProtoSerializer.prototype.toUnaryFilter = function (filter) {
        if (filter instanceof NanFilter) {
            return {
                unaryFilter: {
                    field: this.toFieldPathReference(filter.field),
                    op: 'IS_NAN'
                }
            };
        } else if (filter instanceof NullFilter) {
            return {
                unaryFilter: {
                    field: this.toFieldPathReference(filter.field),
                    op: 'IS_NULL'
                }
            };
        } else {
            return fail('Unrecognized filter: ' + JSON.stringify(filter));
        }
    };
    JsonProtoSerializer.prototype.fromUnaryFilter = function (filter) {
        switch (filter.unaryFilter.op) {
            case 'IS_NAN':
                var nanField = this.fromFieldPathReference(filter.unaryFilter.field);
                return new NanFilter(nanField);
            case 'IS_NULL':
                var nullField = this.fromFieldPathReference(filter.unaryFilter.field);
                return new NullFilter(nullField);
            case 'OPERATOR_UNSPECIFIED':
                return fail('Unspecified filter');
            default:
                return fail('Unknown filter');
        }
    };
    JsonProtoSerializer.prototype.toDocumentMask = function (fieldMask) {
        return {
            fieldPaths: fieldMask.fields.map(function (field) {
                return field.canonicalString();
            })
        };
    };
    JsonProtoSerializer.prototype.fromDocumentMask = function (proto) {
        var paths = proto.fieldPaths || [];
        var fields = paths.map(function (path) {
            return path_FieldPath.fromServerFormat(path);
        });
        return new mutation_FieldMask(fields);
    };
    return JsonProtoSerializer;
}();

/**
 * Checks for a specific oneof tag in a protocol buffer message.
 *
 * This intentionally accommodates two distinct cases:
 *
 * 1) Messages containing a type tag: these are the format produced by GRPC in
 * return values. These may contain default-value mappings for all tags in the
 * oneof but the type tag specifies which one was actually set.
 *
 * 2) Messages that don't contain a type tag: these are the format required by
 * GRPC as inputs. If we emitted objects with type tags, ProtoBuf.js would
 * choke claiming that the tags aren't fields in the Message.
 *
 * Allowing both formats here makes the serializer able to consume the outputs
 * it produces: for all messages it supports, fromX(toX(value)) == value.
 *
 * Note that case 2 suffers from ambiguity: if multiple tags are present
 * without a type tag then the callers are structured in such a way that the
 * first invocation will win. Since we only parse in this mode when parsing
 * the output of a serialize method this works, but it's not a general
 * solution.
 *
 * Unfortunately there is no general solution here because proto3 makes it
 * impossible to distinguish unset from explicitly set fields: both have the
 * default value for the type. Without the type tag but multiple value tags
 * it's possible to have default values for each tag in the oneof and not be
 * able to know which was actually in effect.
 */
function hasTag(obj, type, tag) {
    return type === tag || !type && tag in obj;
}

//# sourceMappingURL=serializer.js.map
// EXTERNAL MODULE: ../node_modules/@firebase/webchannel-wrapper/dist/index.js
var dist = __webpack_require__("IIoC");
var dist_default = /*#__PURE__*/__webpack_require__.n(dist);

// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/remote/stream_bridge.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Provides a simple helper class that implements the Stream interface to
 * bridge to other implementations that are streams but do not implement the
 * interface. The stream callbacks are invoked with the callOn... methods.
 */
var stream_bridge_StreamBridge = /** @class */function () {
    function StreamBridge(args) {
        this.wrappedOnOpen = null;
        this.wrappedOnClose = null;
        this.wrappedOnMessage = null;
        this.sendFn = args.sendFn;
        this.closeFn = args.closeFn;
    }
    StreamBridge.prototype.onOpen = function (callback) {
        assert_assert(!this.wrappedOnOpen, 'Called onOpen on stream twice!');
        this.wrappedOnOpen = callback;
    };
    StreamBridge.prototype.onClose = function (callback) {
        assert_assert(!this.wrappedOnClose, 'Called onClose on stream twice!');
        this.wrappedOnClose = callback;
    };
    StreamBridge.prototype.onMessage = function (callback) {
        assert_assert(!this.wrappedOnMessage, 'Called onMessage on stream twice!');
        this.wrappedOnMessage = callback;
    };
    StreamBridge.prototype.close = function () {
        this.closeFn();
    };
    StreamBridge.prototype.send = function (msg) {
        this.sendFn(msg);
    };
    StreamBridge.prototype.callOnOpen = function () {
        assert_assert(this.wrappedOnOpen !== null, 'Cannot call onOpen because no callback ' + 'was set');
        this.wrappedOnOpen();
    };
    StreamBridge.prototype.callOnClose = function (err) {
        assert_assert(this.wrappedOnClose !== null, 'Cannot call onClose because no ' + 'callback was set');
        this.wrappedOnClose(err);
    };
    StreamBridge.prototype.callOnMessage = function (msg) {
        assert_assert(this.wrappedOnMessage !== null, 'Cannot call onMessage because no ' + 'callback was set');
        this.wrappedOnMessage(msg);
    };
    return StreamBridge;
}();


//# sourceMappingURL=stream_bridge.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/platform_browser/webchannel_connection.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */







var LOG_TAG = 'Connection';
var RPC_STREAM_SERVICE = 'google.firestore.v1beta1.Firestore';
var RPC_URL_VERSION = 'v1beta1';
/** Maps RPC names to the corresponding REST endpoint name. */
var RPC_NAME_REST_MAPPING = {
    BatchGetDocuments: 'batchGet',
    Commit: 'commit'
};
// TODO(b/38203344): The SDK_VERSION is set independently from Firebase because
// we are doing out-of-band releases. Once we release as part of Firebase, we
// should use the Firebase version instead.
var X_GOOG_API_CLIENT_VALUE = 'gl-js/ fire/' + SDK_VERSION;
var XHR_TIMEOUT_SECS = 15;
var webchannel_connection_WebChannelConnection = /** @class */function () {
    function WebChannelConnection(info) {
        this.databaseId = info.databaseId;
        this.pool = new dist["XhrIoPool"]();
        var proto = info.ssl ? 'https' : 'http';
        this.baseUrl = proto + '://' + info.host;
    }
    /**
     * Modifies the headers for a request, adding any authorization token if
     * present and any additional headers for the request.
     */
    WebChannelConnection.prototype.modifyHeadersForRequest = function (headers, token) {
        if (token) {
            for (var header in token.authHeaders) {
                if (token.authHeaders.hasOwnProperty(header)) {
                    headers[header] = token.authHeaders[header];
                }
            }
        }
        headers['X-Goog-Api-Client'] = X_GOOG_API_CLIENT_VALUE;
        // This header is used to improve routing and project isolation by the
        // backend.
        headers['google-cloud-resource-prefix'] = "projects/" + this.databaseId.projectId + "/" + ("databases/" + this.databaseId.database);
    };
    WebChannelConnection.prototype.invokeRPC = function (rpcName, request, token) {
        var _this = this;
        var url = this.makeUrl(rpcName);
        return new Promise(function (resolve, reject) {
            _this.pool.getObject(function (xhr) {
                xhr.listenOnce(dist["EventType"].COMPLETE, function () {
                    try {
                        switch (xhr.getLastErrorCode()) {
                            case dist["ErrorCode"].NO_ERROR:
                                var json = xhr.getResponseJson();
                                debug(LOG_TAG, 'XHR received:', JSON.stringify(json));
                                resolve(json);
                                break;
                            case dist["ErrorCode"].TIMEOUT:
                                debug(LOG_TAG, 'RPC "' + rpcName + '" timed out');
                                reject(new FirestoreError(Code.DEADLINE_EXCEEDED, 'Request time out'));
                                break;
                            case dist["ErrorCode"].HTTP_ERROR:
                                var status_1 = xhr.getStatus();
                                debug(LOG_TAG, 'RPC "' + rpcName + '" failed with status:', status_1, 'response text:', xhr.getResponseText());
                                if (status_1 > 0) {
                                    reject(new FirestoreError(mapCodeFromHttpStatus(status_1), 'Server responded with status ' + xhr.getStatusText()));
                                } else {
                                    // If we received an HTTP_ERROR but there's no status code,
                                    // it's most probably a connection issue
                                    debug(LOG_TAG, 'RPC "' + rpcName + '" failed');
                                    reject(new FirestoreError(Code.UNAVAILABLE, 'Connection failed.'));
                                }
                                break;
                            default:
                                fail('RPC "' + rpcName + '" failed with unanticipated ' + 'webchannel error ' + xhr.getLastErrorCode() + ': ' + xhr.getLastError() + ', giving up.');
                        }
                    } finally {
                        debug(LOG_TAG, 'RPC "' + rpcName + '" completed.');
                        _this.pool.releaseObject(xhr);
                    }
                });
                var requestString = JSON.stringify(request);
                debug(LOG_TAG, 'XHR sending: ', url + ' ' + requestString);
                // Content-Type: text/plain will avoid preflight requests which might
                // mess with CORS and redirects by proxies. If we add custom headers
                // we will need to change this code to potentially use the
                // $httpOverwrite parameter supported by ESF to avoid
                // triggering preflight requests.
                var headers = { 'Content-Type': 'text/plain' };
                _this.modifyHeadersForRequest(headers, token);
                xhr.send(url, 'POST', requestString, headers, XHR_TIMEOUT_SECS);
            });
        });
    };
    WebChannelConnection.prototype.invokeStreamingRPC = function (rpcName, request, token) {
        // The REST API automatically aggregates all of the streamed results, so we
        // can just use the normal invoke() method.
        return this.invokeRPC(rpcName, request, token);
    };
    WebChannelConnection.prototype.openStream = function (rpcName, token) {
        var urlParts = [this.baseUrl, '/', RPC_STREAM_SERVICE, '/', rpcName, '/channel'];
        var webchannelTransport = Object(dist["createWebChannelTransport"])();
        var request = {
            // Background channel test avoids the initial two test calls and decreases
            // initial cold start time.
            // TODO(dimond): wenboz@ mentioned this might affect use with proxies and
            // we should monitor closely for any reports.
            backgroundChannelTest: true,
            // Required for backend stickiness, routing behavior is based on this
            // parameter.
            httpSessionIdParam: 'gsessionid',
            initMessageHeaders: {},
            // Send our custom headers as a '$httpHeaders=' url param to avoid CORS
            // preflight round-trip. This is formally defined here:
            // https://github.com/google/closure-library/blob/b0e1815b13fb92a46d7c9b3c30de5d6a396a3245/closure/goog/net/rpc/httpcors.js#L40
            httpHeadersOverwriteParam: '$httpHeaders',
            sendRawJson: true,
            supportsCrossDomainXhr: true
        };
        this.modifyHeadersForRequest(request.initMessageHeaders, token);
        var url = urlParts.join('');
        debug(LOG_TAG, 'Creating WebChannel: ' + url + ' ' + request);
        // tslint:disable-next-line:no-any Because listen isn't defined on it.
        var channel = webchannelTransport.createWebChannel(url, request);
        // WebChannel supports sending the first message with the handshake - saving
        // a network round trip. However, it will have to call send in the same
        // JS event loop as open. In order to enforce this, we delay actually
        // opening the WebChannel until send is called. Whether we have called
        // open is tracked with this variable.
        var opened = false;
        // A flag to determine whether the stream was closed (by us or through an
        // error/close event) to avoid delivering multiple close events or sending
        // on a closed stream
        var closed = false;
        // tslint:disable-next-line:no-any
        var streamBridge = new stream_bridge_StreamBridge({
            sendFn: function sendFn(msg) {
                if (!closed) {
                    if (!opened) {
                        debug(LOG_TAG, 'Opening WebChannel transport.');
                        channel.open();
                        opened = true;
                    }
                    debug(LOG_TAG, 'WebChannel sending:', msg);
                    channel.send(msg);
                } else {
                    debug(LOG_TAG, 'Not sending because WebChannel is closed:', msg);
                }
            },
            closeFn: function closeFn() {
                return channel.close();
            }
        });
        // Closure events are guarded and exceptions are swallowed, so catch any
        // exception and rethrow using a setTimeout so they become visible again.
        // Note that eventually this function could go away if we are confident
        // enough the code is exception free.
        var unguardedEventListen = function unguardedEventListen(type, fn) {
            // TODO(dimond): closure typing seems broken because WebChannel does
            // not implement goog.events.Listenable
            channel.listen(type, function (param) {
                try {
                    fn(param);
                } catch (e) {
                    setTimeout(function () {
                        throw e;
                    }, 0);
                }
            });
        };
        unguardedEventListen(dist["WebChannel"].EventType.OPEN, function () {
            if (!closed) {
                debug(LOG_TAG, 'WebChannel transport opened.');
            }
        });
        unguardedEventListen(dist["WebChannel"].EventType.CLOSE, function () {
            if (!closed) {
                closed = true;
                debug(LOG_TAG, 'WebChannel transport closed');
                streamBridge.callOnClose();
            }
        });
        unguardedEventListen(dist["WebChannel"].EventType.ERROR, function (err) {
            if (!closed) {
                closed = true;
                debug(LOG_TAG, 'WebChannel transport errored:', err);
                streamBridge.callOnClose(new FirestoreError(Code.UNAVAILABLE, 'The operation could not be completed'));
            }
        });
        unguardedEventListen(dist["WebChannel"].EventType.MESSAGE, function (msg) {
            if (!closed) {
                // WebChannel delivers message events as array. If batching
                // is not enabled (it's off by default) each message will be
                // delivered alone, resulting in a single element array.
                var msgData = msg.data[0];
                assert_assert(!!msgData, 'Got a webchannel message without data.');
                // TODO(b/35143891): There is a bug in One Platform that caused errors
                // (and only errors) to be wrapped in an extra array. To be forward
                // compatible with the bug we need to check either condition. The latter
                // can be removed once the fix has been rolled out.
                var error = msgData.error || msgData[0] && msgData[0].error;
                if (error) {
                    debug(LOG_TAG, 'WebChannel received error:', error);
                    // error.status will be a string like 'OK' or 'NOT_FOUND'.
                    var status_2 = error.status;
                    var code = mapCodeFromRpcStatus(status_2);
                    var message = error.message;
                    if (code === undefined) {
                        code = Code.INTERNAL;
                        message = 'Unknown error status: ' + status_2 + ' with message ' + error.message;
                    }
                    // Mark closed so no further events are propagated
                    closed = true;
                    streamBridge.callOnClose(new FirestoreError(code, message));
                    channel.close();
                } else {
                    debug(LOG_TAG, 'WebChannel received:', msgData);
                    streamBridge.callOnMessage(msgData);
                }
            }
        });
        setTimeout(function () {
            // Technically we could/should wait for the WebChannel opened event,
            // but because we want to send the first message with the WebChannel
            // handshake we pretend the channel opened here (asynchronously), and
            // then delay the actual open until the first message is sent.
            streamBridge.callOnOpen();
        }, 0);
        return streamBridge;
    };
    // visible for testing
    WebChannelConnection.prototype.makeUrl = function (rpcName) {
        var urlRpcName = RPC_NAME_REST_MAPPING[rpcName];
        assert_assert(urlRpcName !== undefined, 'Unknown REST mapping for: ' + rpcName);
        var url = [this.baseUrl, '/', RPC_URL_VERSION];
        url.push('/projects/');
        url.push(this.databaseId.projectId);
        url.push('/databases/');
        url.push(this.databaseId.database);
        url.push('/documents');
        url.push(':');
        url.push(urlRpcName);
        return url.join('');
    };
    return WebChannelConnection;
}();


//# sourceMappingURL=webchannel_connection.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/platform_browser/browser_platform.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var browser_platform_BrowserPlatform = /** @class */function () {
    function BrowserPlatform() {
        this.emptyByteString = '';
        this.base64Available = typeof atob !== 'undefined';
    }
    BrowserPlatform.prototype.loadConnection = function (databaseInfo) {
        return Promise.resolve(new webchannel_connection_WebChannelConnection(databaseInfo));
    };
    BrowserPlatform.prototype.newSerializer = function (databaseId) {
        return new serializer_JsonProtoSerializer(databaseId, { useProto3Json: true });
    };
    BrowserPlatform.prototype.formatJSON = function (value) {
        return JSON.stringify(value);
    };
    BrowserPlatform.prototype.atob = function (encoded) {
        return atob(encoded);
    };
    BrowserPlatform.prototype.btoa = function (raw) {
        return btoa(raw);
    };
    return BrowserPlatform;
}();


//# sourceMappingURL=browser_platform.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/platform_browser/browser_init.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * This code needs to run before Firestore is used. This can be achieved in
 * several ways:
 *   1) Through the JSCompiler compiling this code and then (automatically)
 *      executing it before exporting the Firestore symbols.
 *   2) Through importing this module first in a Firestore main module
 */
platform_PlatformSupport.setPlatform(new browser_platform_BrowserPlatform());

//# sourceMappingURL=browser_init.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/api/field_path.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



// The objects that are a part of this API are exposed to third-parties as
// compiled javascript so we want to flag our private members with a leading
// underscore to discourage their use.
// tslint:disable:strip-private-property-underscore
/**
 * A FieldPath refers to a field in a document. The path may consist of a single
 * field name (referring to a top-level field in the document), or a list of
 * field names (referring to a nested field in the document).
 */
var field_path_FieldPath = /** @class */function () {
    /**
     * Creates a FieldPath from the provided field names. If more than one field
     * name is provided, the path will point to a nested field in a document.
     *
     * @param fieldNames A list of field names.
     */
    function FieldPath() {
        var fieldNames = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            fieldNames[_i] = arguments[_i];
        }
        validateNamedArrayAtLeastNumberOfElements('FieldPath', fieldNames, 'fieldNames', 1);
        for (var i = 0; i < fieldNames.length; ++i) {
            validateArgType('FieldPath', 'string', i, fieldNames[i]);
            if (fieldNames[i].length === 0) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). " + 'Field names must not be empty.');
            }
        }
        this._internalPath = new path_FieldPath(fieldNames);
    }
    FieldPath.documentId = function () {
        return FieldPath._DOCUMENT_ID;
    };
    /**
     * Internal Note: The backend doesn't technically support querying by
     * document ID. Instead it queries by the entire document name (full path
     * included), but in the cases we currently support documentId(), the net
     * effect is the same.
     */
    FieldPath._DOCUMENT_ID = new FieldPath(path_FieldPath.keyField().canonicalString());
    return FieldPath;
}();

/**
 * Matches any characters in a field path string that are reserved.
 */
var RESERVED = new RegExp('[~\\*/\\[\\]]');
/**
 * Parses a field path string into a FieldPath, treating dots as separators.
 */
function fromDotSeparatedString(path) {
    var found = path.search(RESERVED);
    if (found >= 0) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid field path (" + path + "). Paths must not contain " + "'~', '*', '/', '[', or ']'");
    }
    try {
        return new (field_path_FieldPath.bind.apply(field_path_FieldPath, [void 0].concat(path.split('.'))))();
    } catch (e) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid field path (" + path + "). Paths must not be empty, " + "begin with '.', end with '.', or contain '..'");
    }
}

//# sourceMappingURL=field_path.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/core/types.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/** Describes the online state of the Firestore client */
var OnlineState;
(function (OnlineState) {
  /**
   * The Firestore client is in an unknown online state. This means the client
   * is either not actively trying to establish a connection or it was
   * previously in an unknown state and is trying to establish a connection.
   */
  OnlineState[OnlineState["Unknown"] = 0] = "Unknown";
  /**
   * The client is connected and the connections are healthy. This state is
   * reached after a successful connection and there has been at least one
   * succesful message received from the backends.
   */
  OnlineState[OnlineState["Healthy"] = 1] = "Healthy";
  /**
   * The client has tried to establish a connection but has failed.
   * This state is reached after either a connection attempt failed or a
   * healthy stream was closed for unexpected reasons.
   */
  OnlineState[OnlineState["Failed"] = 2] = "Failed";
})(OnlineState || (OnlineState = {}));

//# sourceMappingURL=types.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/core/view_snapshot.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var ChangeType;
(function (ChangeType) {
    ChangeType[ChangeType["Added"] = 0] = "Added";
    ChangeType[ChangeType["Removed"] = 1] = "Removed";
    ChangeType[ChangeType["Modified"] = 2] = "Modified";
    ChangeType[ChangeType["Metadata"] = 3] = "Metadata";
})(ChangeType || (ChangeType = {}));
var SyncState;
(function (SyncState) {
    SyncState[SyncState["Local"] = 0] = "Local";
    SyncState[SyncState["Synced"] = 1] = "Synced";
})(SyncState || (SyncState = {}));
/**
 * DocumentChangeSet keeps track of a set of changes to docs in a query, merging
 * duplicate events for the same doc.
 */
var view_snapshot_DocumentChangeSet = /** @class */function () {
    function DocumentChangeSet() {
        this.changeMap = new sorted_map_SortedMap(document_key_DocumentKey.comparator);
    }
    DocumentChangeSet.prototype.track = function (change) {
        var key = change.doc.key;
        var oldChange = this.changeMap.get(key);
        if (!oldChange) {
            this.changeMap = this.changeMap.insert(key, change);
            return;
        }
        // Merge the new change with the existing change.
        if (change.type !== ChangeType.Added && oldChange.type === ChangeType.Metadata) {
            this.changeMap = this.changeMap.insert(key, change);
        } else if (change.type === ChangeType.Metadata && oldChange.type !== ChangeType.Removed) {
            this.changeMap = this.changeMap.insert(key, {
                type: oldChange.type,
                doc: change.doc
            });
        } else if (change.type === ChangeType.Modified && oldChange.type === ChangeType.Modified) {
            this.changeMap = this.changeMap.insert(key, {
                type: ChangeType.Modified,
                doc: change.doc
            });
        } else if (change.type === ChangeType.Modified && oldChange.type === ChangeType.Added) {
            this.changeMap = this.changeMap.insert(key, {
                type: ChangeType.Added,
                doc: change.doc
            });
        } else if (change.type === ChangeType.Removed && oldChange.type === ChangeType.Added) {
            this.changeMap = this.changeMap.remove(key);
        } else if (change.type === ChangeType.Removed && oldChange.type === ChangeType.Modified) {
            this.changeMap = this.changeMap.insert(key, {
                type: ChangeType.Removed,
                doc: oldChange.doc
            });
        } else if (change.type === ChangeType.Added && oldChange.type === ChangeType.Removed) {
            this.changeMap = this.changeMap.insert(key, {
                type: ChangeType.Modified,
                doc: change.doc
            });
        } else {
            // This includes these cases, which don't make sense:
            // Added->Added
            // Removed->Removed
            // Modified->Added
            // Removed->Modified
            // Metadata->Added
            // Removed->Metadata
            fail('unsupported combination of changes: ' + JSON.stringify(change) + ' after ' + JSON.stringify(oldChange));
        }
    };
    DocumentChangeSet.prototype.getChanges = function () {
        var changes = [];
        this.changeMap.inorderTraversal(function (key, change) {
            changes.push(change);
        });
        return changes;
    };
    return DocumentChangeSet;
}();


//# sourceMappingURL=view_snapshot.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/model/document_set.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
 * DocumentSet is an immutable (copy-on-write) collection that holds documents
 * in order specified by the provided comparator. We always add a document key
 * comparator on top of what is provided to guarantee document equality based on
 * the key.
 */
var document_set_DocumentSet = /** @class */function () {
    /** The default ordering is by key if the comparator is omitted */
    function DocumentSet(comp) {
        // We are adding document key comparator to the end as it's the only
        // guaranteed unique property of a document.
        if (comp) {
            this.comparator = function (d1, d2) {
                return comp(d1, d2) || document_key_DocumentKey.comparator(d1.key, d2.key);
            };
        } else {
            this.comparator = function (d1, d2) {
                return document_key_DocumentKey.comparator(d1.key, d2.key);
            };
        }
        this.keyedMap = documentMap();
        this.sortedSet = new sorted_map_SortedMap(this.comparator);
    }
    /**
     * Returns an empty copy of the existing DocumentSet, using the same
     * comparator.
     */
    DocumentSet.emptySet = function (oldSet) {
        return new DocumentSet(oldSet.comparator);
    };
    DocumentSet.prototype.has = function (key) {
        return this.keyedMap.get(key) != null;
    };
    DocumentSet.prototype.get = function (key) {
        return this.keyedMap.get(key);
    };
    DocumentSet.prototype.first = function () {
        return this.sortedSet.minKey();
    };
    DocumentSet.prototype.last = function () {
        return this.sortedSet.maxKey();
    };
    DocumentSet.prototype.isEmpty = function () {
        return this.sortedSet.isEmpty();
    };
    /**
     * Returns previous document or null if it's a first doc.
     *
     * @param key A key that MUST be present in the DocumentSet.
     */
    DocumentSet.prototype.prevDoc = function (key) {
        assert_assert(this.has(key), 'Trying to get a previous document to non-existing key: ' + key);
        var doc = this.keyedMap.get(key);
        return this.sortedSet.getPredecessorKey(doc);
    };
    /**
     * Returns the index of the provided key in the document set, or -1 if the
     * document key is not present in the set;
     */
    DocumentSet.prototype.indexOf = function (key) {
        var doc = this.keyedMap.get(key);
        return doc ? this.sortedSet.indexOf(doc) : -1;
    };
    Object.defineProperty(DocumentSet.prototype, "size", {
        get: function get() {
            return this.sortedSet.size;
        },
        enumerable: true,
        configurable: true
    });
    /** Iterates documents in order defined by "comparator" */
    DocumentSet.prototype.forEach = function (cb) {
        this.sortedSet.inorderTraversal(function (k, v) {
            cb(k);
            return false;
        });
    };
    /** Inserts or updates a document with the same key */
    DocumentSet.prototype.add = function (doc) {
        // First remove the element if we have it.
        var set = this.delete(doc.key);
        return set.copy(set.keyedMap.insert(doc.key, doc), set.sortedSet.insert(doc, null));
    };
    /** Deletes a document with a given key */
    DocumentSet.prototype.delete = function (key) {
        var doc = this.get(key);
        if (!doc) {
            return this;
        }
        return this.copy(this.keyedMap.remove(key), this.sortedSet.remove(doc));
    };
    DocumentSet.prototype.equals = function (other) {
        if (!(other instanceof DocumentSet)) return false;
        if (this.size !== other.size) return false;
        var thisIt = this.sortedSet.getIterator();
        var otherIt = other.sortedSet.getIterator();
        while (thisIt.hasNext()) {
            var thisDoc = thisIt.getNext().key;
            var otherDoc = otherIt.getNext().key;
            if (!thisDoc.equals(otherDoc)) return false;
        }
        return true;
    };
    DocumentSet.prototype.toString = function () {
        var docStrings = [];
        this.forEach(function (doc) {
            docStrings.push(doc.toString());
        });
        if (docStrings.length === 0) {
            return 'DocumentSet ()';
        } else {
            return 'DocumentSet (\n  ' + docStrings.join('  \n') + '\n)';
        }
    };
    DocumentSet.prototype.copy = function (keyedMap, sortedSet) {
        var newSet = new DocumentSet();
        newSet.comparator = this.comparator;
        newSet.keyedMap = keyedMap;
        newSet.sortedSet = sortedSet;
        return newSet;
    };
    return DocumentSet;
}();


//# sourceMappingURL=document_set.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/util/obj_map.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A map implementation that uses objects as keys. Objects must implement the
 * Equatable interface and must be immutable. Entries in the map are stored
 * together with the key being produced from the mapKeyFn. This map
 * automatically handles collisions of keys.
 */
var obj_map_ObjectMap = /** @class */function () {
    function ObjectMap(mapKeyFn) {
        this.mapKeyFn = mapKeyFn;
        /**
         * The inner map for a key -> value pair. Due to the possibility of
         * collisions we keep a list of entries that we do a linear search through
         * to find an actual match. Note that collisions should be rare, so we still
         * expect near constant time lookups in practice.
         */
        this.inner = {};
    }
    /** Get a value for this key, or undefined if it does not exist. */
    ObjectMap.prototype.get = function (key) {
        var id = this.mapKeyFn(key);
        var matches = this.inner[id];
        if (matches === undefined) {
            return undefined;
        }
        for (var _i = 0, matches_1 = matches; _i < matches_1.length; _i++) {
            var _a = matches_1[_i],
                otherKey = _a[0],
                value = _a[1];
            if (otherKey.equals(key)) {
                return value;
            }
        }
        return undefined;
    };
    ObjectMap.prototype.has = function (key) {
        return this.get(key) !== undefined;
    };
    /** Put this key and value in the map. */
    ObjectMap.prototype.set = function (key, value) {
        var id = this.mapKeyFn(key);
        var matches = this.inner[id];
        if (matches === undefined) {
            this.inner[id] = [[key, value]];
            return;
        }
        for (var i = 0; i < matches.length; i++) {
            if (matches[i][0].equals(key)) {
                matches[i] = [key, value];
                return;
            }
        }
        matches.push([key, value]);
    };
    /**
     * Remove this key from the map. Returns a boolean if anything was deleted.
     */
    ObjectMap.prototype.delete = function (key) {
        var id = this.mapKeyFn(key);
        var matches = this.inner[id];
        if (matches === undefined) {
            return false;
        }
        for (var i = 0; i < matches.length; i++) {
            if (matches[i][0].equals(key)) {
                if (matches.length === 1) {
                    delete this.inner[id];
                } else {
                    matches.splice(i, 1);
                }
                return true;
            }
        }
        return false;
    };
    ObjectMap.prototype.forEach = function (fn) {
        obj_forEach(this.inner, function (_, entries) {
            for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
                var _a = entries_1[_i],
                    k = _a[0],
                    v = _a[1];
                fn(k, v);
            }
        });
    };
    ObjectMap.prototype.isEmpty = function () {
        return obj_isEmpty(this.inner);
    };
    return ObjectMap;
}();


//# sourceMappingURL=obj_map.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/core/event_manager.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Holds the listeners and the last received ViewSnapshot for a query being
 * tracked by EventManager.
 */
var QueryListenersInfo = /** @class */function () {
    function QueryListenersInfo() {
        this.listeners = [];
    }
    return QueryListenersInfo;
}();
/**
 * EventManager is responsible for mapping queries to query event emitters.
 * It handles "fan-out". -- Identical queries will re-use the same watch on the
 * backend.
 */
var event_manager_EventManager = /** @class */function () {
    function EventManager(syncEngine) {
        this.syncEngine = syncEngine;
        this.queries = new obj_map_ObjectMap(function (q) {
            return q.canonicalId();
        });
        this.onlineState = OnlineState.Unknown;
        this.syncEngine.subscribe(this.onChange.bind(this), this.onError.bind(this));
    }
    EventManager.prototype.listen = function (listener) {
        var query = listener.query;
        var firstListen = false;
        var queryInfo = this.queries.get(query);
        if (!queryInfo) {
            firstListen = true;
            queryInfo = new QueryListenersInfo();
            this.queries.set(query, queryInfo);
        }
        queryInfo.listeners.push(listener);
        listener.onOnlineStateChanged(this.onlineState);
        if (queryInfo.viewSnap) listener.onViewSnapshot(queryInfo.viewSnap);
        if (firstListen) {
            return this.syncEngine.listen(query).then(function (targetId) {
                queryInfo.targetId = targetId;
                return targetId;
            });
        } else {
            return Promise.resolve(queryInfo.targetId);
        }
    };
    EventManager.prototype.unlisten = function (listener) {
        var query = listener.query;
        var lastListen = false;
        var queryInfo = this.queries.get(query);
        if (queryInfo) {
            var i = queryInfo.listeners.indexOf(listener);
            if (i >= 0) {
                queryInfo.listeners.splice(i, 1);
                lastListen = queryInfo.listeners.length === 0;
            }
        }
        if (lastListen) {
            this.queries.delete(query);
            return this.syncEngine.unlisten(query);
        } else {
            return Promise.resolve();
        }
    };
    EventManager.prototype.onChange = function (viewSnaps) {
        for (var _i = 0, viewSnaps_1 = viewSnaps; _i < viewSnaps_1.length; _i++) {
            var viewSnap = viewSnaps_1[_i];
            var query = viewSnap.query;
            var queryInfo = this.queries.get(query);
            if (queryInfo) {
                for (var _a = 0, _b = queryInfo.listeners; _a < _b.length; _a++) {
                    var listener = _b[_a];
                    listener.onViewSnapshot(viewSnap);
                }
                queryInfo.viewSnap = viewSnap;
            }
        }
    };
    EventManager.prototype.onError = function (query, error) {
        var queryInfo = this.queries.get(query);
        if (queryInfo) {
            for (var _i = 0, _a = queryInfo.listeners; _i < _a.length; _i++) {
                var listener = _a[_i];
                listener.onError(error);
            }
        }
        // Remove all listeners. NOTE: We don't need to call syncEngine.unlisten()
        // after an error.
        this.queries.delete(query);
    };
    EventManager.prototype.onOnlineStateChanged = function (onlineState) {
        this.onlineState = onlineState;
        this.queries.forEach(function (_, queryInfo) {
            for (var _i = 0, _a = queryInfo.listeners; _i < _a.length; _i++) {
                var listener = _a[_i];
                listener.onOnlineStateChanged(onlineState);
            }
        });
    };
    return EventManager;
}();

/**
 * QueryListener takes a series of internal view snapshots and determines
 * when to raise the event.
 *
 * It uses an Observer to dispatch events.
 */
var event_manager_QueryListener = /** @class */function () {
    function QueryListener(query, queryObserver, options) {
        this.query = query;
        this.queryObserver = queryObserver;
        /**
         * Initial snapshots (e.g. from cache) may not be propagated to the wrapped
         * observer. This flag is set to true once we've actually raised an event.
         */
        this.raisedInitialEvent = false;
        this.onlineState = OnlineState.Unknown;
        this.options = options || {};
    }
    QueryListener.prototype.onViewSnapshot = function (snap) {
        assert_assert(snap.docChanges.length > 0 || snap.syncStateChanged, 'We got a new snapshot with no changes?');
        if (!this.options.includeDocumentMetadataChanges) {
            // Remove the metadata only changes.
            var docChanges = [];
            for (var _i = 0, _a = snap.docChanges; _i < _a.length; _i++) {
                var docChange = _a[_i];
                if (docChange.type !== ChangeType.Metadata) {
                    docChanges.push(docChange);
                }
            }
            snap = {
                query: snap.query,
                docs: snap.docs,
                oldDocs: snap.oldDocs,
                docChanges: docChanges,
                fromCache: snap.fromCache,
                hasPendingWrites: snap.hasPendingWrites,
                syncStateChanged: snap.syncStateChanged
            };
        }
        if (!this.raisedInitialEvent) {
            if (this.shouldRaiseInitialEvent(snap, this.onlineState)) {
                this.raiseInitialEvent(snap);
            }
        } else if (this.shouldRaiseEvent(snap)) {
            this.queryObserver.next(snap);
        }
        this.snap = snap;
    };
    QueryListener.prototype.onError = function (error) {
        this.queryObserver.error(error);
    };
    QueryListener.prototype.onOnlineStateChanged = function (onlineState) {
        this.onlineState = onlineState;
        if (this.snap && !this.raisedInitialEvent && this.shouldRaiseInitialEvent(this.snap, onlineState)) {
            this.raiseInitialEvent(this.snap);
        }
    };
    QueryListener.prototype.shouldRaiseInitialEvent = function (snap, onlineState) {
        assert_assert(!this.raisedInitialEvent, 'Determining whether to raise first event but already had first event');
        // Always raise the first event when we're synced
        if (!snap.fromCache) {
            return true;
        }
        // NOTE: We consider OnlineState.Unknown as online (it should become Failed
        // or Online if we wait long enough).
        var maybeOnline = onlineState !== OnlineState.Failed;
        // Don't raise the event if we're online, aren't synced yet (checked
        // above) and are waiting for a sync.
        if (this.options.waitForSyncWhenOnline && maybeOnline) {
            assert_assert(snap.fromCache, 'Waiting for sync, but snapshot is not from cache');
            return false;
        }
        // Raise data from cache if we have any documents or we are offline
        return !snap.docs.isEmpty() || onlineState === OnlineState.Failed;
    };
    QueryListener.prototype.shouldRaiseEvent = function (snap) {
        // We don't need to handle includeDocumentMetadataChanges here because
        // the Metadata only changes have already been stripped out if needed.
        // At this point the only changes we will see are the ones we should
        // propagate.
        if (snap.docChanges.length > 0) {
            return true;
        }
        var hasPendingWritesChanged = this.snap && this.snap.hasPendingWrites !== snap.hasPendingWrites;
        if (snap.syncStateChanged || hasPendingWritesChanged) {
            return this.options.includeQueryMetadataChanges === true;
        }
        // Generally we should have hit one of the cases above, but it's possible
        // to get here if there were only metadata docChanges and they got
        // stripped out.
        return false;
    };
    QueryListener.prototype.raiseInitialEvent = function (snap) {
        assert_assert(!this.raisedInitialEvent, 'Trying to raise initial events for second time');
        snap = {
            query: snap.query,
            docs: snap.docs,
            oldDocs: document_set_DocumentSet.emptySet(snap.docs),
            docChanges: QueryListener.getInitialViewChanges(snap),
            fromCache: snap.fromCache,
            hasPendingWrites: snap.hasPendingWrites,
            syncStateChanged: true
        };
        this.raisedInitialEvent = true;
        this.queryObserver.next(snap);
    };
    /** Returns changes as if all documents in the snap were added. */
    QueryListener.getInitialViewChanges = function (snap) {
        var result = [];
        snap.docs.forEach(function (doc) {
            result.push({ type: ChangeType.Added, doc: doc });
        });
        return result;
    };
    return QueryListener;
}();


//# sourceMappingURL=event_manager.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/local/persistence_promise.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * PersistencePromise<> is essentially a re-implementation of Promise<> except
 * it has a .next() method instead of .then() and .next() and .catch() callbacks
 * are executed synchronously when a PersistencePromise resolves rather than
 * asynchronously (Promise<> implementations use setImmediate() or similar).
 *
 * This is necessary to interoperate with IndexedDB which will automatically
 * commit transactions if control is returned to the event loop without
 * synchronously initiating another operation on the transaction.
 *
 * NOTE: .then() and .catch() only allow a single consumer, unlike normal
 * Promises.
 */
var persistence_promise_PersistencePromise = /** @class */function () {
    function PersistencePromise(callback) {
        var _this = this;
        // NOTE: next/catchCallback will always point to our own wrapper functions,
        // not the user's raw next() or catch() callbacks.
        this.nextCallback = null;
        this.catchCallback = null;
        // When the operation resolves, we'll set result or error and mark isDone.
        this.result = undefined;
        this.error = null;
        this.isDone = false;
        // Set to true when .then() or .catch() are called and prevents additional
        // chaining.
        this.callbackAttached = false;
        callback(function (value) {
            _this.isDone = true;
            _this.result = value;
            if (_this.nextCallback) {
                // value should be defined unless T is Void, but we can't express
                // that in the type system.
                _this.nextCallback(value);
            }
        }, function (error) {
            _this.isDone = true;
            _this.error = error;
            if (_this.catchCallback) {
                _this.catchCallback(error);
            }
        });
    }
    PersistencePromise.prototype.catch = function (fn) {
        return this.next(undefined, fn);
    };
    PersistencePromise.prototype.next = function (nextFn, catchFn) {
        var _this = this;
        if (this.callbackAttached) {
            fail('Called next() or catch() twice for PersistencePromise');
        }
        this.callbackAttached = true;
        if (this.isDone) {
            if (!this.error) {
                return this.wrapSuccess(nextFn, this.result);
            } else {
                return this.wrapFailure(catchFn, this.error);
            }
        } else {
            return new PersistencePromise(function (resolve, reject) {
                _this.nextCallback = function (value) {
                    _this.wrapSuccess(nextFn, value).next(resolve, reject);
                };
                _this.catchCallback = function (error) {
                    _this.wrapFailure(catchFn, error).next(resolve, reject);
                };
            });
        }
    };
    PersistencePromise.prototype.toPromise = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.next(resolve, reject);
        });
    };
    PersistencePromise.prototype.wrapUserFunction = function (fn) {
        try {
            var result = fn();
            if (result instanceof PersistencePromise) {
                return result;
            } else {
                return PersistencePromise.resolve(result);
            }
        } catch (e) {
            return PersistencePromise.reject(e);
        }
    };
    PersistencePromise.prototype.wrapSuccess = function (nextFn, value) {
        if (nextFn) {
            return this.wrapUserFunction(function () {
                return nextFn(value);
            });
        } else {
            // If there's no nextFn, then R must be the same as T but we
            // can't express that in the type system.
            return PersistencePromise.resolve(value);
        }
    };
    PersistencePromise.prototype.wrapFailure = function (catchFn, error) {
        if (catchFn) {
            return this.wrapUserFunction(function () {
                return catchFn(error);
            });
        } else {
            return PersistencePromise.reject(error);
        }
    };
    PersistencePromise.resolve = function (result) {
        return new PersistencePromise(function (resolve, reject) {
            resolve(result);
        });
    };
    PersistencePromise.reject = function (error) {
        return new PersistencePromise(function (resolve, reject) {
            reject(error);
        });
    };
    PersistencePromise.waitFor = function (all) {
        return all.reduce(function (promise, nextPromise, idx) {
            return promise.next(function () {
                return nextPromise;
            });
        }, PersistencePromise.resolve());
    };
    PersistencePromise.map = function (all) {
        var results = [];
        var first = true;
        // initial is ignored, so we can cheat on the type.
        var initial = PersistencePromise.resolve(null);
        return all.reduce(function (promise, nextPromise) {
            return promise.next(function (result) {
                if (!first) {
                    results.push(result);
                }
                first = false;
                return nextPromise;
            });
        }, initial).next(function (result) {
            results.push(result);
            return results;
        });
    };
    return PersistencePromise;
}();


//# sourceMappingURL=persistence_promise.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/local/eager_garbage_collector.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * A garbage collector implementation that eagerly collects documents as soon as
 * they're no longer referenced in any of its registered GarbageSources.
 *
 * This implementation keeps track of a set of keys that are potentially garbage
 * without keeping an exact reference count. During collectGarbage, the
 * collector verifies that all potential garbage keys actually have no
 * references by consulting its list of garbage sources.
 */
var eager_garbage_collector_EagerGarbageCollector = /** @class */function () {
    function EagerGarbageCollector() {
        this.isEager = true;
        /**
         * The garbage collectible sources to double-check during garbage collection.
         */
        this.sources = [];
        /**
         * A set of potentially garbage keys.
         * PORTING NOTE: This would be a mutable set if Javascript had one.
         */
        this.potentialGarbage = documentKeySet();
    }
    EagerGarbageCollector.prototype.addGarbageSource = function (garbageSource) {
        this.sources.push(garbageSource);
        garbageSource.setGarbageCollector(this);
    };
    EagerGarbageCollector.prototype.removeGarbageSource = function (garbageSource) {
        this.sources.splice(this.sources.indexOf(garbageSource), 1);
        garbageSource.setGarbageCollector(null);
    };
    EagerGarbageCollector.prototype.addPotentialGarbageKey = function (key) {
        this.potentialGarbage = this.potentialGarbage.add(key);
    };
    EagerGarbageCollector.prototype.collectGarbage = function (txn) {
        var _this = this;
        var promises = [];
        var garbageKeys = documentKeySet();
        this.potentialGarbage.forEach(function (key) {
            var hasRefsPromise = _this.documentHasAnyReferences(txn, key);
            promises.push(hasRefsPromise.next(function (hasRefs) {
                // If there are no references, get the key.
                if (!hasRefs) {
                    garbageKeys = garbageKeys.add(key);
                }
                return persistence_promise_PersistencePromise.resolve();
            }));
        });
        // Clear locally retained potential keys and returned confirmed garbage.
        this.potentialGarbage = documentKeySet();
        return persistence_promise_PersistencePromise.waitFor(promises).next(function () {
            return garbageKeys;
        });
    };
    EagerGarbageCollector.prototype.documentHasAnyReferences = function (txn, key) {
        var initial = persistence_promise_PersistencePromise.resolve(false);
        return this.sources.map(function (source) {
            return function () {
                return source.containsKey(txn, key);
            };
        }).reduce(function (promise, nextPromise) {
            return promise.next(function (result) {
                if (result) {
                    return persistence_promise_PersistencePromise.resolve(true);
                } else {
                    return nextPromise();
                }
            });
        }, initial);
    };
    return EagerGarbageCollector;
}();


//# sourceMappingURL=eager_garbage_collector.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/local/local_view_changes.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * A set of changes to what documents are currently in view and out of view for
 * a given query. These changes are sent to the LocalStore by the View (via
 * the SyncEngine) and are used to pin / unpin documents as appropriate.
 */
var local_view_changes_LocalViewChanges = /** @class */function () {
    function LocalViewChanges(query, addedKeys, removedKeys) {
        this.query = query;
        this.addedKeys = addedKeys;
        this.removedKeys = removedKeys;
    }
    LocalViewChanges.fromSnapshot = function (viewSnapshot) {
        var addedKeys = documentKeySet();
        var removedKeys = documentKeySet();
        for (var _i = 0, _a = viewSnapshot.docChanges; _i < _a.length; _i++) {
            var docChange = _a[_i];
            switch (docChange.type) {
                case ChangeType.Added:
                    addedKeys = addedKeys.add(docChange.doc.key);
                    break;
                case ChangeType.Removed:
                    removedKeys = removedKeys.add(docChange.doc.key);
                    break;
                default:
            }
        }
        return new LocalViewChanges(viewSnapshot.query, addedKeys, removedKeys);
    };
    return LocalViewChanges;
}();


//# sourceMappingURL=local_view_changes.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/local/reference_set.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * A collection of references to a document from some kind of numbered entity
 * (either a target ID or batch ID). As references are added to or removed from
 * the set corresponding events are emitted to a registered garbage collector.
 *
 * Each reference is represented by a DocumentReference object. Each of them
 * contains enough information to uniquely identify the reference. They are all
 * stored primarily in a set sorted by key. A document is considered garbage if
 * there's no references in that set (this can be efficiently checked thanks to
 * sorting by key).
 *
 * ReferenceSet also keeps a secondary set that contains references sorted by
 * IDs. This one is used to efficiently implement removal of all references by
 * some target ID.
 */
var reference_set_ReferenceSet = /** @class */function () {
    function ReferenceSet() {
        // A set of outstanding references to a document sorted by key.
        this.refsByKey = new sorted_set_SortedSet(reference_set_DocReference.compareByKey);
        // A set of outstanding references to a document sorted by target id.
        this.refsByTarget = new sorted_set_SortedSet(reference_set_DocReference.compareByTargetId);
        /** Keeps track of keys that have references */
        this.garbageCollector = null;
    }
    /** Returns true if the reference set contains no references. */
    ReferenceSet.prototype.isEmpty = function () {
        return this.refsByKey.isEmpty();
    };
    /** Adds a reference to the given document key for the given ID. */
    ReferenceSet.prototype.addReference = function (key, id) {
        var ref = new reference_set_DocReference(key, id);
        this.refsByKey = this.refsByKey.add(ref);
        this.refsByTarget = this.refsByTarget.add(ref);
    };
    /** Add references to the given document keys for the given ID. */
    ReferenceSet.prototype.addReferences = function (keys, id) {
        var _this = this;
        keys.forEach(function (key) {
            return _this.addReference(key, id);
        });
    };
    /**
     * Removes a reference to the given document key for the given
     * ID.
     */
    ReferenceSet.prototype.removeReference = function (key, id) {
        this.removeRef(new reference_set_DocReference(key, id));
    };
    ReferenceSet.prototype.removeReferences = function (keys, id) {
        var _this = this;
        keys.forEach(function (key) {
            return _this.removeReference(key, id);
        });
    };
    /**
     * Clears all references with a given ID. Calls removeRef() for each key
     * removed.
     */
    ReferenceSet.prototype.removeReferencesForId = function (id) {
        var _this = this;
        var emptyKey = document_key_DocumentKey.EMPTY;
        var startRef = new reference_set_DocReference(emptyKey, id);
        var endRef = new reference_set_DocReference(emptyKey, id + 1);
        this.refsByTarget.forEachInRange([startRef, endRef], function (ref) {
            _this.removeRef(ref);
        });
    };
    ReferenceSet.prototype.removeAllReferences = function () {
        var _this = this;
        this.refsByKey.forEach(function (ref) {
            return _this.removeRef(ref);
        });
    };
    ReferenceSet.prototype.removeRef = function (ref) {
        this.refsByKey = this.refsByKey.delete(ref);
        this.refsByTarget = this.refsByTarget.delete(ref);
        if (this.garbageCollector !== null) {
            this.garbageCollector.addPotentialGarbageKey(ref.key);
        }
    };
    ReferenceSet.prototype.referencesForId = function (id) {
        var emptyKey = document_key_DocumentKey.EMPTY;
        var startRef = new reference_set_DocReference(emptyKey, id);
        var endRef = new reference_set_DocReference(emptyKey, id + 1);
        var keys = documentKeySet();
        this.refsByTarget.forEachInRange([startRef, endRef], function (ref) {
            keys = keys.add(ref.key);
        });
        return keys;
    };
    ReferenceSet.prototype.setGarbageCollector = function (garbageCollector) {
        this.garbageCollector = garbageCollector;
    };
    ReferenceSet.prototype.containsKey = function (txn, key) {
        var ref = new reference_set_DocReference(key, 0);
        var firstRef = this.refsByKey.firstAfterOrEqual(ref);
        return persistence_promise_PersistencePromise.resolve(firstRef !== null && key.equals(firstRef.key));
    };
    return ReferenceSet;
}();

var reference_set_DocReference = /** @class */function () {
    function DocReference(key, targetOrBatchId) {
        this.key = key;
        this.targetOrBatchId = targetOrBatchId;
    }
    /** Compare by key then by ID */
    DocReference.compareByKey = function (left, right) {
        return document_key_DocumentKey.comparator(left.key, right.key) || primitiveComparator(left.targetOrBatchId, right.targetOrBatchId);
    };
    /** Compare by ID then by key */
    DocReference.compareByTargetId = function (left, right) {
        return primitiveComparator(left.targetOrBatchId, right.targetOrBatchId) || document_key_DocumentKey.comparator(left.key, right.key);
    };
    return DocReference;
}();


//# sourceMappingURL=reference_set.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/core/target_id_generator.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var RESERVED_BITS = 1;
var GeneratorIds;
(function (GeneratorIds) {
    GeneratorIds[GeneratorIds["LocalStore"] = 0] = "LocalStore";
    GeneratorIds[GeneratorIds["SyncEngine"] = 1] = "SyncEngine";
})(GeneratorIds || (GeneratorIds = {}));
/**
 * TargetIdGenerator generates monotonically increasing integer IDs. There are
 * separate generators for different scopes. While these generators will operate
 * independently of each other, they are scoped, such that no two generators
 * will ever produce the same ID. This is useful, because sometimes the backend
 * may group IDs from separate parts of the client into the same ID space.
 */
var TargetIdGenerator = /** @class */function () {
    function TargetIdGenerator(generatorId, initAfter) {
        if (initAfter === void 0) {
            initAfter = 0;
        }
        this.generatorId = generatorId;
        // Replace the generator part of initAfter with this generator's ID.
        var afterWithoutGenerator = initAfter >> RESERVED_BITS << RESERVED_BITS;
        var afterGenerator = initAfter - afterWithoutGenerator;
        if (afterGenerator >= generatorId) {
            // For example, if:
            //   this.generatorId = 0b0000
            //   after = 0b1011
            //   afterGenerator = 0b0001
            // Then:
            //   previous = 0b1010
            //   next = 0b1100
            this.previousId = afterWithoutGenerator | this.generatorId;
        } else {
            // For example, if:
            //   this.generatorId = 0b0001
            //   after = 0b1010
            //   afterGenerator = 0b0000
            // Then:
            //   previous = 0b1001
            //   next = 0b1011
            this.previousId = (afterWithoutGenerator | this.generatorId) - (1 << RESERVED_BITS);
        }
    }
    TargetIdGenerator.prototype.next = function () {
        this.previousId += 1 << RESERVED_BITS;
        return this.previousId;
    };
    TargetIdGenerator.forLocalStore = function (initAfter) {
        if (initAfter === void 0) {
            initAfter = 0;
        }
        return new TargetIdGenerator(GeneratorIds.LocalStore, initAfter);
    };
    TargetIdGenerator.forSyncEngine = function () {
        return new TargetIdGenerator(GeneratorIds.SyncEngine);
    };
    return TargetIdGenerator;
}();


//# sourceMappingURL=target_id_generator.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/core/view.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






var AddedLimboDocument = /** @class */function () {
    function AddedLimboDocument(key) {
        this.key = key;
    }
    return AddedLimboDocument;
}();

var RemovedLimboDocument = /** @class */function () {
    function RemovedLimboDocument(key) {
        this.key = key;
    }
    return RemovedLimboDocument;
}();

/**
 * View is responsible for computing the final merged truth of what docs are in
 * a query. It gets notified of local and remote changes to docs, and applies
 * the query filters and limits to determine the most correct possible results.
 */
var view_View = /** @class */function () {
    function View(query,
    /** Documents included in the remote target */
    syncedDocuments) {
        this.query = query;
        this.syncedDocuments = syncedDocuments;
        this.syncState = null;
        /**
         * A flag whether the view is current with the backend. A view is considered
         * current after it has seen the current flag from the backend and did not
         * lose consistency within the watch stream (e.g. because of an existence
         * filter mismatch).
         */
        this.current = false;
        /** Documents in the view but not in the remote target */
        this.limboDocuments = documentKeySet();
        /** Document Keys that have local changes */
        this.mutatedKeys = documentKeySet();
        this.documentSet = new document_set_DocumentSet(query.docComparator.bind(query));
    }
    /**
     * Iterates over a set of doc changes, applies the query limit, and computes
     * what the new results should be, what the changes were, and whether we may
     * need to go back to the local cache for more results. Does not make any
     * changes to the view.
     * @param docChanges The doc changes to apply to this view.
     * @param previousChanges If this is being called with a refill, then start
     *        with this set of docs and changes instead of the current view.
     * @return a new set of docs, changes, and refill flag.
     */
    View.prototype.computeDocChanges = function (docChanges, previousChanges) {
        var _this = this;
        var changeSet = previousChanges ? previousChanges.changeSet : new view_snapshot_DocumentChangeSet();
        var oldDocumentSet = previousChanges ? previousChanges.documentSet : this.documentSet;
        var newMutatedKeys = previousChanges ? previousChanges.mutatedKeys : this.mutatedKeys;
        var newDocumentSet = oldDocumentSet;
        var needsRefill = false;
        // Track the last doc in a (full) limit. This is necessary, because some
        // update (a delete, or an update moving a doc past the old limit) might
        // mean there is some other document in the local cache that either should
        // come (1) between the old last limit doc and the new last document, in the
        // case of updates, or (2) after the new last document, in the case of
        // deletes. So we keep this doc at the old limit to compare the updates to.
        //
        // Note that this should never get used in a refill (when previousChanges is
        // set), because there will only be adds -- no deletes or updates.
        var lastDocInLimit = this.query.hasLimit() && oldDocumentSet.size === this.query.limit ? oldDocumentSet.last() : null;
        docChanges.inorderTraversal(function (key, newMaybeDoc) {
            var oldDoc = oldDocumentSet.get(key);
            var newDoc = newMaybeDoc instanceof document_Document ? newMaybeDoc : null;
            if (newDoc) {
                assert_assert(key.equals(newDoc.key), 'Mismatching keys found in document changes: ' + key + ' != ' + newDoc.key);
                newDoc = _this.query.matches(newDoc) ? newDoc : null;
            }
            if (newDoc) {
                newDocumentSet = newDocumentSet.add(newDoc);
                if (newDoc.hasLocalMutations) {
                    newMutatedKeys = newMutatedKeys.add(key);
                } else {
                    newMutatedKeys = newMutatedKeys.delete(key);
                }
            } else {
                newDocumentSet = newDocumentSet.delete(key);
                newMutatedKeys = newMutatedKeys.delete(key);
            }
            // Calculate change
            if (oldDoc && newDoc) {
                var docsEqual = oldDoc.data.equals(newDoc.data);
                if (!docsEqual || oldDoc.hasLocalMutations !== newDoc.hasLocalMutations) {
                    // only report a change if document actually changed
                    if (docsEqual) {
                        changeSet.track({ type: ChangeType.Metadata, doc: newDoc });
                    } else {
                        changeSet.track({ type: ChangeType.Modified, doc: newDoc });
                    }
                    if (lastDocInLimit && _this.query.docComparator(newDoc, lastDocInLimit) > 0) {
                        // This doc moved from inside the limit to after the limit.
                        // That means there may be some doc in the local cache that's
                        // actually less than this one.
                        needsRefill = true;
                    }
                }
            } else if (!oldDoc && newDoc) {
                changeSet.track({ type: ChangeType.Added, doc: newDoc });
            } else if (oldDoc && !newDoc) {
                changeSet.track({ type: ChangeType.Removed, doc: oldDoc });
                if (lastDocInLimit) {
                    // A doc was removed from a full limit query. We'll need to
                    // requery from the local cache to see if we know about some other
                    // doc that should be in the results.
                    needsRefill = true;
                }
            }
        });
        if (this.query.hasLimit()) {
            // TODO(klimt): Make DocumentSet size be constant time.
            while (newDocumentSet.size > this.query.limit) {
                var oldDoc = newDocumentSet.last();
                newDocumentSet = newDocumentSet.delete(oldDoc.key);
                changeSet.track({ type: ChangeType.Removed, doc: oldDoc });
            }
        }
        assert_assert(!needsRefill || !previousChanges, 'View was refilled using docs that themselves needed refilling.');
        return {
            documentSet: newDocumentSet,
            changeSet: changeSet,
            needsRefill: needsRefill,
            mutatedKeys: newMutatedKeys
        };
    };
    /**
     * Updates the view with the given ViewDocumentChanges and updates limbo docs
     * and sync state from the given (optional) target change.
     * @param docChanges The set of changes to make to the view's docs.
     * @param targetChange A target change to apply for computing limbo docs and
     *        sync state.
     * @return A new ViewChange with the given docs, changes, and sync state.
     */
    View.prototype.applyChanges = function (docChanges, targetChange) {
        var _this = this;
        assert_assert(!docChanges.needsRefill, 'Cannot apply changes that need a refill');
        var oldDocs = this.documentSet;
        this.documentSet = docChanges.documentSet;
        this.mutatedKeys = docChanges.mutatedKeys;
        // Sort changes based on type and query comparator
        var changes = docChanges.changeSet.getChanges();
        changes.sort(function (c1, c2) {
            return compareChangeType(c1.type, c2.type) || _this.query.docComparator(c1.doc, c2.doc);
        });
        var limboChanges = this.applyTargetChange(targetChange);
        var synced = this.limboDocuments.size === 0 && this.current;
        var newSyncState = synced ? SyncState.Synced : SyncState.Local;
        var syncStateChanged = newSyncState !== this.syncState;
        this.syncState = newSyncState;
        if (changes.length === 0 && !syncStateChanged) {
            // no changes
            return { limboChanges: limboChanges };
        } else {
            return {
                snapshot: {
                    query: this.query,
                    docs: docChanges.documentSet,
                    oldDocs: oldDocs,
                    docChanges: changes,
                    fromCache: newSyncState === SyncState.Local,
                    syncStateChanged: syncStateChanged,
                    hasPendingWrites: !docChanges.mutatedKeys.isEmpty()
                },
                limboChanges: limboChanges
            };
        }
    };
    /**
     * Returns whether the doc for the given key should be in limbo.
     */
    View.prototype.shouldBeInLimbo = function (key) {
        // If the remote end says it's part of this query, it's not in limbo.
        if (this.syncedDocuments.has(key)) {
            return false;
        }
        // The local store doesn't think it's a result, so it shouldn't be in limbo.
        if (!this.documentSet.has(key)) {
            return false;
        }
        // If there are local changes to the doc, they might explain why the server
        // doesn't know that it's part of the query. So don't put it in limbo.
        // TODO(klimt): Ideally, we would only consider changes that might actually
        // affect this specific query.
        if (this.documentSet.get(key).hasLocalMutations) {
            return false;
        }
        // Everything else is in limbo.
        return true;
    };
    /**
     * Updates syncedDocuments, current, and limbo docs based on the given change.
     * Returns the list of changes to which docs are in limbo.
     */
    View.prototype.applyTargetChange = function (targetChange) {
        var _this = this;
        if (targetChange) {
            var targetMapping = targetChange.mapping;
            if (targetMapping instanceof ResetMapping) {
                this.syncedDocuments = targetMapping.documents;
            } else if (targetMapping instanceof UpdateMapping) {
                this.syncedDocuments = targetMapping.applyToKeySet(this.syncedDocuments);
            }
            switch (targetChange.currentStatusUpdate) {
                case CurrentStatusUpdate.MarkCurrent:
                    this.current = true;
                    break;
                case CurrentStatusUpdate.MarkNotCurrent:
                    this.current = false;
                    break;
                case CurrentStatusUpdate.None:
                    break;
                default:
                    fail('Unknown current status update: ' + targetChange.currentStatusUpdate);
            }
        }
        // Recompute the set of limbo docs.
        // TODO(klimt): Do this incrementally so that it's not quadratic when
        // updating many documents.
        var oldLimboDocuments = this.limboDocuments;
        this.limboDocuments = documentKeySet();
        if (this.current) {
            this.documentSet.forEach(function (doc) {
                if (_this.shouldBeInLimbo(doc.key)) {
                    _this.limboDocuments = _this.limboDocuments.add(doc.key);
                }
            });
        }
        // Diff the new limbo docs with the old limbo docs.
        var changes = [];
        oldLimboDocuments.forEach(function (key) {
            if (!_this.limboDocuments.has(key)) {
                changes.push(new RemovedLimboDocument(key));
            }
        });
        this.limboDocuments.forEach(function (key) {
            if (!oldLimboDocuments.has(key)) {
                changes.push(new AddedLimboDocument(key));
            }
        });
        return changes;
    };
    return View;
}();

function compareChangeType(c1, c2) {
    var order = function order(change) {
        switch (change) {
            case ChangeType.Added:
                return 1;
            case ChangeType.Modified:
                return 2;
            case ChangeType.Metadata:
                // A metadata change is converted to a modified change at the public
                // api layer.  Since we sort by document key and then change type,
                // metadata and modified changes must be sorted equivalently.
                return 2;
            case ChangeType.Removed:
                return 0;
            default:
                return fail('Unknown ChangeType: ' + change);
        }
    };
    return order(c1) - order(c2);
}

//# sourceMappingURL=view.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/core/sync_engine.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


















var sync_engine_LOG_TAG = 'SyncEngine';
/**
 * QueryView contains all of the data that SyncEngine needs to keep track of for
 * a particular query.
 */
var QueryView = /** @class */function () {
    function QueryView(
    /**
     * The query itself.
     */
    query,
    /**
     * The target number created by the client that is used in the watch
     * stream to identify this query.
     */
    targetId,
    /**
     * An identifier from the datastore backend that indicates the last state
     * of the results that was received. This can be used to indicate where
     * to continue receiving new doc changes for the query.
     */
    resumeToken,
    /**
     * The view is responsible for computing the final merged truth of what
     * docs are in the query. It gets notified of local and remote changes,
     * and applies the query filters and limits to determine the most correct
     * possible results.
     */
    view) {
        this.query = query;
        this.targetId = targetId;
        this.resumeToken = resumeToken;
        this.view = view;
    }
    return QueryView;
}();
/**
 * SyncEngine is the central controller in the client SDK architecture. It is
 * the glue code between the EventManager, LocalStore, and RemoteStore. Some of
 * SyncEngine's responsibilities include:
 * 1. Coordinating client requests and remote events between the EventManager
 *    and the local and remote data stores.
 * 2. Managing a View object for each query, providing the unified view between
 *    the local and remote data stores.
 * 3. Notifying the RemoteStore when the LocalStore has new mutations in its
 *    queue that need sending to the backend.
 *
 * The SyncEngine’s methods should only ever be called by methods running in the
 * global async queue.
 */
var sync_engine_SyncEngine = /** @class */function () {
    function SyncEngine(localStore, remoteStore, currentUser) {
        this.localStore = localStore;
        this.remoteStore = remoteStore;
        this.currentUser = currentUser;
        this.viewHandler = null;
        this.errorHandler = null;
        this.queryViewsByQuery = new obj_map_ObjectMap(function (q) {
            return q.canonicalId();
        });
        this.queryViewsByTarget = {};
        this.limboTargetsByKey = new sorted_map_SortedMap(document_key_DocumentKey.comparator);
        this.limboKeysByTarget = {};
        this.limboDocumentRefs = new reference_set_ReferenceSet();
        this.limboCollector = new eager_garbage_collector_EagerGarbageCollector();
        /** Stores user completion handlers, indexed by User and BatchId. */
        this.mutationUserCallbacks = {};
        this.targetIdGenerator = TargetIdGenerator.forSyncEngine();
    }
    /** Subscribes view and error handler. Can be called only once. */
    SyncEngine.prototype.subscribe = function (viewHandler, errorHandler) {
        assert_assert(viewHandler !== null && errorHandler !== null, 'View and error handlers cannot be null');
        assert_assert(this.viewHandler === null && this.errorHandler === null, 'SyncEngine already has a subscriber.');
        this.viewHandler = viewHandler;
        this.errorHandler = errorHandler;
        this.limboCollector.addGarbageSource(this.limboDocumentRefs);
    };
    /**
     * Initiates the new listen, resolves promise when listen enqueued to the
     * server. All the subsequent view snapshots or errors are sent to the
     * subscribed handlers. Returns the targetId of the query.
     */
    SyncEngine.prototype.listen = function (query) {
        var _this = this;
        this.assertSubscribed('listen()');
        assert_assert(!this.queryViewsByQuery.has(query), 'We already listen to the query: ' + query);
        return this.localStore.allocateQuery(query).then(function (queryData) {
            return _this.localStore.executeQuery(query).then(function (docs) {
                return _this.localStore.remoteDocumentKeys(queryData.targetId).then(function (remoteKeys) {
                    var view = new view_View(query, remoteKeys);
                    var viewDocChanges = view.computeDocChanges(docs);
                    var viewChange = view.applyChanges(viewDocChanges);
                    assert_assert(viewChange.limboChanges.length === 0, 'View returned limbo docs before target ack from the server.');
                    assert_assert(!!viewChange.snapshot, 'applyChanges for new view should always return a snapshot');
                    var data = new QueryView(query, queryData.targetId, queryData.resumeToken, view);
                    _this.queryViewsByQuery.set(query, data);
                    _this.queryViewsByTarget[queryData.targetId] = data;
                    _this.viewHandler([viewChange.snapshot]);
                    _this.remoteStore.listen(queryData);
                });
            }).then(function () {
                return queryData.targetId;
            });
        });
    };
    /** Stops listening to the query. */
    SyncEngine.prototype.unlisten = function (query) {
        var _this = this;
        this.assertSubscribed('unlisten()');
        var queryView = this.queryViewsByQuery.get(query);
        assert_assert(!!queryView, 'Trying to unlisten on query not found:' + query);
        return this.localStore.releaseQuery(query).then(function () {
            _this.remoteStore.unlisten(queryView.targetId);
            return _this.removeAndCleanupQuery(queryView).then(function () {
                return _this.localStore.collectGarbage();
            });
        });
    };
    /**
     * Initiates the write of local mutation batch which involves adding the
     * writes to the mutation queue, notifying the remote store about new
     * mutations and raising events for any changes this write caused.
     *
     * The promise returned by this call is resolved when the above steps
     * have completed, *not* when the write was acked by the backend. The
     * userCallback is resolved once the write was acked/rejected by the
     * backend (or failed locally for any other reason).
     */
    SyncEngine.prototype.write = function (batch, userCallback) {
        var _this = this;
        this.assertSubscribed('write()');
        return this.localStore.localWrite(batch).then(function (result) {
            _this.addMutationCallback(result.batchId, userCallback);
            return _this.emitNewSnapsAndNotifyLocalStore(result.changes);
        }).then(function () {
            return _this.remoteStore.fillWritePipeline();
        });
    };
    // TODO(klimt): Wrap the given error in a standard Firestore error object.
    SyncEngine.prototype.wrapUpdateFunctionError = function (error) {
        return error;
    };
    /**
     * Takes an updateFunction in which a set of reads and writes can be performed
     * atomically. In the updateFunction, the client can read and write values
     * using the supplied transaction object. After the updateFunction, all
     * changes will be committed. If some other client has changed any of the data
     * referenced, then the updateFunction will be called again. If the
     * updateFunction still fails after the given number of retries, then the
     * transaction will be rejection.
     *
     * The transaction object passed to the updateFunction contains methods for
     * accessing documents and collections. Unlike other datastore access, data
     * accessed with the transaction will not reflect local changes that have not
     * been committed. For this reason, it is required that all reads are
     * performed before any writes. Transactions must be performed while online.
     *
     * The promise returned is resolved when the transaction is fully committed.
     */
    SyncEngine.prototype.runTransaction = function (updateFunction, retries) {
        var _this = this;
        if (retries === void 0) {
            retries = 5;
        }
        assert_assert(retries >= 0, 'Got negative number of retries for transaction.');
        var transaction = this.remoteStore.createTransaction();
        var wrappedUpdateFunction = function wrappedUpdateFunction() {
            try {
                var userPromise = updateFunction(transaction);
                if (isNullOrUndefined(userPromise) || !userPromise.catch || !userPromise.then) {
                    return Promise.reject(Error('Transaction callback must return a Promise'));
                }
                return userPromise.catch(function (e) {
                    return Promise.reject(_this.wrapUpdateFunctionError(e));
                });
            } catch (e) {
                return Promise.reject(_this.wrapUpdateFunctionError(e));
            }
        };
        return wrappedUpdateFunction().then(function (result) {
            return transaction.commit().then(function () {
                return result;
            }).catch(function (error) {
                if (retries === 0) {
                    return Promise.reject(error);
                }
                // TODO(klimt): Put in a retry delay?
                return _this.runTransaction(updateFunction, retries - 1);
            });
        });
    };
    SyncEngine.prototype.applyRemoteEvent = function (remoteEvent) {
        var _this = this;
        this.assertSubscribed('applyRemoteEvent()');
        // Make sure limbo documents are deleted if there were no results
        forEachNumber(remoteEvent.targetChanges, function (targetId, targetChange) {
            var limboKey = _this.limboKeysByTarget[targetId];
            if (limboKey && targetChange.currentStatusUpdate === CurrentStatusUpdate.MarkCurrent && !remoteEvent.documentUpdates.get(limboKey)) {
                // When listening to a query the server responds with a snapshot
                // containing documents matching the query and a current marker
                // telling us we're now in sync. It's possible for these to arrive
                // as separate remote events or as a single remote event.
                // For a document query, there will be no documents sent in the
                // response if the document doesn't exist.
                //
                // If the snapshot arrives separately from the current marker,
                // we handle it normally and updateTrackedLimbos will resolve the
                // limbo status of the document, removing it from limboDocumentRefs.
                // This works because clients only initiate limbo resolution when
                // a target is current and because all current targets are
                // always at a consistent snapshot.
                //
                // However, if the document doesn't exist and the current marker
                // arrives, the document is not present in the snapshot and our
                // normal view handling would consider the document to remain in
                // limbo indefinitely because there are no updates to the document.
                // To avoid this, we specially handle this just this case here:
                // synthesizing a delete.
                //
                // TODO(dimond): Ideally we would have an explicit lookup query
                // instead resulting in an explicit delete message and we could
                // remove this special logic.
                remoteEvent.addDocumentUpdate(new document_NoDocument(limboKey, remoteEvent.snapshotVersion));
            }
        });
        return this.localStore.applyRemoteEvent(remoteEvent).then(function (changes) {
            return _this.emitNewSnapsAndNotifyLocalStore(changes, remoteEvent);
        });
    };
    SyncEngine.prototype.rejectListen = function (targetId, err) {
        var _this = this;
        this.assertSubscribed('rejectListens()');
        var limboKey = this.limboKeysByTarget[targetId];
        if (limboKey) {
            // Since this query failed, we won't want to manually unlisten to it.
            // So go ahead and remove it from bookkeeping.
            this.limboTargetsByKey = this.limboTargetsByKey.remove(limboKey);
            delete this.limboKeysByTarget[targetId];
            // TODO(klimt): We really only should do the following on permission
            // denied errors, but we don't have the cause code here.
            // It's a limbo doc. Create a synthetic event saying it was deleted.
            // This is kind of a hack. Ideally, we would have a method in the local
            // store to purge a document. However, it would be tricky to keep all of
            // the local store's invariants with another method.
            var docMap = new sorted_map_SortedMap(document_key_DocumentKey.comparator);
            docMap = docMap.insert(limboKey, new document_NoDocument(limboKey, snapshot_version_SnapshotVersion.forDeletedDoc()));
            var event_1 = new remote_event_RemoteEvent(snapshot_version_SnapshotVersion.MIN, {}, docMap);
            return this.applyRemoteEvent(event_1);
        } else {
            var queryView_1 = this.queryViewsByTarget[targetId];
            assert_assert(!!queryView_1, 'Unknown targetId: ' + targetId);
            return this.localStore.releaseQuery(queryView_1.query).then(function () {
                return _this.removeAndCleanupQuery(queryView_1).then(function () {
                    _this.errorHandler(queryView_1.query, err);
                });
            });
        }
    };
    SyncEngine.prototype.applySuccessfulWrite = function (mutationBatchResult) {
        var _this = this;
        this.assertSubscribed('applySuccessfulWrite()');
        // The local store may or may not be able to apply the write result and
        // raise events immediately (depending on whether the watcher is caught
        // up), so we raise user callbacks first so that they consistently happen
        // before listen events.
        this.processUserCallback(mutationBatchResult.batch.batchId,
        /*error=*/null);
        return this.localStore.acknowledgeBatch(mutationBatchResult).then(function (changes) {
            return _this.emitNewSnapsAndNotifyLocalStore(changes);
        });
    };
    SyncEngine.prototype.rejectFailedWrite = function (batchId, error) {
        var _this = this;
        this.assertSubscribed('rejectFailedWrite()');
        // The local store may or may not be able to apply the write result and
        // raise events immediately (depending on whether the watcher is caught up),
        // so we raise user callbacks first so that they consistently happen before
        // listen events.
        this.processUserCallback(batchId, error);
        return this.localStore.rejectBatch(batchId).then(function (changes) {
            return _this.emitNewSnapsAndNotifyLocalStore(changes);
        });
    };
    SyncEngine.prototype.addMutationCallback = function (batchId, callback) {
        var newCallbacks = this.mutationUserCallbacks[this.currentUser.toKey()];
        if (!newCallbacks) {
            newCallbacks = new sorted_map_SortedMap(primitiveComparator);
        }
        newCallbacks = newCallbacks.insert(batchId, callback);
        this.mutationUserCallbacks[this.currentUser.toKey()] = newCallbacks;
    };
    /**
     * Resolves or rejects the user callback for the given batch and then discards
     * it.
     */
    SyncEngine.prototype.processUserCallback = function (batchId, error) {
        var newCallbacks = this.mutationUserCallbacks[this.currentUser.toKey()];
        // NOTE: Mutations restored from persistence won't have callbacks, so it's
        // okay for there to be no callback for this ID.
        if (newCallbacks) {
            var callback = newCallbacks.get(batchId);
            if (callback) {
                assert_assert(batchId === newCallbacks.minKey(), 'Mutation callbacks processed out-of-order?');
                if (error) {
                    callback.reject(error);
                } else {
                    callback.resolve();
                }
                newCallbacks = newCallbacks.remove(batchId);
            }
            this.mutationUserCallbacks[this.currentUser.toKey()] = newCallbacks;
        }
    };
    SyncEngine.prototype.removeAndCleanupQuery = function (queryView) {
        this.queryViewsByQuery.delete(queryView.query);
        delete this.queryViewsByTarget[queryView.targetId];
        this.limboDocumentRefs.removeReferencesForId(queryView.targetId);
        return this.gcLimboDocuments();
    };
    SyncEngine.prototype.updateTrackedLimbos = function (targetId, limboChanges) {
        for (var _i = 0, limboChanges_1 = limboChanges; _i < limboChanges_1.length; _i++) {
            var limboChange = limboChanges_1[_i];
            if (limboChange instanceof AddedLimboDocument) {
                this.limboDocumentRefs.addReference(limboChange.key, targetId);
                this.trackLimboChange(limboChange);
            } else if (limboChange instanceof RemovedLimboDocument) {
                debug(sync_engine_LOG_TAG, 'Document no longer in limbo: ' + limboChange.key);
                this.limboDocumentRefs.removeReference(limboChange.key, targetId);
            } else {
                fail('Unknown limbo change: ' + JSON.stringify(limboChange));
            }
        }
        return this.gcLimboDocuments();
    };
    SyncEngine.prototype.trackLimboChange = function (limboChange) {
        var key = limboChange.key;
        if (!this.limboTargetsByKey.get(key)) {
            debug(sync_engine_LOG_TAG, 'New document in limbo: ' + key);
            var limboTargetId = this.targetIdGenerator.next();
            var query = query_Query.atPath(key.path);
            this.limboKeysByTarget[limboTargetId] = key;
            this.remoteStore.listen(new query_data_QueryData(query, limboTargetId, QueryPurpose.Listen));
            this.limboTargetsByKey = this.limboTargetsByKey.insert(key, limboTargetId);
        }
    };
    SyncEngine.prototype.gcLimboDocuments = function () {
        var _this = this;
        // HACK: We can use a null transaction here, because we know that the
        // reference set is entirely within memory and doesn't need a store engine.
        return this.limboCollector.collectGarbage(null).next(function (keys) {
            keys.forEach(function (key) {
                var limboTargetId = _this.limboTargetsByKey.get(key);
                if (limboTargetId === null) {
                    // This target already got removed, because the query failed.
                    return;
                }
                _this.remoteStore.unlisten(limboTargetId);
                _this.limboTargetsByKey = _this.limboTargetsByKey.remove(key);
                delete _this.limboKeysByTarget[limboTargetId];
            });
        }).toPromise();
    };
    // Visible for testing
    SyncEngine.prototype.currentLimboDocs = function () {
        return this.limboTargetsByKey;
    };
    SyncEngine.prototype.emitNewSnapsAndNotifyLocalStore = function (changes, remoteEvent) {
        var _this = this;
        var newSnaps = [];
        var docChangesInAllViews = [];
        var queriesProcessed = [];
        this.queryViewsByQuery.forEach(function (_, queryView) {
            queriesProcessed.push(Promise.resolve().then(function () {
                var viewDocChanges = queryView.view.computeDocChanges(changes);
                if (!viewDocChanges.needsRefill) {
                    return viewDocChanges;
                }
                // The query has a limit and some docs were removed, so we need
                // to re-run the query against the local store to make sure we
                // didn't lose any good docs that had been past the limit.
                return _this.localStore.executeQuery(queryView.query).then(function (docs) {
                    return queryView.view.computeDocChanges(docs, viewDocChanges);
                });
            }).then(function (viewDocChanges) {
                var targetChange = remoteEvent && remoteEvent.targetChanges[queryView.targetId];
                var viewChange = queryView.view.applyChanges(viewDocChanges, targetChange);
                return _this.updateTrackedLimbos(queryView.targetId, viewChange.limboChanges).then(function () {
                    if (viewChange.snapshot) {
                        newSnaps.push(viewChange.snapshot);
                        var docChanges = local_view_changes_LocalViewChanges.fromSnapshot(viewChange.snapshot);
                        docChangesInAllViews.push(docChanges);
                    }
                });
            }));
        });
        return Promise.all(queriesProcessed).then(function () {
            _this.viewHandler(newSnaps);
            return _this.localStore.notifyLocalViewChanges(docChangesInAllViews);
        }).then(function () {
            return _this.localStore.collectGarbage();
        });
    };
    SyncEngine.prototype.assertSubscribed = function (fnName) {
        assert_assert(this.viewHandler !== null && this.errorHandler !== null, 'Trying to call ' + fnName + ' before calling subscribe().');
    };
    SyncEngine.prototype.handleUserChange = function (user) {
        var _this = this;
        this.currentUser = user;
        return this.localStore.handleUserChange(user).then(function (changes) {
            return _this.emitNewSnapsAndNotifyLocalStore(changes);
        }).then(function () {
            return _this.remoteStore.handleUserChange(user);
        });
    };
    return SyncEngine;
}();


//# sourceMappingURL=sync_engine.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/model/mutation_batch.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var BATCHID_UNKNOWN = -1;
/**
 * A batch of mutations that will be sent as one unit to the backend.
 */
var mutation_batch_MutationBatch = /** @class */function () {
    function MutationBatch(batchId, localWriteTime, mutations) {
        this.batchId = batchId;
        this.localWriteTime = localWriteTime;
        this.mutations = mutations;
    }
    /**
     * Applies all the mutations in this MutationBatch to the specified document
     * to create a new remote document
     *
     * @param docKey The key of the document to apply mutations to.
     * @param maybeDoc The document to apply mutations to.
     * @param batchResult The result of applying the MutationBatch to the
     * backend.
     */
    MutationBatch.prototype.applyToRemoteDocument = function (docKey, maybeDoc, batchResult) {
        if (maybeDoc) {
            assert_assert(maybeDoc.key.equals(docKey), "applyToRemoteDocument: key " + docKey + " should match maybeDoc key\n        " + maybeDoc.key);
        }
        var mutationResults = batchResult.mutationResults;
        assert_assert(mutationResults.length === this.mutations.length, "Mismatch between mutations length\n      (" + this.mutations.length + ") and mutation results length\n      (" + mutationResults.length + ").");
        for (var i = 0; i < this.mutations.length; i++) {
            var mutation = this.mutations[i];
            if (mutation.key.equals(docKey)) {
                var mutationResult = mutationResults[i];
                maybeDoc = mutation.applyToRemoteDocument(maybeDoc, mutationResult);
            }
        }
        return maybeDoc;
    };
    /**
     * Computes the local view of a document given all the mutations in this
     * batch.
     *
     * @param docKey The key of the document to apply mutations to.
     * @param maybeDoc The document to apply mutations to.
     */
    MutationBatch.prototype.applyToLocalView = function (docKey, maybeDoc) {
        if (maybeDoc) {
            assert_assert(maybeDoc.key.equals(docKey), "applyToLocalDocument: key " + docKey + " should match maybeDoc key\n        " + maybeDoc.key);
        }
        for (var i = 0; i < this.mutations.length; i++) {
            var mutation = this.mutations[i];
            if (mutation.key.equals(docKey)) {
                maybeDoc = mutation.applyToLocalView(maybeDoc, this.localWriteTime);
            }
        }
        return maybeDoc;
    };
    MutationBatch.prototype.keys = function () {
        var keySet = documentKeySet();
        for (var _i = 0, _a = this.mutations; _i < _a.length; _i++) {
            var mutation = _a[_i];
            keySet = keySet.add(mutation.key);
        }
        return keySet;
    };
    MutationBatch.prototype.equals = function (other) {
        return this.batchId === other.batchId && arrayEquals(this.mutations, other.mutations);
    };
    /**
     * Returns true if this mutation batch has already been removed from the
     * mutation queue.
     *
     * Note that not all implementations of the MutationQueue necessarily use
     * tombstones as part of their implementation and generally speaking no code
     * outside the mutation queues should really care about this.
     */
    MutationBatch.prototype.isTombstone = function () {
        return this.mutations.length === 0;
    };
    /** Converts this batch into a tombstone */
    MutationBatch.prototype.toTombstone = function () {
        return new MutationBatch(this.batchId, this.localWriteTime, []);
    };
    return MutationBatch;
}();

/** The result of applying a mutation batch to the backend. */
var mutation_batch_MutationBatchResult = /** @class */function () {
    function MutationBatchResult(batch, commitVersion, mutationResults, streamToken,
    /**
     * A pre-computed mapping from each mutated document to the resulting
     * version.
     */
    docVersions) {
        this.batch = batch;
        this.commitVersion = commitVersion;
        this.mutationResults = mutationResults;
        this.streamToken = streamToken;
        this.docVersions = docVersions;
    }
    /**
     * Creates a new MutationBatchResult for the given batch and results. There
     * must be one result for each mutation in the batch. This static factory
     * caches a document=>version mapping (docVersions).
     */
    MutationBatchResult.from = function (batch, commitVersion, results, streamToken) {
        assert_assert(batch.mutations.length === results.length, 'Mutations sent ' + batch.mutations.length + ' must equal results received ' + results.length);
        var versionMap = documentVersionMap();
        var mutations = batch.mutations;
        for (var i = 0; i < mutations.length; i++) {
            var version = results[i].version;
            if (version === null) {
                // deletes don't have a version, so we substitute the commitVersion
                // of the entire batch.
                version = commitVersion;
            }
            versionMap = versionMap.insert(mutations[i].key, version);
        }
        return new MutationBatchResult(batch, commitVersion, results, streamToken, versionMap);
    };
    return MutationBatchResult;
}();


//# sourceMappingURL=mutation_batch.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/local/encoded_resource_path.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var escapeChar = '\x01';
var encodedSeparatorChar = '\x01';
var encodedNul = '\x10';
var encodedEscape = '\x11';
/**
 * Encodes a resource path into a IndexedDb-compatible string form.
 */
function encode(path) {
    var result = '';
    for (var i = 0; i < path.length; i++) {
        if (result.length > 0) {
            result = encodeSeparator(result);
        }
        result = encodeSegment(path.get(i), result);
    }
    return encodeSeparator(result);
}
/** Encodes a single segment of a resource path into the given result */
function encodeSegment(segment, resultBuf) {
    var result = resultBuf;
    var length = segment.length;
    for (var i = 0; i < length; i++) {
        var c = segment.charAt(i);
        switch (c) {
            case '\0':
                result += escapeChar + encodedNul;
                break;
            case escapeChar:
                result += escapeChar + encodedEscape;
                break;
            default:
                result += c;
        }
    }
    return result;
}
/** Encodes a path separator into the given result */
function encodeSeparator(result) {
    return result + escapeChar + encodedSeparatorChar;
}
/**
 * Decodes the given IndexedDb-compatible string form of a resource path into
 * a ResourcePath instance. Note that this method is not suitable for use with
 * decoding resource names from the server; those are One Platform format
 * strings.
 */
function encoded_resource_path_decode(path) {
    // Event the empty path must encode as a path of at least length 2. A path
    // with exactly 2 must be the empty path.
    var length = path.length;
    assert_assert(length >= 2, 'Invalid path ' + path);
    if (length === 2) {
        assert_assert(path.charAt(0) === escapeChar && path.charAt(1) === encodedSeparatorChar, 'Non-empty path ' + path + ' had length 2');
        return path_ResourcePath.EMPTY_PATH;
    }
    // Escape characters cannot exist past the second-to-last position in the
    // source value.
    var lastReasonableEscapeIndex = length - 2;
    var segments = [];
    var segmentBuilder = '';
    for (var start = 0; start < length;) {
        // The last two characters of a valid encoded path must be a separator, so
        // there must be an end to this segment.
        var end = path.indexOf(escapeChar, start);
        if (end < 0 || end > lastReasonableEscapeIndex) {
            fail('Invalid encoded resource path: "' + path + '"');
        }
        var next = path.charAt(end + 1);
        switch (next) {
            case encodedSeparatorChar:
                var currentPiece = path.substring(start, end);
                var segment = void 0;
                if (segmentBuilder.length === 0) {
                    // Avoid copying for the common case of a segment that excludes \0
                    // and \001
                    segment = currentPiece;
                } else {
                    segmentBuilder += currentPiece;
                    segment = segmentBuilder;
                    segmentBuilder = '';
                }
                segments.push(segment);
                break;
            case encodedNul:
                segmentBuilder += path.substring(start, end);
                segmentBuilder += '\0';
                break;
            case encodedEscape:
                // The escape character can be used in the output to encode itself.
                segmentBuilder += path.substring(start, end + 1);
                break;
            default:
                fail('Invalid encoded resource path: "' + path + '"');
        }
        start = end + 2;
    }
    return new path_ResourcePath(segments);
}
/**
 * Computes the prefix successor of the given path, computed by encode above.
 * A prefix successor is the first key that cannot be prefixed by the given
 * path. It's useful for defining the end of a prefix scan such that all keys
 * in the scan have the same prefix.
 *
 * Note that this is not a general prefix successor implementation, which is
 * tricky to get right with Strings, given that they encode down to UTF-8.
 * Instead this relies on the fact that all paths encoded by this class are
 * always terminated with a separator, and so a successor can always be
 * cheaply computed by incrementing the last character of the path.
 */
function prefixSuccessor(path) {
    var c = path.charCodeAt(path.length - 1);
    // TODO(mcg): this really should be a general thing, but not worth it right
    // now
    assert_assert(c === 1, 'successor may only operate on paths generated by encode');
    return path.substring(0, path.length - 1) + String.fromCharCode(c + 1);
}

//# sourceMappingURL=encoded_resource_path.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/local/indexeddb_schema.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var SCHEMA_VERSION = 1;
/** Performs database creation and (in the future) upgrades between versions. */
function createOrUpgradeDb(db, oldVersion) {
  assert_assert(oldVersion === 0, 'Unexpected upgrade from version ' + oldVersion);
  db.createObjectStore(DbMutationQueue.store, {
    keyPath: DbMutationQueue.keyPath
  });
  // TODO(mikelehen): Get rid of "as any" if/when TypeScript fixes their
  // types. https://github.com/Microsoft/TypeScript/issues/14322
  db.createObjectStore(
  // tslint:disable-next-line:no-any
  DbMutationBatch.store, { keyPath: DbMutationBatch.keyPath });
  var targetDocumentsStore = db.createObjectStore(
  // tslint:disable-next-line:no-any
  DbTargetDocument.store, { keyPath: DbTargetDocument.keyPath });
  targetDocumentsStore.createIndex(DbTargetDocument.documentTargetsIndex, DbTargetDocument.documentTargetsKeyPath, { unique: true });
  var targetStore = db.createObjectStore(DbTarget.store, {
    keyPath: DbTarget.keyPath
  });
  // NOTE: This is unique only because the TargetId is the suffix.
  targetStore.createIndex(DbTarget.queryTargetsIndexName, DbTarget.queryTargetsKeyPath, { unique: true });
  // NOTE: keys for these stores are specified explicitly rather than using a
  // keyPath.
  db.createObjectStore(indexeddb_schema_DbDocumentMutation.store);
  db.createObjectStore(DbRemoteDocument.store);
  db.createObjectStore(DbOwner.store);
  db.createObjectStore(DbTargetGlobal.store);
}
/**
 * Wrapper class to store timestamps (seconds and nanos) in IndexedDb objects.
 */
var DbTimestamp = /** @class */function () {
  function DbTimestamp(seconds, nanos) {
    this.seconds = seconds;
    this.nanos = nanos;
  }
  return DbTimestamp;
}();

/**
 * A singleton object to be stored in the 'owner' store in IndexedDb.
 *
 * A given database can be owned by a single tab at a given time. That tab
 * must validate that it is still the owner before every write operation and
 * should regularly write an updated timestamp to prevent other tabs from
 * "stealing" ownership of the db.
 */
var DbOwner = /** @class */function () {
  function DbOwner(ownerId, leaseTimestampMs) {
    this.ownerId = ownerId;
    this.leaseTimestampMs = leaseTimestampMs;
  }
  /** Name of the IndexedDb object store. */
  DbOwner.store = 'owner';
  return DbOwner;
}();

/**
 * An object to be stored in the 'mutationQueues' store in IndexedDb.
 *
 * Each user gets a single queue of MutationBatches to apply to the server.
 * DbMutationQueue tracks the metadata about the queue.
 */
var DbMutationQueue = /** @class */function () {
  function DbMutationQueue(
  /**
   * The normalized user ID to which this queue belongs.
   */
  userId,
  /**
   * An identifier for the highest numbered batch that has been acknowledged
   * by the server. All MutationBatches in this queue with batchIds less
   * than or equal to this value are considered to have been acknowledged by
   * the server.
   */
  lastAcknowledgedBatchId,
  /**
   * A stream token that was previously sent by the server.
   *
   * See StreamingWriteRequest in datastore.proto for more details about
   * usage.
   *
   * After sending this token, earlier tokens may not be used anymore so
   * only a single stream token is retained.
   */
  lastStreamToken) {
    this.userId = userId;
    this.lastAcknowledgedBatchId = lastAcknowledgedBatchId;
    this.lastStreamToken = lastStreamToken;
  }
  /** Name of the IndexedDb object store.  */
  DbMutationQueue.store = 'mutationQueues';
  /** Keys are automatically assigned via the userId property. */
  DbMutationQueue.keyPath = 'userId';
  return DbMutationQueue;
}();

/**
 * An object to be stored in the 'mutations' store in IndexedDb.
 *
 * Represents a batch of user-level mutations intended to be sent to the server
 * in a single write. Each user-level batch gets a separate DbMutationBatch
 * with a new batchId.
 */
var DbMutationBatch = /** @class */function () {
  function DbMutationBatch(
  /**
   * The normalized user ID to which this batch belongs.
   */
  userId,
  /**
   * An identifier for this batch, allocated by the mutation queue in a
   * monotonically increasing manner.
   */
  batchId,
  /**
   * The local write time of the batch, stored as milliseconds since the
   * epoch.
   */
  localWriteTimeMs,
  /**
   * A list of mutations to apply. All mutations will be applied atomically.
   *
   * Mutations are serialized via JsonProtoSerializer.toMutation().
   */
  mutations) {
    this.userId = userId;
    this.batchId = batchId;
    this.localWriteTimeMs = localWriteTimeMs;
    this.mutations = mutations;
  }
  /** Name of the IndexedDb object store.  */
  DbMutationBatch.store = 'mutations';
  /** Keys are automatically assigned via the userId, batchId properties. */
  DbMutationBatch.keyPath = ['userId', 'batchId'];
  return DbMutationBatch;
}();

/**
 * An object to be stored in the 'documentMutations' store in IndexedDb.
 *
 * A manually maintained index of all the mutation batches that affect a given
 * document key. The rows in this table are references based on the contents of
 * DbMutationBatch.mutations.
 */
var indexeddb_schema_DbDocumentMutation = /** @class */function () {
  function DbDocumentMutation() {}
  /**
   * Creates a [userId] key for use in the DbDocumentMutations index to iterate
   * over all of a user's document mutations.
   */
  DbDocumentMutation.prefixForUser = function (userId) {
    return [userId];
  };
  /**
   * Creates a [userId, encodedPath] key for use in the DbDocumentMutations
   * index to iterate over all at document mutations for a given path or lower.
   */
  DbDocumentMutation.prefixForPath = function (userId, path) {
    return [userId, encode(path)];
  };
  /**
   * Creates a full index key of [userId, encodedPath, batchId] for inserting
   * and deleting into the DbDocumentMutations index.
   */
  DbDocumentMutation.key = function (userId, path, batchId) {
    return [userId, encode(path), batchId];
  };
  DbDocumentMutation.store = 'documentMutations';
  /**
   * Because we store all the useful information for this store in the key,
   * there is no useful information to store as the value. The raw (unencoded)
   * path cannot be stored because IndexedDb doesn't store prototype
   * information.
   */
  DbDocumentMutation.PLACEHOLDER = new DbDocumentMutation();
  return DbDocumentMutation;
}();

/**
 * Represents the known absence of a document at a particular version.
 * Stored in IndexedDb as part of a DbRemoteDocument object.
 */
var DbNoDocument = /** @class */function () {
  function DbNoDocument(path, readTime) {
    this.path = path;
    this.readTime = readTime;
  }
  return DbNoDocument;
}();

/**
 * An object to be stored in the 'remoteDocuments' store in IndexedDb. It
 * represents either a cached document (if it exists) or a cached "no-document"
 * (if it is known to not exist).
 *
 * Note: This is the persisted equivalent of a MaybeDocument and could perhaps
 * be made more general if necessary.
 */
var DbRemoteDocument = /** @class */function () {
  function DbRemoteDocument(
  /**
   * Set to an instance of a DbNoDocument if it is known that no document
   * exists.
   */
  noDocument,
  /**
   * Set to an instance of a Document if there's a cached version of the
   * document.
   */
  document) {
    this.noDocument = noDocument;
    this.document = document;
  }
  DbRemoteDocument.store = 'remoteDocuments';
  return DbRemoteDocument;
}();

/**
 * An object to be stored in the 'targets' store in IndexedDb.
 *
 * This is based on and should be kept in sync with the proto used in the iOS
 * client.
 *
 * Each query the client listens to against the server is tracked on disk so
 * that the query can be efficiently resumed on restart.
 */
var DbTarget = /** @class */function () {
  function DbTarget(
  /**
   * An auto-generated sequential numeric identifier for the query.
   *
   * Queries are stored using their canonicalId as the key, but these
   * canonicalIds can be quite long so we additionally assign a unique
   * queryId which can be used by referenced data structures (e.g.
   * indexes) to minimize the on-disk cost.
   */
  targetId,
  /**
   * The canonical string representing this query. This is not unique.
   */
  canonicalId,
  /**
   * The last readTime received from the Watch Service for this query.
   *
   * This is the same value as TargetChange.read_time in the protos.
   */
  readTime,
  /**
   * An opaque, server-assigned token that allows watching a query to be
   * resumed after disconnecting without retransmitting all the data
   * that matches the query. The resume token essentially identifies a
   * point in time from which the server should resume sending results.
   *
   * This is related to the snapshotVersion in that the resumeToken
   * effectively also encodes that value, but the resumeToken is opaque
   * and sometimes encodes additional information.
   *
   * A consequence of this is that the resumeToken should be used when
   * asking the server to reason about where this client is in the watch
   * stream, but the client should use the snapshotVersion for its own
   * purposes.
   *
   * This is the same value as TargetChange.resume_token in the protos.
   */
  resumeToken,
  /**
   * A sequence number representing the last time this query was
   * listened to, used for garbage collection purposes.
   *
   * Conventionally this would be a timestamp value, but device-local
   * clocks are unreliable and they must be able to create new listens
   * even while disconnected. Instead this should be a monotonically
   * increasing number that's incremented on each listen call.
   *
   * This is different from the queryId since the queryId is an
   * immutable identifier assigned to the Query on first use while
   * lastListenSequenceNumber is updated every time the query is
   * listened to.
   */
  lastListenSequenceNumber,
  /**
   * The query for this target.
   *
   * Because canonical ids are not unique we must store the actual query. We
   * use the proto to have an object we can persist without having to
   * duplicate translation logic to and from a `Query` object.
   */
  query) {
    this.targetId = targetId;
    this.canonicalId = canonicalId;
    this.readTime = readTime;
    this.resumeToken = resumeToken;
    this.lastListenSequenceNumber = lastListenSequenceNumber;
    this.query = query;
  }
  DbTarget.store = 'targets';
  /** Keys are automatically assigned via the targetId property. */
  DbTarget.keyPath = 'targetId';
  /** The name of the queryTargets index. */
  DbTarget.queryTargetsIndexName = 'queryTargetsIndex';
  /**
   * The index of all canonicalIds to the targets that they match. This is not
   * a unique mapping because canonicalId does not promise a unique name for all
   * possible queries, so we append the targetId to make the mapping unique.
   */
  DbTarget.queryTargetsKeyPath = ['canonicalId', 'targetId'];
  return DbTarget;
}();

/**
 * An object representing an association between a target and a document.
 * Stored in the targetDocument object store to store the documents tracked by a
 * particular target.
 */
var DbTargetDocument = /** @class */function () {
  function DbTargetDocument(
  /**
   * The targetId identifying a target.
   */
  targetId,
  /**
   * The path to the document, as encoded in the key.
   */
  path) {
    this.targetId = targetId;
    this.path = path;
  }
  /** Name of the IndexedDb object store.  */
  DbTargetDocument.store = 'targetDocuments';
  /** Keys are automatically assigned via the targetId, path properties. */
  DbTargetDocument.keyPath = ['targetId', 'path'];
  /** The index name for the reverse index. */
  DbTargetDocument.documentTargetsIndex = 'documentTargetsIndex';
  /** We also need to create the reverse index for these properties. */
  DbTargetDocument.documentTargetsKeyPath = ['path', 'targetId'];
  return DbTargetDocument;
}();

/**
 * A record of global state tracked across all Targets, tracked separately
 * to avoid the need for extra indexes.
 *
 * This should be kept in-sync with the proto used in the iOS client.
 */
var DbTargetGlobal = /** @class */function () {
  function DbTargetGlobal(
  /**
   * The highest numbered target id across all targets.
   *
   * See DbTarget.targetId.
   */
  highestTargetId,
  /**
   * The highest numbered lastListenSequenceNumber across all targets.
   *
   * See DbTarget.lastListenSequenceNumber.
   */
  highestListenSequenceNumber,
  /**
   * A global snapshot version representing the last consistent snapshot we
   * received from the backend. This is monotonically increasing and any
   * snapshots received from the backend prior to this version (e.g. for
   * targets resumed with a resumeToken) should be suppressed (buffered)
   * until the backend has caught up to this snapshot version again. This
   * prevents our cache from ever going backwards in time.
   */
  lastRemoteSnapshotVersion) {
    this.highestTargetId = highestTargetId;
    this.highestListenSequenceNumber = highestListenSequenceNumber;
    this.lastRemoteSnapshotVersion = lastRemoteSnapshotVersion;
  }
  /**
   * The key string used for the single object that exists in the
   * DbTargetGlobal store.
   */
  DbTargetGlobal.key = 'targetGlobalKey';
  DbTargetGlobal.store = 'targetGlobal';
  return DbTargetGlobal;
}();

/**
 * The list of all IndexedDB stored used by the SDK. This is used when creating
 * transactions so that access across all stores is done atomically.
 */
var ALL_STORES = [DbMutationQueue.store, DbMutationBatch.store, indexeddb_schema_DbDocumentMutation.store, DbRemoteDocument.store, DbTarget.store, DbOwner.store, DbTargetGlobal.store, DbTargetDocument.store];

//# sourceMappingURL=indexeddb_schema.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/local/simple_db.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var simple_db_LOG_TAG = 'SimpleDb';
/**
 * Provides a wrapper around IndexedDb with a simplified interface that uses
 * Promise-like return values to chain operations. Real promises cannot be used
 * since .then() continuations are executed asynchronously (e.g. via
 * .setImmediate), which would cause IndexedDB to end the transaction.
 * See PersistencePromise for more details.
 */
var simple_db_SimpleDb = /** @class */function () {
    function SimpleDb(db) {
        this.db = db;
    }
    /** Opens the specified database, creating or upgrading it if necessary. */
    SimpleDb.openOrCreate = function (name, version, runUpgrade) {
        assert_assert(SimpleDb.isAvailable(), 'IndexedDB not supported in current environment.');
        debug(simple_db_LOG_TAG, 'Opening database:', name);
        return new persistence_promise_PersistencePromise(function (resolve, reject) {
            // TODO(mikelehen): Investigate browser compatibility.
            // https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB
            // suggests IE9 and older WebKit browsers handle upgrade
            // differently.
            var request = window.indexedDB.open(name, version);
            request.onsuccess = function (event) {
                var db = event.target.result;
                resolve(new SimpleDb(db));
            };
            request.onerror = function (event) {
                reject(event.target.error);
            };
            request.onupgradeneeded = function (event) {
                debug(simple_db_LOG_TAG, 'Database "' + name + '" requires upgrade from version:', event.oldVersion);
                // TODO(mikelehen): If/when we need to do an actual data
                // migration, we'll want to wrap db in a SimpleDb and have the
                // runUpgrade function return a PersistencePromise, since we'll
                // likely need to do async reads and writes. For now we're
                // cheating and just passing the raw IndexedDB in, since
                // createObjectStore(), etc. are synchronous.
                var db = event.target.result;
                runUpgrade(db, event.oldVersion);
            };
        }).toPromise();
    };
    /** Deletes the specified database. */
    SimpleDb.delete = function (name) {
        debug(simple_db_LOG_TAG, 'Removing database:', name);
        return wrapRequest(window.indexedDB.deleteDatabase(name)).toPromise();
    };
    /** Returns true if IndexedDB is available in the current environment. */
    SimpleDb.isAvailable = function () {
        if (typeof window === 'undefined' || window.indexedDB == null) {
            return false;
        }
        // We extensively use indexed array values and compound keys,
        // which IE and Edge do not support. However, they still have indexedDB
        // defined on the window, so we need to check for them here and make sure
        // to return that persistence is not enabled for those browsers.
        // For tracking support of this feature, see here:
        // https://developer.microsoft.com/en-us/microsoft-edge/platform/status/indexeddbarraysandmultientrysupport/
        // Check the UA string to find out the browser.
        var ua = window.navigator.userAgent;
        // IE 10
        // ua = 'Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.2; Trident/6.0)';
        // IE 11
        // ua = 'Mozilla/5.0 (Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko';
        // Edge
        // ua = 'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML,
        // like Gecko) Chrome/39.0.2171.71 Safari/537.36 Edge/12.0';
        if (ua.indexOf('MSIE ') > 0 || ua.indexOf('Trident/') > 0 || ua.indexOf('Edge/') > 0) {
            return false;
        } else {
            return true;
        }
    };
    SimpleDb.prototype.runTransaction = function (mode, objectStores, transactionFn) {
        var transaction = new simple_db_SimpleDbTransaction(this.db, mode, objectStores);
        var transactionFnResult = transactionFn(transaction).catch(function (error) {
            // Abort the transaction if there was an
            // error.
            transaction.abort();
            return persistence_promise_PersistencePromise.reject(error);
        }).toPromise();
        // Wait for the transaction to complete (i.e. IndexedDb's onsuccess event to
        // fire), but still return the original transactionFnResult back to the
        // caller.
        return transaction.completionPromise.then(function () {
            return transactionFnResult;
        });
    };
    SimpleDb.prototype.close = function () {
        this.db.close();
    };
    return SimpleDb;
}();

/**
 * A controller for iterating over a key range or index. It allows an iterate
 * callback to delete the currently-referenced object, or jump to a new key
 * within the key range or index.
 */
var IterationController = /** @class */function () {
    function IterationController(dbCursor) {
        this.dbCursor = dbCursor;
        this.shouldStop = false;
        this.nextKey = null;
    }
    Object.defineProperty(IterationController.prototype, "isDone", {
        get: function get() {
            return this.shouldStop;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IterationController.prototype, "skipToKey", {
        get: function get() {
            return this.nextKey;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IterationController.prototype, "cursor", {
        set: function set(value) {
            this.dbCursor = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * This function can be called to stop iteration at any point.
     */
    IterationController.prototype.done = function () {
        this.shouldStop = true;
    };
    /**
     * This function can be called to skip to that next key, which could be
     * an index or a primary key.
     */
    IterationController.prototype.skip = function (key) {
        this.nextKey = key;
    };
    /**
     * Delete the current cursor value from the object store.
     *
     * NOTE: You CANNOT do this with a keysOnly query.
     */
    IterationController.prototype.delete = function () {
        return wrapRequest(this.dbCursor.delete());
    };
    return IterationController;
}();

/**
 * Wraps an IDBTransaction and exposes a store() method to get a handle to a
 * specific object store.
 */
var simple_db_SimpleDbTransaction = /** @class */function () {
    function SimpleDbTransaction(db, mode, objectStoresNames) {
        var _this = this;
        this.aborted = false;
        this.transaction = db.transaction(objectStoresNames, mode);
        this.completionPromise = new Promise(function (resolve, reject) {
            // We consider aborting to be "normal" and just resolve the promise.
            // May need to revisit if/when we actually need to abort transactions.
            _this.transaction.onabort = _this.transaction.oncomplete = function (event) {
                resolve();
            };
            _this.transaction.onerror = function (event) {
                reject(event.target.error);
            };
        });
    }
    SimpleDbTransaction.prototype.abort = function () {
        if (!this.aborted) {
            debug(simple_db_LOG_TAG, 'Aborting transaction.');
            this.aborted = true;
            this.transaction.abort();
        }
    };
    /**
     * Returns a SimpleDbStore<KeyType, ValueType> for the specified store. All
     * operations performed on the SimpleDbStore happen within the context of this
     * transaction and it cannot be used anymore once the transaction is
     * completed.
     *
     * Note that we can't actually enforce that the KeyType and ValueType are
     * correct, but they allow type safety through the rest of the consuming code.
     */
    SimpleDbTransaction.prototype.store = function (storeName) {
        var store = this.transaction.objectStore(storeName);
        assert_assert(!!store, 'Object store not part of transaction: ' + storeName);
        return new simple_db_SimpleDbStore(store);
    };
    return SimpleDbTransaction;
}();

/**
 * A wrapper around an IDBObjectStore providing an API that:
 *
 * 1) Has generic KeyType / ValueType parameters to provide strongly-typed
 * methods for acting against the object store.
 * 2) Deals with IndexedDB's onsuccess / onerror event callbacks, making every
 * method return a PersistencePromise instead.
 * 3) Provides a higher-level API to avoid needing to do excessive wrapping of
 * intermediate IndexedDB types (IDBCursorWithValue, etc.)
 */
var simple_db_SimpleDbStore = /** @class */function () {
    function SimpleDbStore(store) {
        this.store = store;
    }
    SimpleDbStore.prototype.put = function (keyOrValue, value) {
        var request;
        if (value !== undefined) {
            debug(simple_db_LOG_TAG, 'PUT', this.store.name, keyOrValue, value);
            request = this.store.put(value, keyOrValue);
        } else {
            debug(simple_db_LOG_TAG, 'PUT', this.store.name, '<auto-key>', keyOrValue);
            request = this.store.put(keyOrValue);
        }
        return wrapRequest(request);
    };
    /**
     * Gets the object with the specified key from the specified store, or null
     * if no object exists with the specified key.
     *
     * @key The key of the object to get.
     * @return The object with the specified key or null if no object exists.
     */
    SimpleDbStore.prototype.get = function (key) {
        var _this = this;
        var request = this.store.get(key);
        // tslint:disable-next-line:no-any We're doing an unsafe cast to ValueType.
        return wrapRequest(request).next(function (result) {
            // Normalize nonexistence to null.
            if (result === undefined) {
                result = null;
            }
            debug(simple_db_LOG_TAG, 'GET', _this.store.name, key, result);
            return result;
        });
    };
    SimpleDbStore.prototype.delete = function (key) {
        debug(simple_db_LOG_TAG, 'DELETE', this.store.name, key);
        var request = this.store.delete(key);
        return wrapRequest(request);
    };
    SimpleDbStore.prototype.loadAll = function (indexOrRange, range) {
        var cursor = this.cursor(this.options(indexOrRange, range));
        var results = [];
        return this.iterateCursor(cursor, function (key, value) {
            results.push(value);
        }).next(function () {
            return results;
        });
    };
    SimpleDbStore.prototype.deleteAll = function (indexOrRange, range) {
        debug(simple_db_LOG_TAG, 'DELETE ALL', this.store.name);
        var options = this.options(indexOrRange, range);
        options.keysOnly = false;
        var cursor = this.cursor(options);
        return this.iterateCursor(cursor, function (key, value, control) {
            // NOTE: Calling delete() on a cursor is documented as more efficient than
            // calling delete() on an object store with a single key
            // (https://developer.mozilla.org/en-US/docs/Web/API/IDBObjectStore/delete),
            // however, this requires us *not* to use a keysOnly cursor
            // (https://developer.mozilla.org/en-US/docs/Web/API/IDBCursor/delete). We
            // may want to compare the performance of each method.
            return control.delete();
        });
    };
    SimpleDbStore.prototype.iterate = function (optionsOrCallback, callback) {
        var options;
        if (!callback) {
            options = {};
            callback = optionsOrCallback;
        } else {
            options = optionsOrCallback;
        }
        var cursor = this.cursor(options);
        return this.iterateCursor(cursor, callback);
    };
    SimpleDbStore.prototype.iterateCursor = function (cursorRequest, fn) {
        var results = [];
        return new persistence_promise_PersistencePromise(function (resolve, reject) {
            cursorRequest.onerror = function (event) {
                reject(event.target.error);
            };
            cursorRequest.onsuccess = function (event) {
                var cursor = event.target.result;
                if (!cursor) {
                    resolve();
                    return;
                }
                var controller = new IterationController(cursor);
                var userResult = fn(cursor.primaryKey, cursor.value, controller);
                if (userResult instanceof persistence_promise_PersistencePromise) {
                    results.push(userResult);
                }
                if (controller.isDone) {
                    resolve();
                } else if (controller.skipToKey === null) {
                    cursor.continue();
                } else {
                    cursor.continue(controller.skipToKey);
                }
            };
        }).next(function () {
            return persistence_promise_PersistencePromise.waitFor(results);
        });
    };
    SimpleDbStore.prototype.options = function (indexOrRange, range) {
        var indexName = undefined;
        if (indexOrRange !== undefined) {
            if (typeof indexOrRange === 'string') {
                indexName = indexOrRange;
            } else {
                assert_assert(range === undefined, '3rd argument must not be defined if 2nd is a range.');
                range = indexOrRange;
            }
        }
        return { index: indexName, range: range };
    };
    SimpleDbStore.prototype.cursor = function (options) {
        var direction = 'next';
        if (options.reverse) {
            direction = 'prev';
        }
        if (options.index) {
            var index = this.store.index(options.index);
            if (options.keysOnly) {
                return index.openKeyCursor(options.range, direction);
            } else {
                return index.openCursor(options.range, direction);
            }
        } else {
            return this.store.openCursor(options.range, direction);
        }
    };
    return SimpleDbStore;
}();

/**
 * Wraps an IDBRequest in a PersistencePromise, using the onsuccess / onerror
 * handlers to resolve / reject the PersistencePromise as appropriate.
 */
function wrapRequest(request) {
    return new persistence_promise_PersistencePromise(function (resolve, reject) {
        request.onsuccess = function (event) {
            var result = event.target.result;
            resolve(result);
        };
        request.onerror = function (event) {
            reject(event.target.error);
        };
    });
}

//# sourceMappingURL=simple_db.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/local/indexeddb_mutation_queue.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/** A mutation queue for a specific user, backed by IndexedDB. */
var indexeddb_mutation_queue_IndexedDbMutationQueue = /** @class */function () {
    function IndexedDbMutationQueue(
    /**
     * The normalized userId (e.g. null UID => "" userId) used to store /
     * retrieve mutations.
     */
    userId, serializer) {
        this.userId = userId;
        this.serializer = serializer;
        this.garbageCollector = null;
    }
    /**
     * Creates a new mutation queue for the given user.
     * @param user The user for which to create a mutation queue.
     * @param serializer The serializer to use when persisting to IndexedDb.
     */
    IndexedDbMutationQueue.forUser = function (user, serializer) {
        // TODO(mcg): Figure out what constraints there are on userIDs
        // In particular, are there any reserved characters? are empty ids allowed?
        // For the moment store these together in the same mutations table assuming
        // that empty userIDs aren't allowed.
        assert_assert(user.uid !== '', 'UserID must not be an empty string.');
        var userId = user.isUnauthenticated() ? '' : user.uid;
        return new IndexedDbMutationQueue(userId, serializer);
    };
    IndexedDbMutationQueue.prototype.start = function (transaction) {
        var _this = this;
        return IndexedDbMutationQueue.loadNextBatchIdFromDb(transaction).next(function (nextBatchId) {
            _this.nextBatchId = nextBatchId;
            return mutationQueuesStore(transaction).get(_this.userId);
        }).next(function (metadata) {
            if (!metadata) {
                metadata = new DbMutationQueue(_this.userId, BATCHID_UNKNOWN,
                /*lastStreamToken=*/'');
            }
            _this.metadata = metadata;
            // On restart, nextBatchId may end up lower than
            // lastAcknowledgedBatchId since it's computed from the queue
            // contents, and there may be no mutations in the queue. In this
            // case, we need to reset lastAcknowledgedBatchId (which is safe
            // since the queue must be empty).
            if (_this.metadata.lastAcknowledgedBatchId >= _this.nextBatchId) {
                return _this.checkEmpty(transaction).next(function (empty) {
                    assert_assert(empty, 'Reset nextBatchID is only possible when the queue is empty');
                    _this.metadata.lastAcknowledgedBatchId = BATCHID_UNKNOWN;
                    return mutationQueuesStore(transaction).put(_this.metadata);
                });
            } else {
                return persistence_promise_PersistencePromise.resolve();
            }
        });
    };
    /**
     * Returns one larger than the largest batch ID that has been stored. If there
     * are no mutations returns 0. Note that batch IDs are global.
     */
    IndexedDbMutationQueue.loadNextBatchIdFromDb = function (txn) {
        var maxBatchId = BATCHID_UNKNOWN;
        return mutationsStore(txn).iterate({ reverse: true }, function (key, batch, control) {
            var userId = key[0],
                batchId = key[1];
            if (batchId > maxBatchId) {
                maxBatchId = batch.batchId;
            }
            if (userId === '') {
                // We can't compute a predecessor for the empty string, since it
                // is lexographically first. That also means that no other
                // userIds can come before this one, so we can just exit early.
                control.done();
            } else {
                var nextUser = immediatePredecessor(userId);
                control.skip([nextUser]);
            }
        }).next(function () {
            return maxBatchId + 1;
        });
    };
    IndexedDbMutationQueue.prototype.checkEmpty = function (transaction) {
        var empty = true;
        var range = IDBKeyRange.bound(this.keyForBatchId(Number.NEGATIVE_INFINITY), this.keyForBatchId(Number.POSITIVE_INFINITY));
        return mutationsStore(transaction).iterate({ range: range }, function (key, value, control) {
            empty = false;
            control.done();
        }).next(function () {
            return empty;
        });
    };
    IndexedDbMutationQueue.prototype.getNextBatchId = function (transaction) {
        return persistence_promise_PersistencePromise.resolve(this.nextBatchId);
    };
    IndexedDbMutationQueue.prototype.getHighestAcknowledgedBatchId = function (transaction) {
        return persistence_promise_PersistencePromise.resolve(this.metadata.lastAcknowledgedBatchId);
    };
    IndexedDbMutationQueue.prototype.acknowledgeBatch = function (transaction, batch, streamToken) {
        var batchId = batch.batchId;
        assert_assert(batchId > this.metadata.lastAcknowledgedBatchId, 'Mutation batchIDs must be acknowledged in order');
        this.metadata.lastAcknowledgedBatchId = batchId;
        this.metadata.lastStreamToken = validateStreamToken(streamToken);
        return mutationQueuesStore(transaction).put(this.metadata);
    };
    IndexedDbMutationQueue.prototype.getLastStreamToken = function (transaction) {
        return persistence_promise_PersistencePromise.resolve(this.metadata.lastStreamToken);
    };
    IndexedDbMutationQueue.prototype.setLastStreamToken = function (transaction, streamToken) {
        this.metadata.lastStreamToken = validateStreamToken(streamToken);
        return mutationQueuesStore(transaction).put(this.metadata);
    };
    IndexedDbMutationQueue.prototype.addMutationBatch = function (transaction, localWriteTime, mutations) {
        var _this = this;
        var batchId = this.nextBatchId;
        this.nextBatchId++;
        var batch = new mutation_batch_MutationBatch(batchId, localWriteTime, mutations);
        var dbBatch = this.serializer.toDbMutationBatch(this.userId, batch);
        return mutationsStore(transaction).put(dbBatch).next(function () {
            var promises = [];
            for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {
                var mutation = mutations_1[_i];
                var encodedPath = encode(mutation.key.path);
                var indexKey = indexeddb_schema_DbDocumentMutation.key(_this.userId, mutation.key.path, batchId);
                documentMutationsStore(transaction).put(indexKey, indexeddb_schema_DbDocumentMutation.PLACEHOLDER);
            }
            return persistence_promise_PersistencePromise.waitFor(promises);
        }).next(function () {
            return batch;
        });
    };
    IndexedDbMutationQueue.prototype.lookupMutationBatch = function (transaction, batchId) {
        var _this = this;
        return mutationsStore(transaction).get(this.keyForBatchId(batchId)).next(function (dbBatch) {
            return dbBatch ? _this.serializer.fromDbMutationBatch(dbBatch) : null;
        });
    };
    IndexedDbMutationQueue.prototype.getNextMutationBatchAfterBatchId = function (transaction, batchId) {
        var _this = this;
        var range = IDBKeyRange.lowerBound(this.keyForBatchId(batchId + 1));
        var foundBatch = null;
        return mutationsStore(transaction).iterate({ range: range }, function (key, dbBatch, control) {
            if (dbBatch.userId === _this.userId) {
                assert_assert(dbBatch.batchId > batchId, 'Should have found mutation after ' + batchId);
                foundBatch = _this.serializer.fromDbMutationBatch(dbBatch);
            }
            control.done();
        }).next(function () {
            return foundBatch;
        });
    };
    IndexedDbMutationQueue.prototype.getAllMutationBatches = function (transaction) {
        var _this = this;
        var range = IDBKeyRange.bound(this.keyForBatchId(BATCHID_UNKNOWN), this.keyForBatchId(Number.POSITIVE_INFINITY));
        return mutationsStore(transaction).loadAll(range).next(function (dbBatches) {
            return dbBatches.map(function (dbBatch) {
                return _this.serializer.fromDbMutationBatch(dbBatch);
            });
        });
    };
    IndexedDbMutationQueue.prototype.getAllMutationBatchesThroughBatchId = function (transaction, batchId) {
        var _this = this;
        var range = IDBKeyRange.bound(this.keyForBatchId(BATCHID_UNKNOWN), this.keyForBatchId(batchId));
        return mutationsStore(transaction).loadAll(range).next(function (dbBatches) {
            return dbBatches.map(function (dbBatch) {
                return _this.serializer.fromDbMutationBatch(dbBatch);
            });
        });
    };
    IndexedDbMutationQueue.prototype.getAllMutationBatchesAffectingDocumentKey = function (transaction, documentKey) {
        var _this = this;
        // Scan the document-mutation index starting with a prefix starting with
        // the given documentKey.
        var indexPrefix = indexeddb_schema_DbDocumentMutation.prefixForPath(this.userId, documentKey.path);
        var indexStart = IDBKeyRange.lowerBound(indexPrefix);
        var results = [];
        return documentMutationsStore(transaction).iterate({ range: indexStart }, function (indexKey, _, control) {
            var userID = indexKey[0],
                encodedPath = indexKey[1],
                batchID = indexKey[2];
            // Only consider rows matching exactly the specific key of
            // interest. Note that because we order by path first, and we
            // order terminators before path separators, we'll encounter all
            // the index rows for documentKey contiguously. In particular, all
            // the rows for documentKey will occur before any rows for
            // documents nested in a subcollection beneath documentKey so we
            // can stop as soon as we hit any such row.
            var path = encoded_resource_path_decode(encodedPath);
            if (userID !== _this.userId || !documentKey.path.equals(path)) {
                control.done();
                return;
            }
            var mutationKey = _this.keyForBatchId(batchID);
            // Look up the mutation batch in the store.
            // PORTING NOTE: because iteration is callback driven in the web,
            // we just look up the key instead of keeping an open iterator
            // like iOS.
            return mutationsStore(transaction).get(mutationKey).next(function (dbBatch) {
                if (dbBatch === null) {
                    fail('Dangling document-mutation reference found: ' + indexKey + ' which points to ' + mutationKey);
                }
                results.push(_this.serializer.fromDbMutationBatch(dbBatch));
            });
        }).next(function () {
            return results;
        });
    };
    IndexedDbMutationQueue.prototype.getAllMutationBatchesAffectingQuery = function (transaction, query) {
        var _this = this;
        assert_assert(!query.isDocumentQuery(), "Document queries shouldn't go down this path");
        var queryPath = query.path;
        var immediateChildrenLength = queryPath.length + 1;
        // TODO(mcg): Actually implement a single-collection query
        //
        // This is actually executing an ancestor query, traversing the whole
        // subtree below the collection which can be horrifically inefficient for
        // some structures. The right way to solve this is to implement the full
        // value index, but that's not in the cards in the near future so this is
        // the best we can do for the moment.
        //
        // Since we don't yet index the actual properties in the mutations, our
        // current approach is to just return all mutation batches that affect
        // documents in the collection being queried.
        var indexPrefix = indexeddb_schema_DbDocumentMutation.prefixForPath(this.userId, queryPath);
        var encodedQueryPath = indexPrefix[1];
        var indexStart = IDBKeyRange.lowerBound(indexPrefix);
        // Collect up unique batchIDs encountered during a scan of the index. Use a
        // SortedSet to accumulate batch IDs so they can be traversed in order in a
        // scan of the main table.
        var uniqueBatchIDs = new sorted_set_SortedSet(primitiveComparator);
        return documentMutationsStore(transaction).iterate({ range: indexStart }, function (indexKey, _, control) {
            var userID = indexKey[0],
                encodedPath = indexKey[1],
                batchID = indexKey[2];
            var path = encoded_resource_path_decode(encodedPath);
            if (userID !== _this.userId || !queryPath.isPrefixOf(path)) {
                control.done();
                return;
            }
            // Rows with document keys more than one segment longer than the
            // query path can't be matches. For example, a query on 'rooms'
            // can't match the document /rooms/abc/messages/xyx.
            // TODO(mcg): we'll need a different scanner when we implement
            // ancestor queries.
            if (path.length !== immediateChildrenLength) {
                return;
            }
            uniqueBatchIDs = uniqueBatchIDs.add(batchID);
        }).next(function () {
            var results = [];
            var promises = [];
            // TODO(rockwood): Implement this using iterate.
            uniqueBatchIDs.forEach(function (batchID) {
                var mutationKey = _this.keyForBatchId(batchID);
                promises.push(mutationsStore(transaction).get(mutationKey).next(function (mutation) {
                    if (mutation === null) {
                        fail('Dangling document-mutation reference found, ' + 'which points to ' + mutationKey);
                    }
                    results.push(_this.serializer.fromDbMutationBatch(mutation));
                }));
            });
            return persistence_promise_PersistencePromise.waitFor(promises).next(function () {
                return results;
            });
        });
    };
    IndexedDbMutationQueue.prototype.removeMutationBatches = function (transaction, batches) {
        var txn = mutationsStore(transaction);
        var indexTxn = documentMutationsStore(transaction);
        var promises = [];
        var _loop_1 = function _loop_1(batch) {
            var range = IDBKeyRange.only(this_1.keyForBatchId(batch.batchId));
            var numDeleted = 0;
            var removePromise = txn.iterate({ range: range }, function (key, value, control) {
                numDeleted++;
                return control.delete();
            });
            promises.push(removePromise.next(function () {
                assert_assert(numDeleted === 1, 'Dangling document-mutation reference found: Missing batch ' + batch.batchId);
            }));
            for (var _i = 0, _a = batch.mutations; _i < _a.length; _i++) {
                var mutation = _a[_i];
                var indexKey = indexeddb_schema_DbDocumentMutation.key(this_1.userId, mutation.key.path, batch.batchId);
                promises.push(indexTxn.delete(indexKey));
                if (this_1.garbageCollector !== null) {
                    this_1.garbageCollector.addPotentialGarbageKey(mutation.key);
                }
            }
        };
        var this_1 = this;
        for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {
            var batch = batches_1[_i];
            _loop_1(batch);
        }
        return persistence_promise_PersistencePromise.waitFor(promises);
    };
    IndexedDbMutationQueue.prototype.performConsistencyCheck = function (txn) {
        var _this = this;
        return this.checkEmpty(txn).next(function (empty) {
            if (!empty) {
                return persistence_promise_PersistencePromise.resolve();
            }
            // Verify that there are no entries in the documentMutations index if
            // the queue is empty.
            var startRange = IDBKeyRange.lowerBound(indexeddb_schema_DbDocumentMutation.prefixForUser(_this.userId));
            var danglingMutationReferences = [];
            return documentMutationsStore(txn).iterate({ range: startRange }, function (key, _, control) {
                var userID = key[0];
                if (userID !== _this.userId) {
                    control.done();
                    return;
                } else {
                    var path = encoded_resource_path_decode(key[1]);
                    danglingMutationReferences.push(path);
                }
            }).next(function () {
                assert_assert(danglingMutationReferences.length === 0, 'Document leak -- detected dangling mutation references when queue is empty. Dangling keys: ' + danglingMutationReferences.map(function (p) {
                    return p.canonicalString();
                }));
            });
        });
    };
    IndexedDbMutationQueue.prototype.setGarbageCollector = function (gc) {
        this.garbageCollector = gc;
    };
    IndexedDbMutationQueue.prototype.containsKey = function (txn, key) {
        var _this = this;
        var indexKey = indexeddb_schema_DbDocumentMutation.prefixForPath(this.userId, key.path);
        var encodedPath = indexKey[1];
        var startRange = IDBKeyRange.lowerBound(indexKey);
        var containsKey = false;
        return documentMutationsStore(txn).iterate({ range: startRange, keysOnly: true }, function (key, _, control) {
            var userID = key[0],
                keyPath = key[1],
                batchID = key[2];
            if (userID === _this.userId && keyPath === encodedPath) {
                containsKey = true;
            }
            control.done();
        }).next(function () {
            return containsKey;
        });
    };
    /**
     * Creates a [userId, batchId] key for use with the DbMutationQueue object
     * store.
     */
    IndexedDbMutationQueue.prototype.keyForBatchId = function (batchId) {
        return [this.userId, batchId];
    };
    return IndexedDbMutationQueue;
}();

function validateStreamToken(token) {
    assert_assert(typeof token === 'string', 'Persisting non-string stream token not supported.');
    return token;
}
/**
 * Helper to get a typed SimpleDbStore for the mutations object store.
 */
function mutationsStore(txn) {
    return getStore(txn, DbMutationBatch.store);
}
/**
 * Helper to get a typed SimpleDbStore for the mutationQueues object store.
 */
function documentMutationsStore(txn) {
    return getStore(txn, indexeddb_schema_DbDocumentMutation.store);
}
/**
 * Helper to get a typed SimpleDbStore for the mutationQueues object store.
 */
function mutationQueuesStore(txn) {
    return getStore(txn, DbMutationQueue.store);
}
/**
 * Helper to get a typed SimpleDbStore from a transaction.
 */
function getStore(txn, store) {
    if (txn instanceof simple_db_SimpleDbTransaction) {
        return txn.store(store);
    } else {
        return fail('Invalid transaction object provided!');
    }
}

//# sourceMappingURL=indexeddb_mutation_queue.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/local/indexeddb_query_cache.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */










var indexeddb_query_cache_IndexedDbQueryCache = /** @class */function () {
    function IndexedDbQueryCache(serializer) {
        this.serializer = serializer;
        /**
         * The last received snapshot version. We store this seperately from the
         * metadata to avoid the extra conversion to/from DbTimestamp.
         */
        this.lastRemoteSnapshotVersion = snapshot_version_SnapshotVersion.MIN;
        /**
         * A cached copy of the metadata for the query cache.
         */
        this.metadata = new DbTargetGlobal(
        /*highestTargetId=*/0,
        /*lastListenSequenceNumber=*/0, snapshot_version_SnapshotVersion.MIN.toTimestamp());
        /** The garbage collector to notify about potential garbage keys. */
        this.garbageCollector = null;
    }
    IndexedDbQueryCache.prototype.start = function (transaction) {
        var _this = this;
        return globalTargetStore(transaction).get(DbTargetGlobal.key).next(function (metadata) {
            if (metadata !== null) {
                _this.metadata = metadata;
                var lastSavedVersion = metadata.lastRemoteSnapshotVersion;
                _this.lastRemoteSnapshotVersion = snapshot_version_SnapshotVersion.fromTimestamp(new timestamp_Timestamp(lastSavedVersion.seconds, lastSavedVersion.nanos));
            }
            return persistence_promise_PersistencePromise.resolve();
        });
    };
    IndexedDbQueryCache.prototype.getHighestTargetId = function () {
        return this.metadata.highestTargetId;
    };
    IndexedDbQueryCache.prototype.getLastRemoteSnapshotVersion = function () {
        return this.lastRemoteSnapshotVersion;
    };
    IndexedDbQueryCache.prototype.setLastRemoteSnapshotVersion = function (transaction, snapshotVersion) {
        this.lastRemoteSnapshotVersion = snapshotVersion;
        this.metadata.lastRemoteSnapshotVersion = snapshotVersion.toTimestamp();
        return globalTargetStore(transaction).put(DbTargetGlobal.key, this.metadata);
    };
    IndexedDbQueryCache.prototype.addQueryData = function (transaction, queryData) {
        var _this = this;
        var targetId = queryData.targetId;
        var addedQueryPromise = targetsStore(transaction).put(this.serializer.toDbTarget(queryData));
        if (targetId > this.metadata.highestTargetId) {
            this.metadata.highestTargetId = targetId;
            return addedQueryPromise.next(function () {
                return globalTargetStore(transaction).put(DbTargetGlobal.key, _this.metadata);
            });
        } else {
            return addedQueryPromise;
        }
    };
    IndexedDbQueryCache.prototype.removeQueryData = function (transaction, queryData) {
        return this.removeMatchingKeysForTargetId(transaction, queryData.targetId).next(function () {
            targetsStore(transaction).delete(queryData.targetId);
        });
    };
    IndexedDbQueryCache.prototype.getQueryData = function (transaction, query) {
        var _this = this;
        // Iterating by the canonicalId may yield more than one result because
        // canonicalId values are not required to be unique per target. This query
        // depends on the queryTargets index to be efficent.
        var canonicalId = query.canonicalId();
        var range = IDBKeyRange.bound([canonicalId, Number.NEGATIVE_INFINITY], [canonicalId, Number.POSITIVE_INFINITY]);
        var result = null;
        return targetsStore(transaction).iterate({ range: range, index: DbTarget.queryTargetsIndexName }, function (key, value, control) {
            var found = _this.serializer.fromDbTarget(value);
            // After finding a potential match, check that the query is
            // actually equal to the requested query.
            if (query.equals(found.query)) {
                result = found;
                control.done();
            }
        }).next(function () {
            return result;
        });
    };
    IndexedDbQueryCache.prototype.addMatchingKeys = function (txn, keys, targetId) {
        // PORTING NOTE: The reverse index (documentsTargets) is maintained by
        // Indexeddb.
        var promises = [];
        var store = documentTargetStore(txn);
        keys.forEach(function (key) {
            var path = encode(key.path);
            promises.push(store.put(new DbTargetDocument(targetId, path)));
        });
        return persistence_promise_PersistencePromise.waitFor(promises);
    };
    IndexedDbQueryCache.prototype.removeMatchingKeys = function (txn, keys, targetId) {
        var _this = this;
        // PORTING NOTE: The reverse index (documentsTargets) is maintained by
        // IndexedDb.
        var promises = [];
        var store = documentTargetStore(txn);
        keys.forEach(function (key) {
            var path = encode(key.path);
            promises.push(store.delete([targetId, path]));
            if (_this.garbageCollector !== null) {
                _this.garbageCollector.addPotentialGarbageKey(key);
            }
        });
        return persistence_promise_PersistencePromise.waitFor(promises);
    };
    IndexedDbQueryCache.prototype.removeMatchingKeysForTargetId = function (txn, targetId) {
        var store = documentTargetStore(txn);
        var range = IDBKeyRange.bound([targetId], [targetId + 1],
        /*lowerOpen=*/false,
        /*upperOpen=*/true);
        return this.notifyGCForRemovedKeys(txn, range).next(function () {
            return store.delete(range);
        });
    };
    IndexedDbQueryCache.prototype.notifyGCForRemovedKeys = function (txn, range) {
        var _this = this;
        var store = documentTargetStore(txn);
        if (this.garbageCollector !== null && this.garbageCollector.isEager) {
            // In order to generate garbage events properly, we need to read these
            // keys before deleting.
            return store.iterate({ range: range, keysOnly: true }, function (key, _, control) {
                var path = encoded_resource_path_decode(key[1]);
                var docKey = new document_key_DocumentKey(path);
                // Paranoid assertion in case the the collector is set to null
                // during the iteration.
                assert_assert(_this.garbageCollector !== null, 'GarbageCollector for query cache set to null during key removal.');
                _this.garbageCollector.addPotentialGarbageKey(docKey);
            });
        } else {
            return persistence_promise_PersistencePromise.resolve();
        }
    };
    IndexedDbQueryCache.prototype.getMatchingKeysForTargetId = function (txn, targetId) {
        var promises = [];
        var range = IDBKeyRange.bound([targetId], [targetId + 1],
        /*lowerOpen=*/false,
        /*upperOpen=*/true);
        var store = documentTargetStore(txn);
        var result = documentKeySet();
        return store.iterate({ range: range, keysOnly: true }, function (key, _, control) {
            var path = encoded_resource_path_decode(key[1]);
            var docKey = new document_key_DocumentKey(path);
            result = result.add(docKey);
        }).next(function () {
            return result;
        });
    };
    IndexedDbQueryCache.prototype.setGarbageCollector = function (gc) {
        this.garbageCollector = gc;
    };
    IndexedDbQueryCache.prototype.containsKey = function (txn, key) {
        assert_assert(txn !== null, 'Persistence Transaction cannot be null for query cache containsKey');
        var path = encode(key.path);
        var range = IDBKeyRange.bound([path], [immediateSuccessor(path)],
        /*lowerOpen=*/false,
        /*upperOpen=*/true);
        var count = 0;
        return documentTargetStore(txn).iterate({
            index: DbTargetDocument.documentTargetsIndex,
            keysOnly: true,
            range: range
        }, function (key, _, control) {
            count++;
            control.done();
        }).next(function () {
            return count > 0;
        });
    };
    return IndexedDbQueryCache;
}();

/**
 * Helper to get a typed SimpleDbStore for the queries object store.
 */
function targetsStore(txn) {
    return indexeddb_query_cache_getStore(txn, DbTarget.store);
}
/**
 * Helper to get a typed SimpleDbStore for the target globals object store.
 */
function globalTargetStore(txn) {
    return indexeddb_query_cache_getStore(txn, DbTargetGlobal.store);
}
/**
 * Helper to get a typed SimpleDbStore for the document target object store.
 */
function documentTargetStore(txn) {
    return indexeddb_query_cache_getStore(txn, DbTargetDocument.store);
}
/**
 * Helper to get a typed SimpleDbStore from a transaction.
 */
function indexeddb_query_cache_getStore(txn, store) {
    if (txn instanceof simple_db_SimpleDbTransaction) {
        return txn.store(store);
    } else {
        return fail('Invalid transaction object provided!');
    }
}

//# sourceMappingURL=indexeddb_query_cache.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/local/indexeddb_remote_document_cache.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





var indexeddb_remote_document_cache_IndexedDbRemoteDocumentCache = /** @class */function () {
    function IndexedDbRemoteDocumentCache(serializer) {
        this.serializer = serializer;
    }
    IndexedDbRemoteDocumentCache.prototype.addEntry = function (transaction, maybeDocument) {
        return remoteDocumentsStore(transaction).put(dbKey(maybeDocument.key), this.serializer.toDbRemoteDocument(maybeDocument));
    };
    IndexedDbRemoteDocumentCache.prototype.removeEntry = function (transaction, documentKey) {
        return remoteDocumentsStore(transaction).delete(dbKey(documentKey));
    };
    IndexedDbRemoteDocumentCache.prototype.getEntry = function (transaction, documentKey) {
        var _this = this;
        return remoteDocumentsStore(transaction).get(dbKey(documentKey)).next(function (dbRemoteDoc) {
            return dbRemoteDoc ? _this.serializer.fromDbRemoteDocument(dbRemoteDoc) : null;
        });
    };
    IndexedDbRemoteDocumentCache.prototype.getDocumentsMatchingQuery = function (transaction, query) {
        var _this = this;
        var results = documentMap();
        // Documents are ordered by key, so we can use a prefix scan to narrow down
        // the documents we need to match the query against.
        var startKey = query.path.toArray();
        var range = IDBKeyRange.lowerBound(startKey);
        return remoteDocumentsStore(transaction).iterate({ range: range }, function (key, dbRemoteDoc, control) {
            var maybeDoc = _this.serializer.fromDbRemoteDocument(dbRemoteDoc);
            if (!query.path.isPrefixOf(maybeDoc.key.path)) {
                control.done();
            } else if (maybeDoc instanceof document_Document && query.matches(maybeDoc)) {
                results = results.insert(maybeDoc.key, maybeDoc);
            }
        }).next(function () {
            return results;
        });
    };
    return IndexedDbRemoteDocumentCache;
}();

/**
 * Helper to get a typed SimpleDbStore for the remoteDocuments object store.
 */
function remoteDocumentsStore(txn) {
    if (txn instanceof simple_db_SimpleDbTransaction) {
        return txn.store(DbRemoteDocument.store);
    } else {
        return fail('Invalid transaction object provided!');
    }
}
function dbKey(docKey) {
    return docKey.path.toArray();
}

//# sourceMappingURL=indexeddb_remote_document_cache.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/local/local_serializer.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/** Serializer for values stored in the LocalStore. */
var local_serializer_LocalSerializer = /** @class */function () {
    function LocalSerializer(remoteSerializer) {
        this.remoteSerializer = remoteSerializer;
    }
    /** Decodes a remote document from storage locally to a Document. */
    LocalSerializer.prototype.fromDbRemoteDocument = function (remoteDoc) {
        if (remoteDoc.document) {
            return this.remoteSerializer.fromDocument(remoteDoc.document);
        } else if (remoteDoc.noDocument) {
            var key = document_key_DocumentKey.fromSegments(remoteDoc.noDocument.path);
            var readTime = remoteDoc.noDocument.readTime;
            var timestamp = new timestamp_Timestamp(readTime.seconds, readTime.nanos);
            return new document_NoDocument(key, snapshot_version_SnapshotVersion.fromTimestamp(timestamp));
        } else {
            return fail('Unexpected DbRemoteDocument');
        }
    };
    /** Encodes a document for storage locally. */
    LocalSerializer.prototype.toDbRemoteDocument = function (maybeDoc) {
        if (maybeDoc instanceof document_Document) {
            var doc = this.remoteSerializer.toDocument(maybeDoc);
            return new DbRemoteDocument(null, doc);
        } else {
            var path = maybeDoc.key.path.toArray();
            var timestamp = maybeDoc.version.toTimestamp();
            var readTime = new DbTimestamp(timestamp.seconds, timestamp.nanos);
            return new DbRemoteDocument(new DbNoDocument(path, readTime), null);
        }
    };
    /** Encodes a batch of mutations into a DbMutationBatch for local storage. */
    LocalSerializer.prototype.toDbMutationBatch = function (userId, batch) {
        var _this = this;
        var serializedMutations = batch.mutations.map(function (m) {
            return _this.remoteSerializer.toMutation(m);
        });
        return new DbMutationBatch(userId, batch.batchId, batch.localWriteTime.toEpochMilliseconds(), serializedMutations);
    };
    /** Decodes a DbMutationBatch into a MutationBatch */
    LocalSerializer.prototype.fromDbMutationBatch = function (dbBatch) {
        var _this = this;
        var mutations = dbBatch.mutations.map(function (m) {
            return _this.remoteSerializer.fromMutation(m);
        });
        var timestamp = timestamp_Timestamp.fromEpochMilliseconds(dbBatch.localWriteTimeMs);
        return new mutation_batch_MutationBatch(dbBatch.batchId, timestamp, mutations);
    };
    /** Decodes a DbTarget into QueryData */
    LocalSerializer.prototype.fromDbTarget = function (dbTarget) {
        var readTime = new timestamp_Timestamp(dbTarget.readTime.seconds, dbTarget.readTime.nanos);
        var version = snapshot_version_SnapshotVersion.fromTimestamp(readTime);
        var query;
        if (isDocumentQuery(dbTarget.query)) {
            query = this.remoteSerializer.fromDocumentsTarget(dbTarget.query);
        } else {
            query = this.remoteSerializer.fromQueryTarget(dbTarget.query);
        }
        return new query_data_QueryData(query, dbTarget.targetId, QueryPurpose.Listen, version, dbTarget.resumeToken);
    };
    /** Encodes QueryData into a DbTarget for storage locally. */
    LocalSerializer.prototype.toDbTarget = function (queryData) {
        assert_assert(QueryPurpose.Listen === queryData.purpose, 'Only queries with purpose ' + QueryPurpose.Listen + ' may be stored, got ' + queryData.purpose);
        var timestamp = queryData.snapshotVersion.toTimestamp();
        var dbTimestamp = new DbTimestamp(timestamp.seconds, timestamp.nanos);
        var queryProto;
        if (queryData.query.isDocumentQuery()) {
            queryProto = this.remoteSerializer.toDocumentsTarget(queryData.query);
        } else {
            queryProto = this.remoteSerializer.toQueryTarget(queryData.query);
        }
        assert_assert(typeof queryData.resumeToken === 'string', 'Persisting non-string resume token not supported.');
        var resumeToken = queryData.resumeToken;
        // lastListenSequenceNumber is always 0 until we do real GC.
        return new DbTarget(queryData.targetId, queryData.query.canonicalId(), dbTimestamp, resumeToken, 0, queryProto);
    };
    return LocalSerializer;
}();

/**
 * A helper function for figuring out what kind of query has been stored.
 */
function isDocumentQuery(dbQuery) {
    return dbQuery.documents !== undefined;
}

//# sourceMappingURL=local_serializer.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/local/indexeddb_persistence.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */












var indexeddb_persistence_LOG_TAG = 'IndexedDbPersistence';
/** If the owner lease is older than 5 seconds, try to take ownership. */
var OWNER_LEASE_MAX_AGE_MS = 5000;
/** Refresh the owner lease every 4 seconds while owner. */
var OWNER_LEASE_REFRESH_INTERVAL_MS = 4000;
/** LocalStorage location to indicate a zombied ownerId (see class comment). */
var ZOMBIE_OWNER_LOCALSTORAGE_SUFFIX = 'zombiedOwnerId';
/** Error when the owner lease cannot be acquired or is lost. */
var EXISTING_OWNER_ERROR_MSG = 'There is another tab open with offline' + ' persistence enabled. Only one such tab is allowed at a time. The' + ' other tab must be closed or persistence must be disabled.';
var UNSUPPORTED_PLATFORM_ERROR_MSG = 'This platform is either missing' + ' IndexedDB or is known to have an incomplete implementation. Offline' + ' persistence has been disabled.';
/**
 * An IndexedDB-backed instance of Persistence. Data is stored persistently
 * across sessions.
 *
 * Currently the Firestore SDK only supports a single consumer of the database,
 * but browsers obviously support multiple tabs. IndexedDbPersistence ensures a
 * single consumer of the database via an "owner lease" stored in the database.
 *
 * On startup, IndexedDbPersistence assigns itself a random "ownerId" and writes
 * it to a special "owner" object in the database (if no entry exists already or
 * the current entry is expired). This owner lease is then verified inside every
 * transaction to ensure the lease has not been lost.
 *
 * If a tab opts not to acquire the owner lease (because there's an existing
 * non-expired owner) or loses the owner lease, IndexedDbPersistence enters a
 * failed state and all subsequent operations will automatically fail.
 *
 * The current owner regularly refreshes the owner lease with new timestamps to
 * prevent newly-opened tabs from taking over ownership.
 *
 * Additionally there is an optimization so that when a tab is closed, the owner
 * lease is released immediately (this is especially important to make sure that
 * a refreshed tab is able to immediately re-acquire the owner lease).
 * Unfortunately, IndexedDB cannot be reliably used in window.unload since it is
 * an asynchronous API. So in addition to attempting to give up the lease,
 * the owner writes its ownerId to a "zombiedOwnerId" entry in LocalStorage
 * which acts as an indicator that another tab should go ahead and take the
 * owner lease immediately regardless of the current lease timestamp.
 */
var indexeddb_persistence_IndexedDbPersistence = /** @class */function () {
    function IndexedDbPersistence(prefix, serializer) {
        this.ownerId = this.generateOwnerId();
        this.dbName = prefix + IndexedDbPersistence.MAIN_DATABASE;
        this.serializer = new local_serializer_LocalSerializer(serializer);
        this.localStoragePrefix = prefix;
    }
    IndexedDbPersistence.prototype.start = function () {
        var _this = this;
        if (!IndexedDbPersistence.isAvailable()) {
            this.persistenceError = new FirestoreError(Code.UNIMPLEMENTED, UNSUPPORTED_PLATFORM_ERROR_MSG);
            return Promise.reject(this.persistenceError);
        }
        assert_assert(!this.started, 'IndexedDbPersistence double-started!');
        this.started = true;
        return simple_db_SimpleDb.openOrCreate(this.dbName, SCHEMA_VERSION, createOrUpgradeDb).then(function (db) {
            _this.simpleDb = db;
        }).then(function () {
            return _this.tryAcquireOwnerLease();
        }).then(function () {
            _this.scheduleOwnerLeaseRefreshes();
            _this.attachWindowUnloadHook();
        });
    };
    IndexedDbPersistence.prototype.shutdown = function () {
        var _this = this;
        assert_assert(this.started, 'IndexedDbPersistence shutdown without start!');
        this.started = false;
        this.detachWindowUnloadHook();
        this.stopOwnerLeaseRefreshes();
        return this.releaseOwnerLease().then(function () {
            _this.simpleDb.close();
        });
    };
    IndexedDbPersistence.prototype.getMutationQueue = function (user) {
        return indexeddb_mutation_queue_IndexedDbMutationQueue.forUser(user, this.serializer);
    };
    IndexedDbPersistence.prototype.getQueryCache = function () {
        return new indexeddb_query_cache_IndexedDbQueryCache(this.serializer);
    };
    IndexedDbPersistence.prototype.getRemoteDocumentCache = function () {
        return new indexeddb_remote_document_cache_IndexedDbRemoteDocumentCache(this.serializer);
    };
    IndexedDbPersistence.prototype.runTransaction = function (action, operation) {
        var _this = this;
        if (this.persistenceError) {
            return Promise.reject(this.persistenceError);
        }
        debug(indexeddb_persistence_LOG_TAG, 'Starting transaction:', action);
        // Do all transactions as readwrite against all object stores, since we
        // are the only reader/writer.
        return this.simpleDb.runTransaction('readwrite', ALL_STORES, function (txn) {
            // Verify that we still have the owner lease as part of every transaction.
            return _this.ensureOwnerLease(txn).next(function () {
                return operation(txn);
            });
        });
    };
    IndexedDbPersistence.isAvailable = function () {
        return simple_db_SimpleDb.isAvailable();
    };
    /**
     * Generates a string used as a prefix when storing data in IndexedDB and
     * LocalStorage.
     */
    IndexedDbPersistence.buildStoragePrefix = function (databaseInfo) {
        // Use two different prefix formats:
        //
        //   * firestore / persistenceKey / projectID . databaseID / ...
        //   * firestore / persistenceKey / projectID / ...
        //
        // projectIDs are DNS-compatible names and cannot contain dots
        // so there's no danger of collisions.
        var database = databaseInfo.databaseId.projectId;
        if (!databaseInfo.databaseId.isDefaultDatabase) {
            database += '.' + databaseInfo.databaseId.database;
        }
        return 'firestore/' + databaseInfo.persistenceKey + '/' + database + '/';
    };
    /**
     * Acquires the owner lease if there's no valid owner. Else returns a rejected
     * promise.
     */
    IndexedDbPersistence.prototype.tryAcquireOwnerLease = function () {
        var _this = this;
        // NOTE: Don't use this.runTransaction, since it requires us to already
        // have the lease.
        return this.simpleDb.runTransaction('readwrite', [DbOwner.store], function (txn) {
            var store = txn.store(DbOwner.store);
            return store.get('owner').next(function (dbOwner) {
                if (!_this.validOwner(dbOwner)) {
                    var newDbOwner = new DbOwner(_this.ownerId, Date.now());
                    debug(indexeddb_persistence_LOG_TAG, 'No valid owner. Acquiring owner lease. Current owner:', dbOwner, 'New owner:', newDbOwner);
                    return store.put('owner', newDbOwner);
                } else {
                    debug(indexeddb_persistence_LOG_TAG, 'Valid owner already. Failing. Current owner:', dbOwner);
                    _this.persistenceError = new FirestoreError(Code.FAILED_PRECONDITION, EXISTING_OWNER_ERROR_MSG);
                    return persistence_promise_PersistencePromise.reject(_this.persistenceError);
                }
            });
        });
    };
    /** Checks the owner lease and deletes it if we are the current owner. */
    IndexedDbPersistence.prototype.releaseOwnerLease = function () {
        var _this = this;
        // NOTE: Don't use this.runTransaction, since it requires us to already
        // have the lease.
        return this.simpleDb.runTransaction('readwrite', [DbOwner.store], function (txn) {
            var store = txn.store(DbOwner.store);
            return store.get('owner').next(function (dbOwner) {
                if (dbOwner !== null && dbOwner.ownerId === _this.ownerId) {
                    debug(indexeddb_persistence_LOG_TAG, 'Releasing owner lease.');
                    return store.delete('owner');
                } else {
                    return persistence_promise_PersistencePromise.resolve();
                }
            });
        });
    };
    /**
     * Checks the owner lease and returns a rejected promise if we are not the
     * current owner. This should be included in every transaction to guard
     * against losing the owner lease.
     */
    IndexedDbPersistence.prototype.ensureOwnerLease = function (txn) {
        var _this = this;
        var store = txn.store(DbOwner.store);
        return store.get('owner').next(function (dbOwner) {
            if (dbOwner === null || dbOwner.ownerId !== _this.ownerId) {
                _this.persistenceError = new FirestoreError(Code.FAILED_PRECONDITION, EXISTING_OWNER_ERROR_MSG);
                return persistence_promise_PersistencePromise.reject(_this.persistenceError);
            } else {
                return persistence_promise_PersistencePromise.resolve();
            }
        });
    };
    /**
     * Returns true if the provided owner exists, has a recent timestamp, and
     * isn't zombied.
     *
     * NOTE: To determine if the owner is zombied, this method reads from
     * LocalStorage which could be mildly expensive.
     */
    IndexedDbPersistence.prototype.validOwner = function (dbOwner) {
        var now = Date.now();
        var minAcceptable = now - OWNER_LEASE_MAX_AGE_MS;
        var maxAcceptable = now;
        if (dbOwner === null) {
            return false; // no owner.
        } else if (dbOwner.leaseTimestampMs < minAcceptable) {
            return false; // owner lease has expired.
        } else if (dbOwner.leaseTimestampMs > maxAcceptable) {
            log_error('Persistence owner-lease is in the future. Discarding.', dbOwner);
            return false;
        } else if (dbOwner.ownerId === this.getZombiedOwnerId()) {
            return false; // owner's tab closed.
        } else {
            return true;
        }
    };
    /**
     * Schedules a recurring timer to update the owner lease timestamp to prevent
     * other tabs from taking the lease.
     */
    IndexedDbPersistence.prototype.scheduleOwnerLeaseRefreshes = function () {
        var _this = this;
        // NOTE: This doesn't need to be scheduled on the async queue and doing so
        // would increase the chances of us not refreshing on time if the queue is
        // backed up for some reason.
        this.ownerLeaseRefreshHandle = setInterval(function () {
            var txResult = _this.runTransaction('Refresh owner timestamp', function (txn) {
                // NOTE: We don't need to validate the current owner contents, since
                // runTransaction does that automatically.
                var store = txn.store(DbOwner.store);
                return store.put('owner', new DbOwner(_this.ownerId, Date.now()));
            });
            txResult.catch(function (reason) {
                // Probably means we lost the lease. Report the error and stop trying to
                // refresh the lease.
                log_error(reason);
                _this.stopOwnerLeaseRefreshes();
            });
        }, OWNER_LEASE_REFRESH_INTERVAL_MS);
    };
    IndexedDbPersistence.prototype.stopOwnerLeaseRefreshes = function () {
        if (this.ownerLeaseRefreshHandle) {
            clearInterval(this.ownerLeaseRefreshHandle);
            this.ownerLeaseRefreshHandle = null;
        }
    };
    /**
     * Attaches a window.unload handler that will synchronously write our
     * ownerId to a "zombie owner id" location in localstorage. This can be used
     * by tabs trying to acquire the lease to determine that the lease should be
     * acquired immediately even if the timestamp is recent. This is particularly
     * important for the refresh case (so the tab correctly re-acquires the owner
     * lease). LocalStorage is used for this rather than IndexedDb because it is
     * a synchronous API and so can be used reliably from an unload handler.
     */
    IndexedDbPersistence.prototype.attachWindowUnloadHook = function () {
        var _this = this;
        this.windowUnloadHandler = function () {
            // Record that we're zombied.
            _this.setZombiedOwnerId(_this.ownerId);
            // Attempt graceful shutdown (including releasing our owner lease), but
            // there's no guarantee it will complete.
            _this.shutdown();
        };
        window.addEventListener('unload', this.windowUnloadHandler);
    };
    IndexedDbPersistence.prototype.detachWindowUnloadHook = function () {
        if (this.windowUnloadHandler) {
            window.removeEventListener('unload', this.windowUnloadHandler);
            this.windowUnloadHandler = null;
        }
    };
    /**
     * Returns any recorded "zombied owner" (i.e. a previous owner that became
     * zombied due to their tab closing) from LocalStorage, or null if no such
     * record exists.
     */
    IndexedDbPersistence.prototype.getZombiedOwnerId = function () {
        try {
            var zombiedOwnerId = window.localStorage.getItem(this.zombiedOwnerLocalStorageKey());
            debug(indexeddb_persistence_LOG_TAG, 'Zombied ownerID from LocalStorage:', zombiedOwnerId);
            return zombiedOwnerId;
        } catch (e) {
            // Gracefully handle if LocalStorage isn't available / working.
            log_error(indexeddb_persistence_LOG_TAG, 'Failed to get zombie owner id.', e);
            return null;
        }
    };
    /**
     * Records a zombied owner (an owner that had its tab closed) in LocalStorage
     * or, if passed null, deletes any recorded zombied owner.
     */
    IndexedDbPersistence.prototype.setZombiedOwnerId = function (zombieOwnerId) {
        try {
            if (zombieOwnerId === null) {
                window.localStorage.removeItem(this.zombiedOwnerLocalStorageKey());
            } else {
                window.localStorage.setItem(this.zombiedOwnerLocalStorageKey(), zombieOwnerId);
            }
        } catch (e) {
            // Gracefully handle if LocalStorage isn't available / working.
            log_error(indexeddb_persistence_LOG_TAG, 'Failed to set zombie owner id.', e);
        }
    };
    IndexedDbPersistence.prototype.zombiedOwnerLocalStorageKey = function () {
        return this.localStoragePrefix + ZOMBIE_OWNER_LOCALSTORAGE_SUFFIX;
    };
    IndexedDbPersistence.prototype.generateOwnerId = function () {
        // For convenience, just use an AutoId.
        return misc_AutoId.newId();
    };
    /**
     * The name of the main (and currently only) IndexedDB database. this name is
     * appended to the prefix provided to the IndexedDbPersistence constructor.
     */
    IndexedDbPersistence.MAIN_DATABASE = 'main';
    return IndexedDbPersistence;
}();


//# sourceMappingURL=indexeddb_persistence.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/local/local_documents_view.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






/**
 * A readonly view of the local state of all documents we're tracking (i.e. we
 * have a cached version in remoteDocumentCache or local mutations for the
 * document). The view is computed by applying the mutations in the
 * MutationQueue to the RemoteDocumentCache.
 */
var local_documents_view_LocalDocumentsView = /** @class */function () {
    function LocalDocumentsView(remoteDocumentCache, mutationQueue) {
        this.remoteDocumentCache = remoteDocumentCache;
        this.mutationQueue = mutationQueue;
    }
    /**
     * Get the local view of the document identified by `key`.
     *
     * @return Local view of the document or null if we don't have any cached
     * state for it.
     */
    LocalDocumentsView.prototype.getDocument = function (transaction, key) {
        var _this = this;
        return this.remoteDocumentCache.getEntry(transaction, key).next(function (remoteDoc) {
            return _this.computeLocalDocument(transaction, key, remoteDoc);
        });
    };
    /**
     * Gets the local view of the documents identified by `keys`.
     *
     * If we don't have cached state for a document in `keys`, a NoDocument will
     * be stored for that key in the resulting set.
     */
    LocalDocumentsView.prototype.getDocuments = function (transaction, keys) {
        var _this = this;
        var promises = [];
        var results = maybeDocumentMap();
        keys.forEach(function (key) {
            promises.push(_this.getDocument(transaction, key).next(function (maybeDoc) {
                // TODO(http://b/32275378): Don't conflate missing / deleted.
                if (!maybeDoc) {
                    maybeDoc = new document_NoDocument(key, snapshot_version_SnapshotVersion.forDeletedDoc());
                }
                results = results.insert(key, maybeDoc);
            }));
        });
        return persistence_promise_PersistencePromise.waitFor(promises).next(function () {
            return results;
        });
    };
    /** Performs a query against the local view of all documents. */
    LocalDocumentsView.prototype.getDocumentsMatchingQuery = function (transaction, query) {
        if (document_key_DocumentKey.isDocumentKey(query.path)) {
            return this.getDocumentsMatchingDocumentQuery(transaction, query.path);
        } else {
            return this.getDocumentsMatchingCollectionQuery(transaction, query);
        }
    };
    LocalDocumentsView.prototype.getDocumentsMatchingDocumentQuery = function (transaction, docPath) {
        // Just do a simple document lookup.
        return this.getDocument(transaction, new document_key_DocumentKey(docPath)).next(function (maybeDoc) {
            var result = documentMap();
            if (maybeDoc instanceof document_Document) {
                result = result.insert(maybeDoc.key, maybeDoc);
            }
            return result;
        });
    };
    LocalDocumentsView.prototype.getDocumentsMatchingCollectionQuery = function (transaction, query) {
        var _this = this;
        // Query the remote documents and overlay mutations.
        // TODO(mikelehen): There may be significant overlap between the mutations
        // affecting these remote documents and the
        // getAllMutationBatchesAffectingQuery() mutations. Consider optimizing.
        var results;
        return this.remoteDocumentCache.getDocumentsMatchingQuery(transaction, query).next(function (queryResults) {
            return _this.computeLocalDocuments(transaction, queryResults);
        }).next(function (promisedResults) {
            results = promisedResults;
            // Now use the mutation queue to discover any other documents that may
            // match the query after applying mutations.
            return _this.mutationQueue.getAllMutationBatchesAffectingQuery(transaction, query);
        }).next(function (matchingMutationBatches) {
            var matchingKeys = documentKeySet();
            for (var _i = 0, matchingMutationBatches_1 = matchingMutationBatches; _i < matchingMutationBatches_1.length; _i++) {
                var batch = matchingMutationBatches_1[_i];
                for (var _a = 0, _b = batch.mutations; _a < _b.length; _a++) {
                    var mutation = _b[_a];
                    // TODO(mikelehen): PERF: Check if this mutation actually
                    // affects the query to reduce work.
                    if (!results.get(mutation.key)) {
                        matchingKeys = matchingKeys.add(mutation.key);
                    }
                }
            }
            // Now add in the results for the matchingKeys.
            var promises = [];
            matchingKeys.forEach(function (key) {
                promises.push(_this.getDocument(transaction, key).next(function (doc) {
                    if (doc instanceof document_Document) {
                        results = results.insert(doc.key, doc);
                    }
                }));
            });
            return persistence_promise_PersistencePromise.waitFor(promises);
        }).next(function () {
            // Finally, filter out any documents that don't actually match
            // the query.
            results.forEach(function (key, doc) {
                if (!query.matches(doc)) {
                    results = results.remove(key);
                }
            });
            return results;
        });
    };
    /**
     * Takes a remote document and applies local mutations to generate the local
     * view of the document.
     * @param transaction The transaction in which to perform any persistence
     *     operations.
     * @param documentKey The key of the document (necessary when remoteDocument
     *     is null).
     * @param document The base remote document to apply mutations to or null.
     */
    LocalDocumentsView.prototype.computeLocalDocument = function (transaction, documentKey, document) {
        return this.mutationQueue.getAllMutationBatchesAffectingDocumentKey(transaction, documentKey).next(function (batches) {
            for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {
                var batch = batches_1[_i];
                document = batch.applyToLocalView(documentKey, document);
            }
            return document;
        });
    };
    /**
     * Takes a set of remote documents and applies local mutations to generate the
     * local view of the documents.
     * @param transaction The transaction in which to perform any persistence
     *     operations.
     * @param documents The base remote documents to apply mutations to.
     * @return The local view of the documents.
     */
    LocalDocumentsView.prototype.computeLocalDocuments = function (transaction, documents) {
        var _this = this;
        var promises = [];
        documents.forEach(function (key, doc) {
            promises.push(_this.computeLocalDocument(transaction, key, doc).next(function (mutatedDoc) {
                if (mutatedDoc instanceof document_Document) {
                    documents = documents.insert(mutatedDoc.key, mutatedDoc);
                } else if (mutatedDoc instanceof document_NoDocument) {
                    documents = documents.remove(mutatedDoc.key);
                } else {
                    fail('Unknown MaybeDocument: ' + mutatedDoc);
                }
            }));
        });
        return persistence_promise_PersistencePromise.waitFor(promises).next(function () {
            return documents;
        });
    };
    return LocalDocumentsView;
}();


//# sourceMappingURL=local_documents_view.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/local/remote_document_change_buffer.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * An in-memory buffer of entries to be written to a RemoteDocumentCache.
 * It can be used to batch up a set of changes to be written to the cache, but
 * additionally supports reading entries back with the `getEntry()` method,
 * falling back to the underlying RemoteDocumentCache if no entry is
 * buffered.
 *
 * NOTE: This class was introduced in iOS to work around a limitation in
 * LevelDB. Given IndexedDb has full transaction support with
 * read-your-own-writes capability, this class is not technically needed, but
 * has been preserved as a convenience and to aid portability.
 */
var remote_document_change_buffer_RemoteDocumentChangeBuffer = /** @class */function () {
    function RemoteDocumentChangeBuffer(remoteDocumentCache) {
        this.remoteDocumentCache = remoteDocumentCache;
        this.changes = maybeDocumentMap();
    }
    /** Buffers a `RemoteDocumentCache.addEntry()` call. */
    RemoteDocumentChangeBuffer.prototype.addEntry = function (maybeDocument) {
        var changes = this.assertChanges();
        this.changes = changes.insert(maybeDocument.key, maybeDocument);
    };
    // NOTE: removeEntry() is not presently necessary and so is omitted.
    /**
     * Looks up an entry in the cache. The buffered changes will first be checked,
     * and if no buffered change applies, this will forward to
     * `RemoteDocumentCache.getEntry()`.
     *
     * @param transaction The transaction in which to perform any persistence
     *     operations.
     * @param documentKey The key of the entry to look up.
     * @return The cached Document or NoDocument entry, or null if we have nothing
     * cached.
     */
    RemoteDocumentChangeBuffer.prototype.getEntry = function (transaction, documentKey) {
        var changes = this.assertChanges();
        var bufferedEntry = changes.get(documentKey);
        if (bufferedEntry) {
            return persistence_promise_PersistencePromise.resolve(bufferedEntry);
        } else {
            return this.remoteDocumentCache.getEntry(transaction, documentKey);
        }
    };
    /**
     * Applies buffered changes to the underlying RemoteDocumentCache, using
     * the provided transaction.
     */
    RemoteDocumentChangeBuffer.prototype.apply = function (transaction) {
        var _this = this;
        var changes = this.assertChanges();
        var promises = [];
        changes.forEach(function (key, maybeDoc) {
            promises.push(_this.remoteDocumentCache.addEntry(transaction, maybeDoc));
        });
        // We should not be used to buffer any more changes.
        this.changes = null;
        return persistence_promise_PersistencePromise.waitFor(promises);
    };
    /** Helper to assert this.changes is not null and return it. */
    RemoteDocumentChangeBuffer.prototype.assertChanges = function () {
        assert_assert(this.changes !== null, 'Changes have already been applied.');
        return this.changes;
    };
    return RemoteDocumentChangeBuffer;
}();


//# sourceMappingURL=remote_document_change_buffer.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/local/local_store.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */














var local_store_LOG_TAG = 'LocalStore';
/**
 * Local storage in the Firestore client. Coordinates persistence components
 * like the mutation queue and remote document cache to present a
 * latency-compensated view of stored data.
 *
 * The LocalStore is responsible for accepting mutations from the Sync Engine.
 * Writes from the client are put into a queue as provisional Mutations until
 * they are processed by the RemoteStore and confirmed as having been written
 * to the server.
 *
 * The local store provides the local version of documents that have been
 * modified locally. It maintains the constraint:
 *
 *   LocalDocument = RemoteDocument + Active(LocalMutations)
 *
 * (Active mutations are those that are enqueued and have not been previously
 * acknowledged or rejected).
 *
 * The RemoteDocument ("ground truth") state is provided via the
 * applyChangeBatch method. It will be some version of a server-provided
 * document OR will be a server-provided document PLUS acknowledged mutations:
 *
 *   RemoteDocument' = RemoteDocument + Acknowledged(LocalMutations)
 *
 * Note that this "dirty" version of a RemoteDocument will not be identical to a
 * server base version, since it has LocalMutations added to it pending getting
 * an authoritative copy from the server.
 *
 * Since LocalMutations can be rejected by the server, we have to be able to
 * revert a LocalMutation that has already been applied to the LocalDocument
 * (typically done by replaying all remaining LocalMutations to the
 * RemoteDocument to re-apply).
 *
 * The LocalStore is responsible for the garbage collection of the documents it
 * contains. For now, it every doc referenced by a view, the mutation queue, or
 * the RemoteStore.
 *
 * It also maintains the persistence of mapping queries to resume tokens and
 * target ids. It needs to know this data about queries to properly know what
 * docs it would be allowed to garbage collect.
 *
 * The LocalStore must be able to efficiently execute queries against its local
 * cache of the documents, to provide the initial set of results before any
 * remote changes have been received.
 *
 * Note: In TypeScript, most methods return Promises since the implementation
 * may rely on fetching data from IndexedDB which is async.
 * These Promises will only be rejected on an I/O error or other internal
 * (unexpected) failure (e.g. failed assert) and always represent an
 * unrecoverable error (should be caught / reported by the async_queue).
 */
var local_store_LocalStore = /** @class */function () {
    function LocalStore(
    /** Manages our in-memory or durable persistence. */
    persistence, initialUser,
    /**
     * The garbage collector collects documents that should no longer be
     * cached (e.g. if they are no longer retained by the above reference sets
     * and the garbage collector is performing eager collection).
     */
    garbageCollector) {
        this.persistence = persistence;
        this.garbageCollector = garbageCollector;
        /**
         * The set of document references maintained by any local views.
         */
        this.localViewReferences = new reference_set_ReferenceSet();
        /** Maps a targetID to data about its query. */
        this.targetIds = {};
        /** Used to generate targetIDs for queries tracked locally. */
        this.targetIdGenerator = TargetIdGenerator.forLocalStore();
        /**
         * A heldBatchResult is a mutation batch result (from a write acknowledgement)
         * that arrived before the watch stream got notified of a snapshot that
         * includes the write. So we "hold" it until the watch stream catches up. It
         * ensures that the local write remains visible (latency compensation) and
         * doesn't temporarily appear reverted because the watch stream is slower than
         * the write stream and so wasn't reflecting it.
         *
         * NOTE: Eventually we want to move this functionality into the remote store.
         */
        this.heldBatchResults = [];
        this.mutationQueue = persistence.getMutationQueue(initialUser);
        this.remoteDocuments = persistence.getRemoteDocumentCache();
        this.queryCache = persistence.getQueryCache();
        this.localDocuments = new local_documents_view_LocalDocumentsView(this.remoteDocuments, this.mutationQueue);
        this.garbageCollector.addGarbageSource(this.localViewReferences);
        this.garbageCollector.addGarbageSource(this.queryCache);
        this.garbageCollector.addGarbageSource(this.mutationQueue);
    }
    /** Performs any initial startup actions required by the local store. */
    LocalStore.prototype.start = function () {
        var _this = this;
        return this.persistence.runTransaction('Start LocalStore', function (txn) {
            return _this.startMutationQueue(txn).next(function () {
                return _this.startQueryCache(txn);
            });
        });
    };
    /**
     * Tells the LocalStore that the currently authenticated user has changed.
     *
     * In response the local store switches the mutation queue to the new user and
     * returns any resulting document changes.
     */
    LocalStore.prototype.handleUserChange = function (user) {
        var _this = this;
        return this.persistence.runTransaction('Handle user change', function (txn) {
            // Swap out the mutation queue, grabbing the pending mutation batches
            // before and after.
            var oldBatches;
            return _this.mutationQueue.getAllMutationBatches(txn).next(function (promisedOldBatches) {
                oldBatches = promisedOldBatches;
                _this.garbageCollector.removeGarbageSource(_this.mutationQueue);
                _this.mutationQueue = _this.persistence.getMutationQueue(user);
                _this.garbageCollector.addGarbageSource(_this.mutationQueue);
                return _this.startMutationQueue(txn);
            }).next(function () {
                // Recreate our LocalDocumentsView using the new
                // MutationQueue.
                _this.localDocuments = new local_documents_view_LocalDocumentsView(_this.remoteDocuments, _this.mutationQueue);
                return _this.mutationQueue.getAllMutationBatches(txn);
            }).next(function (newBatches) {
                // Union the old/new changed keys.
                var changedKeys = documentKeySet();
                for (var _i = 0, _a = [oldBatches, newBatches]; _i < _a.length; _i++) {
                    var batches = _a[_i];
                    for (var _b = 0, batches_1 = batches; _b < batches_1.length; _b++) {
                        var batch = batches_1[_b];
                        for (var _c = 0, _d = batch.mutations; _c < _d.length; _c++) {
                            var mutation = _d[_c];
                            changedKeys = changedKeys.add(mutation.key);
                        }
                    }
                }
                // Return the set of all (potentially) changed documents as the
                // result of the user change.
                return _this.localDocuments.getDocuments(txn, changedKeys);
            });
        });
    };
    LocalStore.prototype.startQueryCache = function (txn) {
        var _this = this;
        return this.queryCache.start(txn).next(function () {
            var targetId = _this.queryCache.getHighestTargetId();
            _this.targetIdGenerator = TargetIdGenerator.forLocalStore(targetId);
        });
    };
    LocalStore.prototype.startMutationQueue = function (txn) {
        var _this = this;
        return this.mutationQueue.start(txn).next(function () {
            // If we have any leftover mutation batch results from a prior run,
            // just drop them.
            // TODO(http://b/33446471): We probably need to repopulate
            // heldBatchResults or similar instead, but that is not
            // straightforward since we're not persisting the write ack versions.
            _this.heldBatchResults = [];
            return _this.mutationQueue.getHighestAcknowledgedBatchId(txn);
        }).next(function (highestAck) {
            // TODO(mikelehen): This is the only usage of
            // getAllMutationBatchesThroughBatchId(). Consider removing it in
            // favor of a getAcknowledgedBatches() method.
            if (highestAck !== BATCHID_UNKNOWN) {
                return _this.mutationQueue.getAllMutationBatchesThroughBatchId(txn, highestAck);
            } else {
                return persistence_promise_PersistencePromise.resolve([]);
            }
        }).next(function (ackedBatches) {
            if (ackedBatches.length > 0) {
                return _this.mutationQueue.removeMutationBatches(txn, ackedBatches);
            } else {
                return persistence_promise_PersistencePromise.resolve();
            }
        });
    };
    /* Accept locally generated Mutations and commit them to storage. */
    LocalStore.prototype.localWrite = function (mutations) {
        var _this = this;
        return this.persistence.runTransaction('Locally write mutations', function (txn) {
            var batch;
            var localWriteTime = timestamp_Timestamp.now();
            return _this.mutationQueue.addMutationBatch(txn, localWriteTime, mutations).next(function (promisedBatch) {
                batch = promisedBatch;
                // TODO(koss): This is doing an N^2 update by replaying ALL the
                // mutations on each document (instead of just the ones added) in
                // this batch.
                var keys = batch.keys();
                return _this.localDocuments.getDocuments(txn, keys);
            }).next(function (changedDocuments) {
                return { batchId: batch.batchId, changes: changedDocuments };
            });
        });
    };
    /**
     * Acknowledge the given batch.
     *
     * On the happy path when a batch is acknowledged, the local store will
     *
     *  + remove the batch from the mutation queue;
     *  + apply the changes to the remote document cache;
     *  + recalculate the latency compensated view implied by those changes (there
     *    may be mutations in the queue that affect the documents but haven't been
     *    acknowledged yet); and
     *  + give the changed documents back the sync engine
     *
     * @returns The resulting (modified) documents.
     */
    LocalStore.prototype.acknowledgeBatch = function (batchResult) {
        var _this = this;
        return this.persistence.runTransaction('Acknowledge batch', function (txn) {
            var affected;
            return _this.mutationQueue.acknowledgeBatch(txn, batchResult.batch, batchResult.streamToken).next(function () {
                if (_this.shouldHoldBatchResult(batchResult.commitVersion)) {
                    _this.heldBatchResults.push(batchResult);
                    affected = documentKeySet();
                    return persistence_promise_PersistencePromise.resolve();
                } else {
                    var documentBuffer_1 = new remote_document_change_buffer_RemoteDocumentChangeBuffer(_this.remoteDocuments);
                    return _this.releaseBatchResults(txn, [batchResult], documentBuffer_1).next(function (promisedAffectedKeys) {
                        affected = promisedAffectedKeys;
                        return documentBuffer_1.apply(txn);
                    });
                }
            }).next(function () {
                return _this.mutationQueue.performConsistencyCheck(txn);
            }).next(function () {
                return _this.localDocuments.getDocuments(txn, affected);
            });
        });
    };
    /**
     * Remove mutations from the MutationQueue for the specified batch;
     * LocalDocuments will be recalculated.
     *
     * @returns The resulting modified documents.
     */
    LocalStore.prototype.rejectBatch = function (batchId) {
        var _this = this;
        return this.persistence.runTransaction('Reject batch', function (txn) {
            var toReject;
            var affectedKeys;
            return _this.mutationQueue.lookupMutationBatch(txn, batchId).next(function (promisedToReject) {
                assert_assert(promisedToReject != null, 'Attempt to reject nonexistent batch!');
                toReject = promisedToReject;
                return _this.mutationQueue.getHighestAcknowledgedBatchId(txn).next(function (lastAcked) {
                    assert_assert(batchId > lastAcked, "Acknowledged batches can't be rejected.");
                    return toReject;
                });
            }).next(function () {
                return _this.removeMutationBatch(txn, toReject);
            }).next(function (promisedAffectedKeys) {
                affectedKeys = promisedAffectedKeys;
                return _this.mutationQueue.performConsistencyCheck(txn);
            }).next(function () {
                return _this.localDocuments.getDocuments(txn, affectedKeys);
            });
        });
    };
    /** Returns the last recorded stream token for the current user. */
    LocalStore.prototype.getLastStreamToken = function () {
        var _this = this;
        return this.persistence.runTransaction('Get last stream token', function (txn) {
            return _this.mutationQueue.getLastStreamToken(txn);
        });
    };
    /**
     * Sets the stream token for the current user without acknowledging any
     * mutation batch. This is usually only useful after a stream handshake or in
     * response to an error that requires clearing the stream token.
     */
    LocalStore.prototype.setLastStreamToken = function (streamToken) {
        var _this = this;
        return this.persistence.runTransaction('Set last stream token', function (txn) {
            return _this.mutationQueue.setLastStreamToken(txn, streamToken);
        });
    };
    /**
     * Returns the last consistent snapshot processed (used by the RemoteStore to
     * determine whether to buffer incoming snapshots from the backend).
     */
    LocalStore.prototype.getLastRemoteSnapshotVersion = function () {
        return this.queryCache.getLastRemoteSnapshotVersion();
    };
    /**
     * Update the "ground-state" (remote) documents. We assume that the remote
     * event reflects any write batches that have been acknowledged or rejected
     * (i.e. we do not re-apply local mutations to updates from this event).
     *
     * LocalDocuments are re-calculated if there are remaining mutations in the
     * queue.
     */
    LocalStore.prototype.applyRemoteEvent = function (remoteEvent) {
        var _this = this;
        var documentBuffer = new remote_document_change_buffer_RemoteDocumentChangeBuffer(this.remoteDocuments);
        return this.persistence.runTransaction('Apply remote event', function (txn) {
            var promises = [];
            forEachNumber(remoteEvent.targetChanges, function (targetId, change) {
                // Do not ref/unref unassigned targetIds - it may lead to leaks.
                var queryData = _this.targetIds[targetId];
                if (!queryData) return;
                var mapping = change.mapping;
                if (mapping) {
                    // First make sure that all references are deleted
                    if (mapping instanceof ResetMapping) {
                        promises.push(_this.queryCache.removeMatchingKeysForTargetId(txn, targetId).next(function () {
                            return _this.queryCache.addMatchingKeys(txn, mapping.documents, targetId);
                        }));
                    } else if (mapping instanceof UpdateMapping) {
                        promises.push(_this.queryCache.removeMatchingKeys(txn, mapping.removedDocuments, targetId).next(function () {
                            return _this.queryCache.addMatchingKeys(txn, mapping.addedDocuments, targetId);
                        }));
                    } else {
                        return fail('Unknown mapping type: ' + JSON.stringify(mapping));
                    }
                }
                // Update the resume token if the change includes one. Don't clear
                // any preexisting value.
                var resumeToken = change.resumeToken;
                if (resumeToken.length > 0) {
                    queryData = queryData.update({
                        resumeToken: resumeToken,
                        snapshotVersion: change.snapshotVersion
                    });
                    _this.targetIds[targetId] = queryData;
                    promises.push(_this.queryCache.addQueryData(txn, queryData));
                }
            });
            var changedDocKeys = documentKeySet();
            remoteEvent.documentUpdates.forEach(function (key, doc) {
                changedDocKeys = changedDocKeys.add(key);
                promises.push(documentBuffer.getEntry(txn, key).next(function (existingDoc) {
                    // Make sure we don't apply an old document version to the remote
                    // cache, though we make an exception for SnapshotVersion.MIN which
                    // can happen for manufactured events (e.g. in the case of a limbo
                    // document resolution failing).
                    if (existingDoc == null || doc.version.equals(snapshot_version_SnapshotVersion.MIN) || doc.version.compareTo(existingDoc.version) >= 0) {
                        documentBuffer.addEntry(doc);
                    } else {
                        debug(local_store_LOG_TAG, 'Ignoring outdated watch update for ', key, '. Current version:', existingDoc.version, ' Watch version:', doc.version);
                    }
                    // The document might be garbage because it was unreferenced by
                    // everything. Make sure to mark it as garbage if it is...
                    _this.garbageCollector.addPotentialGarbageKey(key);
                }));
            });
            // HACK: The only reason we allow a null snapshot version is so that we
            // can synthesize remote events when we get permission denied errors while
            // trying to resolve the state of a locally cached document that is in
            // limbo.
            var lastRemoteVersion = _this.queryCache.getLastRemoteSnapshotVersion();
            var remoteVersion = remoteEvent.snapshotVersion;
            if (!remoteVersion.equals(snapshot_version_SnapshotVersion.MIN)) {
                assert_assert(remoteVersion.compareTo(lastRemoteVersion) >= 0, 'Watch stream reverted to previous snapshot?? ' + remoteVersion + ' < ' + lastRemoteVersion);
                promises.push(_this.queryCache.setLastRemoteSnapshotVersion(txn, remoteVersion));
            }
            var releasedWriteKeys;
            return persistence_promise_PersistencePromise.waitFor(promises).next(function () {
                return _this.releaseHeldBatchResults(txn, documentBuffer);
            }).next(function (promisedReleasedWriteKeys) {
                releasedWriteKeys = promisedReleasedWriteKeys;
                return documentBuffer.apply(txn);
            }).next(function () {
                return _this.localDocuments.getDocuments(txn, changedDocKeys.unionWith(releasedWriteKeys));
            });
        });
    };
    /**
     * Notify local store of the changed views to locally pin documents.
     */
    LocalStore.prototype.notifyLocalViewChanges = function (viewChanges) {
        var _this = this;
        return this.persistence.runTransaction('Notify local view changes', function (txn) {
            var promises = [];
            var _loop_1 = function _loop_1(view) {
                promises.push(_this.queryCache.getQueryData(txn, view.query).next(function (queryData) {
                    assert_assert(queryData !== null, 'Local view changes contain unallocated query.');
                    var targetId = queryData.targetId;
                    _this.localViewReferences.addReferences(view.addedKeys, targetId);
                    _this.localViewReferences.removeReferences(view.removedKeys, targetId);
                }));
            };
            for (var _i = 0, viewChanges_1 = viewChanges; _i < viewChanges_1.length; _i++) {
                var view = viewChanges_1[_i];
                _loop_1(view);
            }
            return persistence_promise_PersistencePromise.waitFor(promises);
        });
    };
    /**
     * Gets the mutation batch after the passed in batchId in the mutation queue
     * or null if empty.
     * @param afterBatchId If provided, the batch to search after.
     * @returns The next mutation or null if there wasn't one.
     */
    LocalStore.prototype.nextMutationBatch = function (afterBatchId) {
        var _this = this;
        return this.persistence.runTransaction('Get next mutation batch', function (txn) {
            if (afterBatchId === undefined) {
                afterBatchId = BATCHID_UNKNOWN;
            }
            return _this.mutationQueue.getNextMutationBatchAfterBatchId(txn, afterBatchId);
        });
    };
    /**
     * Read the current value of a Document with a given key or null if not
     * found - used for testing.
     */
    LocalStore.prototype.readDocument = function (key) {
        var _this = this;
        return this.persistence.runTransaction('read document', function (txn) {
            return _this.localDocuments.getDocument(txn, key);
        });
    };
    /**
     * Assigns the given query an internal ID so that its results can be pinned so
     * they don't get GC'd. A query must be allocated in the local store before
     * the store can be used to manage its view.
     */
    LocalStore.prototype.allocateQuery = function (query) {
        var _this = this;
        return this.persistence.runTransaction('Allocate query', function (txn) {
            var queryData;
            return _this.queryCache.getQueryData(txn, query).next(function (cached) {
                if (cached) {
                    // This query has been listened to previously, so reuse the
                    // previous targetID.
                    // TODO(mcg): freshen last accessed date?
                    queryData = cached;
                    return persistence_promise_PersistencePromise.resolve();
                } else {
                    var targetId = _this.targetIdGenerator.next();
                    queryData = new query_data_QueryData(query, targetId, QueryPurpose.Listen);
                    return _this.queryCache.addQueryData(txn, queryData);
                }
            }).next(function () {
                assert_assert(!_this.targetIds[queryData.targetId], 'Tried to allocate an already allocated query: ' + query);
                _this.targetIds[queryData.targetId] = queryData;
                return queryData;
            });
        });
    };
    /** Unpin all the documents associated with the given query. */
    LocalStore.prototype.releaseQuery = function (query) {
        var _this = this;
        return this.persistence.runTransaction('Release query', function (txn) {
            return _this.queryCache.getQueryData(txn, query).next(function (queryData) {
                assert_assert(queryData != null, 'Tried to release nonexistent query: ' + query);
                _this.localViewReferences.removeReferencesForId(queryData.targetId);
                delete _this.targetIds[queryData.targetId];
                if (_this.garbageCollector.isEager) {
                    return _this.queryCache.removeQueryData(txn, queryData);
                } else {
                    return persistence_promise_PersistencePromise.resolve();
                }
            }).next(function () {
                // If this was the last watch target, then we won't get any more
                // watch snapshots, so we should release any held batch results.
                if (obj_isEmpty(_this.targetIds)) {
                    var documentBuffer_2 = new remote_document_change_buffer_RemoteDocumentChangeBuffer(_this.remoteDocuments);
                    return _this.releaseHeldBatchResults(txn, documentBuffer_2).next(function () {
                        documentBuffer_2.apply(txn);
                    });
                } else {
                    return persistence_promise_PersistencePromise.resolve();
                }
            });
        });
    };
    /**
     * Runs the specified query against all the documents in the local store and
     * returns the results.
     */
    LocalStore.prototype.executeQuery = function (query) {
        var _this = this;
        return this.persistence.runTransaction('Execute query', function (txn) {
            return _this.localDocuments.getDocumentsMatchingQuery(txn, query);
        });
    };
    /**
     * Returns the keys of the documents that are associated with the given
     * target id in the remote table.
     */
    LocalStore.prototype.remoteDocumentKeys = function (targetId) {
        var _this = this;
        return this.persistence.runTransaction('Remote document keys', function (txn) {
            return _this.queryCache.getMatchingKeysForTargetId(txn, targetId);
        });
    };
    /**
     * Collect garbage if necessary.
     * Should be called periodically by Sync Engine to recover resources. The
     * implementation must guarantee that GC won't happen in other places than
     * this method call.
     */
    LocalStore.prototype.collectGarbage = function () {
        var _this = this;
        // Call collectGarbage regardless of whether isGCEnabled so the referenceSet
        // doesn't continue to accumulate the garbage keys.
        return this.persistence.runTransaction('Garbage collection', function (txn) {
            return _this.garbageCollector.collectGarbage(txn).next(function (garbage) {
                var promises = [];
                garbage.forEach(function (key) {
                    promises.push(_this.remoteDocuments.removeEntry(txn, key));
                });
                return persistence_promise_PersistencePromise.waitFor(promises);
            });
        });
    };
    LocalStore.prototype.releaseHeldBatchResults = function (txn, documentBuffer) {
        var toRelease = [];
        for (var _i = 0, _a = this.heldBatchResults; _i < _a.length; _i++) {
            var batchResult = _a[_i];
            if (!this.isRemoteUpToVersion(batchResult.commitVersion)) {
                break;
            }
            toRelease.push(batchResult);
        }
        if (toRelease.length === 0) {
            return persistence_promise_PersistencePromise.resolve(documentKeySet());
        } else {
            this.heldBatchResults.splice(0, toRelease.length);
            return this.releaseBatchResults(txn, toRelease, documentBuffer);
        }
    };
    LocalStore.prototype.isRemoteUpToVersion = function (version) {
        // If there are no watch targets, then we won't get remote snapshots, and
        // we are always "up-to-date."
        var lastRemoteVersion = this.queryCache.getLastRemoteSnapshotVersion();
        return version.compareTo(lastRemoteVersion) <= 0 || obj_isEmpty(this.targetIds);
    };
    LocalStore.prototype.shouldHoldBatchResult = function (version) {
        // Check if watcher isn't up to date or prior results are already held.
        return !this.isRemoteUpToVersion(version) || this.heldBatchResults.length > 0;
    };
    LocalStore.prototype.releaseBatchResults = function (txn, batchResults, documentBuffer) {
        var _this = this;
        var promiseChain = persistence_promise_PersistencePromise.resolve();
        var _loop_2 = function _loop_2(batchResult) {
            promiseChain = promiseChain.next(function () {
                return _this.applyWriteToRemoteDocuments(txn, batchResult, documentBuffer);
            });
        };
        for (var _i = 0, batchResults_1 = batchResults; _i < batchResults_1.length; _i++) {
            var batchResult = batchResults_1[_i];
            _loop_2(batchResult);
        }
        return promiseChain.next(function () {
            return _this.removeMutationBatches(txn, batchResults.map(function (result) {
                return result.batch;
            }));
        });
    };
    LocalStore.prototype.removeMutationBatch = function (txn, batch) {
        return this.removeMutationBatches(txn, [batch]);
    };
    /** Removes all the mutation batches named in the given array. */
    LocalStore.prototype.removeMutationBatches = function (txn, batches) {
        var affectedDocs = documentKeySet();
        for (var _i = 0, batches_2 = batches; _i < batches_2.length; _i++) {
            var batch = batches_2[_i];
            for (var _a = 0, _b = batch.mutations; _a < _b.length; _a++) {
                var mutation = _b[_a];
                var key = mutation.key;
                affectedDocs = affectedDocs.add(key);
            }
        }
        return this.mutationQueue.removeMutationBatches(txn, batches).next(function () {
            return affectedDocs;
        });
    };
    LocalStore.prototype.applyWriteToRemoteDocuments = function (txn, batchResult, documentBuffer) {
        var batch = batchResult.batch;
        var docKeys = batch.keys();
        var promiseChain = persistence_promise_PersistencePromise.resolve();
        docKeys.forEach(function (docKey) {
            promiseChain = promiseChain.next(function () {
                return documentBuffer.getEntry(txn, docKey);
            }).next(function (remoteDoc) {
                var doc = remoteDoc;
                var ackVersion = batchResult.docVersions.get(docKey);
                assert_assert(ackVersion !== null, 'ackVersions should contain every doc in the write.');
                if (!doc || doc.version.compareTo(ackVersion) < 0) {
                    doc = batch.applyToRemoteDocument(docKey, doc, batchResult);
                    if (!doc) {
                        assert_assert(!remoteDoc, 'Mutation batch ' + batch + ' applied to document ' + remoteDoc + ' resulted in null');
                    } else {
                        documentBuffer.addEntry(doc);
                    }
                }
            });
        });
        return promiseChain;
    };
    return LocalStore;
}();


//# sourceMappingURL=local_store.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/local/memory_mutation_queue.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








var memory_mutation_queue_MemoryMutationQueue = /** @class */function () {
    function MemoryMutationQueue() {
        /**
         * The set of all mutations that have been sent but not yet been applied to
         * the backend.
         */
        this.mutationQueue = [];
        /** Next value to use when assigning sequential IDs to each mutation batch. */
        this.nextBatchId = 1;
        /** The highest acknowledged mutation in the queue. */
        this.highestAcknowledgedBatchId = BATCHID_UNKNOWN;
        /** The last received stream token from the server, used to acknowledge which
         * responses the client has processed. Stream tokens are opaque checkpoint
         * markers whose only real value is their inclusion in the next request.
         */
        this.lastStreamToken = emptyByteString();
        /** The garbage collector to notify about potential garbage keys. */
        this.garbageCollector = null;
        /** An ordered mapping between documents and the mutations batch IDs. */
        this.batchesByDocumentKey = new sorted_set_SortedSet(reference_set_DocReference.compareByKey);
    }
    MemoryMutationQueue.prototype.start = function (transaction) {
        // NOTE: The queue may be shutdown / started multiple times, since we
        // maintain the queue for the duration of the app session in case a user
        // logs out / back in. To behave like the LevelDB-backed MutationQueue (and
        // accommodate tests that expect as much), we reset nextBatchId and
        // highestAcknowledgedBatchId if the queue is empty.
        if (this.mutationQueue.length === 0) {
            this.nextBatchId = 1;
            this.highestAcknowledgedBatchId = BATCHID_UNKNOWN;
        }
        assert_assert(this.highestAcknowledgedBatchId < this.nextBatchId, 'highestAcknowledgedBatchId must be less than the nextBatchId');
        return persistence_promise_PersistencePromise.resolve();
    };
    MemoryMutationQueue.prototype.checkEmpty = function (transaction) {
        return persistence_promise_PersistencePromise.resolve(this.mutationQueue.length === 0);
    };
    MemoryMutationQueue.prototype.getNextBatchId = function (transaction) {
        return persistence_promise_PersistencePromise.resolve(this.nextBatchId);
    };
    MemoryMutationQueue.prototype.getHighestAcknowledgedBatchId = function (transaction) {
        return persistence_promise_PersistencePromise.resolve(this.highestAcknowledgedBatchId);
    };
    MemoryMutationQueue.prototype.acknowledgeBatch = function (transaction, batch, streamToken) {
        var batchId = batch.batchId;
        assert_assert(batchId > this.highestAcknowledgedBatchId, 'Mutation batchIDs must be acknowledged in order');
        var batchIndex = this.indexOfExistingBatchId(batchId, 'acknowledged');
        // Verify that the batch in the queue is the one to be acknowledged.
        var check = this.mutationQueue[batchIndex];
        assert_assert(batchId === check.batchId, 'Queue ordering failure: expected batch ' + batchId + ', got batch ' + check.batchId);
        assert_assert(!check.isTombstone(), "Can't acknowledge a previously removed batch");
        this.highestAcknowledgedBatchId = batchId;
        this.lastStreamToken = streamToken;
        return persistence_promise_PersistencePromise.resolve();
    };
    MemoryMutationQueue.prototype.getLastStreamToken = function (transaction) {
        return persistence_promise_PersistencePromise.resolve(this.lastStreamToken);
    };
    MemoryMutationQueue.prototype.setLastStreamToken = function (transaction, streamToken) {
        this.lastStreamToken = streamToken;
        return persistence_promise_PersistencePromise.resolve();
    };
    MemoryMutationQueue.prototype.addMutationBatch = function (transaction, localWriteTime, mutations) {
        assert_assert(mutations.length !== 0, 'Mutation batches should not be empty');
        var batchId = this.nextBatchId;
        this.nextBatchId++;
        if (this.mutationQueue.length > 0) {
            var prior = this.mutationQueue[this.mutationQueue.length - 1];
            assert_assert(prior.batchId < batchId, 'Mutation batchIDs must be monotonically increasing order');
        }
        var batch = new mutation_batch_MutationBatch(batchId, localWriteTime, mutations);
        this.mutationQueue.push(batch);
        // Track references by document key.
        for (var _i = 0, mutations_1 = mutations; _i < mutations_1.length; _i++) {
            var mutation = mutations_1[_i];
            this.batchesByDocumentKey = this.batchesByDocumentKey.add(new reference_set_DocReference(mutation.key, batchId));
        }
        return persistence_promise_PersistencePromise.resolve(batch);
    };
    MemoryMutationQueue.prototype.lookupMutationBatch = function (transaction, batchId) {
        return persistence_promise_PersistencePromise.resolve(this.findMutationBatch(batchId));
    };
    MemoryMutationQueue.prototype.getNextMutationBatchAfterBatchId = function (transaction, batchId) {
        var size = this.mutationQueue.length;
        // All batches with batchId <= this.highestAcknowledgedBatchId have been
        // acknowledged so the first unacknowledged batch after batchID will have a
        // batchID larger than both of these values.
        batchId = Math.max(batchId + 1, this.highestAcknowledgedBatchId);
        // The requested batchId may still be out of range so normalize it to the
        // start of the queue.
        var rawIndex = this.indexOfBatchId(batchId);
        var index = rawIndex < 0 ? 0 : rawIndex;
        // Finally return the first non-tombstone batch.
        for (; index < size; index++) {
            var batch = this.mutationQueue[index];
            if (!batch.isTombstone()) {
                return persistence_promise_PersistencePromise.resolve(batch);
            }
        }
        return persistence_promise_PersistencePromise.resolve(null);
    };
    MemoryMutationQueue.prototype.getAllMutationBatches = function (transaction) {
        return persistence_promise_PersistencePromise.resolve(this.getAllLiveMutationBatchesBeforeIndex(this.mutationQueue.length));
    };
    MemoryMutationQueue.prototype.getAllMutationBatchesThroughBatchId = function (transaction, batchId) {
        var count = this.mutationQueue.length;
        var endIndex = this.indexOfBatchId(batchId);
        if (endIndex < 0) {
            endIndex = 0;
        } else if (endIndex >= count) {
            endIndex = count;
        } else {
            // The endIndex is in the queue so increment to pull everything in the
            // queue including it.
            endIndex++;
        }
        return persistence_promise_PersistencePromise.resolve(this.getAllLiveMutationBatchesBeforeIndex(endIndex));
    };
    MemoryMutationQueue.prototype.getAllMutationBatchesAffectingDocumentKey = function (transaction, documentKey) {
        var _this = this;
        var start = new reference_set_DocReference(documentKey, 0);
        var end = new reference_set_DocReference(documentKey, Number.POSITIVE_INFINITY);
        var result = [];
        this.batchesByDocumentKey.forEachInRange([start, end], function (ref) {
            assert_assert(documentKey.equals(ref.key), "Should only iterate over a single key's batches");
            var batch = _this.findMutationBatch(ref.targetOrBatchId);
            assert_assert(batch !== null, 'Batches in the index must exist in the main table');
            result.push(batch);
        });
        return persistence_promise_PersistencePromise.resolve(result);
    };
    MemoryMutationQueue.prototype.getAllMutationBatchesAffectingQuery = function (transaction, query) {
        var _this = this;
        // Use the query path as a prefix for testing if a document matches the
        // query.
        var prefix = query.path;
        var immediateChildrenPathLength = prefix.length + 1;
        // Construct a document reference for actually scanning the index. Unlike
        // the prefix the document key in this reference must have an even number of
        // segments. The empty segment can be used a suffix of the query path
        // because it precedes all other segments in an ordered traversal.
        var startPath = prefix;
        if (!document_key_DocumentKey.isDocumentKey(startPath)) {
            startPath = startPath.child('');
        }
        var start = new reference_set_DocReference(new document_key_DocumentKey(startPath), 0);
        // Find unique batchIDs referenced by all documents potentially matching the
        // query.
        var uniqueBatchIDs = new sorted_set_SortedSet(primitiveComparator);
        this.batchesByDocumentKey.forEachWhile(function (ref) {
            var rowKeyPath = ref.key.path;
            if (!prefix.isPrefixOf(rowKeyPath)) {
                return false;
            } else {
                // Rows with document keys more than one segment longer than the query
                // path can't be matches. For example, a query on 'rooms' can't match
                // the document /rooms/abc/messages/xyx.
                // TODO(mcg): we'll need a different scanner when we implement
                // ancestor queries.
                if (rowKeyPath.length === immediateChildrenPathLength) {
                    uniqueBatchIDs = uniqueBatchIDs.add(ref.targetOrBatchId);
                }
                return true;
            }
        }, start);
        // Construct an array of matching batches, sorted by batchID to ensure that
        // multiple mutations affecting the same document key are applied in order.
        var result = [];
        uniqueBatchIDs.forEach(function (batchId) {
            var batch = _this.findMutationBatch(batchId);
            if (batch !== null) {
                result.push(batch);
            }
        });
        return persistence_promise_PersistencePromise.resolve(result);
    };
    MemoryMutationQueue.prototype.removeMutationBatches = function (transaction, batches) {
        var batchCount = batches.length;
        assert_assert(batchCount > 0, 'Should not remove mutations when none exist.');
        var firstBatchId = batches[0].batchId;
        var queueCount = this.mutationQueue.length;
        // Find the position of the first batch for removal. This need not be the
        // first entry in the queue.
        var startIndex = this.indexOfExistingBatchId(firstBatchId, 'removed');
        assert_assert(this.mutationQueue[startIndex].batchId === firstBatchId, 'Removed batches must exist in the queue');
        // Check that removed batches are contiguous (while excluding tombstones).
        var batchIndex = 1;
        var queueIndex = startIndex + 1;
        while (batchIndex < batchCount && queueIndex < queueCount) {
            var batch = this.mutationQueue[queueIndex];
            if (batch.isTombstone()) {
                queueIndex++;
                continue;
            }
            assert_assert(batch.batchId === batches[batchIndex].batchId, 'Removed batches must be contiguous in the queue');
            batchIndex++;
            queueIndex++;
        }
        // Only actually remove batches if removing at the front of the queue.
        // Previously rejected batches may have left tombstones in the queue, so
        // expand the removal range to include any tombstones.
        if (startIndex === 0) {
            for (; queueIndex < queueCount; queueIndex++) {
                var batch = this.mutationQueue[queueIndex];
                if (!batch.isTombstone()) {
                    break;
                }
            }
            var length_1 = queueIndex - startIndex;
            this.mutationQueue.splice(startIndex, length_1);
        } else {
            // Mark the tombstones
            for (var i = startIndex; i < queueIndex; i++) {
                this.mutationQueue[i] = this.mutationQueue[i].toTombstone();
            }
        }
        var references = this.batchesByDocumentKey;
        for (var _i = 0, batches_1 = batches; _i < batches_1.length; _i++) {
            var batch = batches_1[_i];
            var batchId = batch.batchId;
            for (var _a = 0, _b = batch.mutations; _a < _b.length; _a++) {
                var mutation = _b[_a];
                var key = mutation.key;
                if (this.garbageCollector !== null) {
                    this.garbageCollector.addPotentialGarbageKey(key);
                }
                var ref = new reference_set_DocReference(key, batchId);
                references = references.delete(ref);
            }
        }
        this.batchesByDocumentKey = references;
        return persistence_promise_PersistencePromise.resolve();
    };
    MemoryMutationQueue.prototype.setGarbageCollector = function (garbageCollector) {
        this.garbageCollector = garbageCollector;
    };
    MemoryMutationQueue.prototype.containsKey = function (txn, key) {
        var ref = new reference_set_DocReference(key, 0);
        var firstRef = this.batchesByDocumentKey.firstAfterOrEqual(ref);
        return persistence_promise_PersistencePromise.resolve(key.equals(firstRef && firstRef.key));
    };
    MemoryMutationQueue.prototype.performConsistencyCheck = function (txn) {
        if (this.mutationQueue.length === 0) {
            assert_assert(this.batchesByDocumentKey.isEmpty(), 'Document leak -- detected dangling mutation references when queue is empty.');
        }
        return persistence_promise_PersistencePromise.resolve();
    };
    /**
     * A private helper that collects all the mutations batches in the queue up to
     * but not including the given endIndex. All tombstones in the queue are
     * excluded.
     */
    MemoryMutationQueue.prototype.getAllLiveMutationBatchesBeforeIndex = function (endIndex) {
        var result = [];
        for (var i = 0; i < endIndex; i++) {
            var batch = this.mutationQueue[i];
            if (!batch.isTombstone()) {
                result.push(batch);
            }
        }
        return result;
    };
    /**
     * Finds the index of the given batchId in the mutation queue and asserts that
     * the resulting index is within the bounds of the queue.
     *
     * @param batchId The batchId to search for
     * @param action A description of what the caller is doing, phrased in passive
     * form (e.g. "acknowledged" in a routine that acknowledges batches).
     */
    MemoryMutationQueue.prototype.indexOfExistingBatchId = function (batchId, action) {
        var index = this.indexOfBatchId(batchId);
        assert_assert(index >= 0 && index < this.mutationQueue.length, 'Batches must exist to be ' + action);
        return index;
    };
    /**
     * Finds the index of the given batchId in the mutation queue. This operation
     * is O(1).
     *
     * @return The computed index of the batch with the given batchId, based on
     * the state of the queue. Note this index can be negative if the requested
     * batchId has already been remvoed from the queue or past the end of the
     * queue if the batchId is larger than the last added batch.
     */
    MemoryMutationQueue.prototype.indexOfBatchId = function (batchId) {
        if (this.mutationQueue.length === 0) {
            // As an index this is past the end of the queue
            return 0;
        }
        // Examine the front of the queue to figure out the difference between the
        // batchId and indexes in the array. Note that since the queue is ordered
        // by batchId, if the first batch has a larger batchId then the requested
        // batchId doesn't exist in the queue.
        var firstBatchId = this.mutationQueue[0].batchId;
        return batchId - firstBatchId;
    };
    /**
     * A version of lookupMutationBatch that doesn't return a promise, this makes
     * other functions that uses this code easier to read and more efficent.
     */
    MemoryMutationQueue.prototype.findMutationBatch = function (batchId) {
        var index = this.indexOfBatchId(batchId);
        if (index < 0 || index >= this.mutationQueue.length) {
            return null;
        }
        var batch = this.mutationQueue[index];
        assert_assert(batch.batchId === batchId, 'If found batch must match');
        return batch.isTombstone() ? null : batch;
    };
    return MemoryMutationQueue;
}();


//# sourceMappingURL=memory_mutation_queue.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/local/memory_query_cache.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var memory_query_cache_MemoryQueryCache = /** @class */function () {
    function MemoryQueryCache() {
        /**
         * Maps a query to the data about that query
         */
        this.queries = new obj_map_ObjectMap(function (q) {
            return q.canonicalId();
        });
        /** The last received snapshot version. */
        this.lastRemoteSnapshotVersion = snapshot_version_SnapshotVersion.MIN;
        /** The highest numbered target ID encountered. */
        this.highestTargetId = 0;
        /**
         * A ordered bidirectional mapping between documents and the remote target
         * IDs.
         */
        this.references = new reference_set_ReferenceSet();
    }
    MemoryQueryCache.prototype.start = function (transaction) {
        // Nothing to do.
        return persistence_promise_PersistencePromise.resolve();
    };
    MemoryQueryCache.prototype.getLastRemoteSnapshotVersion = function () {
        return this.lastRemoteSnapshotVersion;
    };
    MemoryQueryCache.prototype.getHighestTargetId = function () {
        return this.highestTargetId;
    };
    MemoryQueryCache.prototype.setLastRemoteSnapshotVersion = function (transaction, snapshotVersion) {
        this.lastRemoteSnapshotVersion = snapshotVersion;
        return persistence_promise_PersistencePromise.resolve();
    };
    MemoryQueryCache.prototype.addQueryData = function (transaction, queryData) {
        this.queries.set(queryData.query, queryData);
        var targetId = queryData.targetId;
        if (targetId > this.highestTargetId) {
            this.highestTargetId = targetId;
        }
        return persistence_promise_PersistencePromise.resolve();
    };
    MemoryQueryCache.prototype.removeQueryData = function (transaction, queryData) {
        this.queries.delete(queryData.query);
        this.references.removeReferencesForId(queryData.targetId);
        return persistence_promise_PersistencePromise.resolve();
    };
    MemoryQueryCache.prototype.getQueryData = function (transaction, query) {
        var queryData = this.queries.get(query) || null;
        return persistence_promise_PersistencePromise.resolve(queryData);
    };
    MemoryQueryCache.prototype.addMatchingKeys = function (txn, keys, targetId) {
        this.references.addReferences(keys, targetId);
        return persistence_promise_PersistencePromise.resolve();
    };
    MemoryQueryCache.prototype.removeMatchingKeys = function (txn, keys, targetId) {
        this.references.removeReferences(keys, targetId);
        return persistence_promise_PersistencePromise.resolve();
    };
    MemoryQueryCache.prototype.removeMatchingKeysForTargetId = function (txn, targetId) {
        this.references.removeReferencesForId(targetId);
        return persistence_promise_PersistencePromise.resolve();
    };
    MemoryQueryCache.prototype.getMatchingKeysForTargetId = function (txn, targetId) {
        var matchingKeys = this.references.referencesForId(targetId);
        return persistence_promise_PersistencePromise.resolve(matchingKeys);
    };
    MemoryQueryCache.prototype.setGarbageCollector = function (gc) {
        this.references.setGarbageCollector(gc);
    };
    MemoryQueryCache.prototype.containsKey = function (txn, key) {
        return this.references.containsKey(txn, key);
    };
    return MemoryQueryCache;
}();


//# sourceMappingURL=memory_query_cache.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/local/memory_remote_document_cache.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var memory_remote_document_cache_MemoryRemoteDocumentCache = /** @class */function () {
    function MemoryRemoteDocumentCache() {
        this.docs = maybeDocumentMap();
    }
    MemoryRemoteDocumentCache.prototype.addEntry = function (transaction, maybeDocument) {
        this.docs = this.docs.insert(maybeDocument.key, maybeDocument);
        return persistence_promise_PersistencePromise.resolve();
    };
    MemoryRemoteDocumentCache.prototype.removeEntry = function (transaction, documentKey) {
        this.docs = this.docs.remove(documentKey);
        return persistence_promise_PersistencePromise.resolve();
    };
    MemoryRemoteDocumentCache.prototype.getEntry = function (transaction, documentKey) {
        return persistence_promise_PersistencePromise.resolve(this.docs.get(documentKey));
    };
    MemoryRemoteDocumentCache.prototype.getDocumentsMatchingQuery = function (transaction, query) {
        var results = documentMap();
        // Documents are ordered by key, so we can use a prefix scan to narrow down
        // the documents we need to match the query against.
        var prefix = new document_key_DocumentKey(query.path.child(''));
        var iterator = this.docs.getIteratorFrom(prefix);
        while (iterator.hasNext()) {
            var _a = iterator.getNext(),
                key = _a.key,
                maybeDoc = _a.value;
            if (!query.path.isPrefixOf(key.path)) {
                break;
            }
            if (maybeDoc instanceof document_Document && query.matches(maybeDoc)) {
                results = results.insert(maybeDoc.key, maybeDoc);
            }
        }
        return persistence_promise_PersistencePromise.resolve(results);
    };
    return MemoryRemoteDocumentCache;
}();


//# sourceMappingURL=memory_remote_document_cache.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/local/memory_persistence.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





var memory_persistence_LOG_TAG = 'MemoryPersistence';
/**
 * A memory-backed instance of Persistence. Data is stored only in RAM and
 * not persisted across sessions.
 */
var memory_persistence_MemoryPersistence = /** @class */function () {
    function MemoryPersistence() {
        /**
         * Note that these are retained here to make it easier to write tests
         * affecting both the in-memory and IndexedDB-backed persistence layers. Tests
         * can create a new LocalStore wrapping this Persistence instance and this
         * will make the in-memory persistence layer behave as if it were actually
         * persisting values.
         */
        this.mutationQueues = {};
        this.remoteDocumentCache = new memory_remote_document_cache_MemoryRemoteDocumentCache();
        this.queryCache = new memory_query_cache_MemoryQueryCache();
        this.started = false;
    }
    MemoryPersistence.prototype.start = function () {
        assert_assert(!this.started, 'MemoryPersistence double-started!');
        this.started = true;
        // No durable state to read on startup.
        return Promise.resolve();
    };
    MemoryPersistence.prototype.shutdown = function () {
        // No durable state to ensure is closed on shutdown.
        assert_assert(this.started, 'MemoryPersistence shutdown without start!');
        this.started = false;
        return Promise.resolve();
    };
    MemoryPersistence.prototype.getMutationQueue = function (user) {
        var queue = this.mutationQueues[user.toKey()];
        if (!queue) {
            queue = new memory_mutation_queue_MemoryMutationQueue();
            this.mutationQueues[user.toKey()] = queue;
        }
        return queue;
    };
    MemoryPersistence.prototype.getQueryCache = function () {
        return this.queryCache;
    };
    MemoryPersistence.prototype.getRemoteDocumentCache = function () {
        return this.remoteDocumentCache;
    };
    MemoryPersistence.prototype.runTransaction = function (action, operation) {
        debug(memory_persistence_LOG_TAG, 'Starting transaction:', action);
        return operation(new MemoryPersistenceTransaction()).toPromise();
    };
    return MemoryPersistence;
}();

/** Dummy class since memory persistence doesn't actually use transactions. */
var MemoryPersistenceTransaction = /** @class */function () {
    function MemoryPersistenceTransaction() {}
    return MemoryPersistenceTransaction;
}();

//# sourceMappingURL=memory_persistence.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/local/no_op_garbage_collector.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * A garbage collector implementation that does absolutely nothing. It ignores
 * all addGarbageSource and addPotentialGarbageKey messages and and never
 * produces any garbage.
 */
var no_op_garbage_collector_NoOpGarbageCollector = /** @class */function () {
    function NoOpGarbageCollector() {
        this.isEager = false;
    }
    NoOpGarbageCollector.prototype.addGarbageSource = function (garbageSource) {
        // Not tracking garbage so don't track sources.
    };
    NoOpGarbageCollector.prototype.removeGarbageSource = function (garbageSource) {
        // Not tracking garbage so don't track sources.
    };
    NoOpGarbageCollector.prototype.addPotentialGarbageKey = function (key) {
        // Not tracking garbage so ignore.
    };
    NoOpGarbageCollector.prototype.collectGarbage = function (txn) {
        return persistence_promise_PersistencePromise.resolve(documentKeySet());
    };
    return NoOpGarbageCollector;
}();


//# sourceMappingURL=no_op_garbage_collector.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/util/promise.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var promise_Deferred = /** @class */function () {
    function Deferred() {
        var _this = this;
        this.promise = new Promise(function (resolve, reject) {
            _this.resolve = resolve;
            _this.reject = reject;
        });
    }
    return Deferred;
}();

/**
 * Takes an array of values and sequences them using the promise (or value)
 * returned by the supplied callback. The callback for each item is called
 * after the promise is resolved for the previous item.
 * The function returns a promise which is resolved after the promise for
 * the last item is resolved.
 */
function sequence(values, fn, initialValue) {
    var result = Promise.resolve(initialValue);
    values.forEach(function (value) {
        result = result.then(function (lastResult) {
            return fn(value, lastResult);
        });
    });
    return result;
}

//# sourceMappingURL=promise.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/remote/backoff.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var backoff_LOG_TAG = 'ExponentialBackoff';
/**
 * A helper for running delayed tasks following an exponential backoff curve
 * between attempts.
 *
 * Each delay is made up of a "base" delay which follows the exponential
 * backoff curve, and a +/- 50% "jitter" that is calculated and added to the
 * base delay. This prevents clients from accidentally synchronizing their
 * delays causing spikes of load to the backend.
 */
var backoff_ExponentialBackoff = /** @class */function () {
    function ExponentialBackoff(
    /**
     * The initial delay (used as the base delay on the first retry attempt).
     * Note that jitter will still be applied, so the actual delay could be as
     * little as 0.5*initialDelayMs.
     */
    initialDelayMs,
    /**
     * The multiplier to use to determine the extended base delay after each
     * attempt.
     */
    backoffFactor,
    /**
     * The maximum base delay after which no further backoff is performed.
     * Note that jitter will still be applied, so the actual delay could be as
     * much as 1.5*maxDelayMs.
     */
    maxDelayMs) {
        this.initialDelayMs = initialDelayMs;
        this.backoffFactor = backoffFactor;
        this.maxDelayMs = maxDelayMs;
        this.reset();
    }
    /**
     * Resets the backoff delay.
     *
     * The very next backoffAndWait() will have no delay. If it is called again
     * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and
     * subsequent ones will increase according to the backoffFactor.
     */
    ExponentialBackoff.prototype.reset = function () {
        this.currentBaseMs = 0;
    };
    /**
     * Resets the backoff delay to the maximum delay (e.g. for use after a
     * RESOURCE_EXHAUSTED error).
     */
    ExponentialBackoff.prototype.resetToMax = function () {
        this.currentBaseMs = this.maxDelayMs;
    };
    /**
     * Returns a promise that resolves after currentDelayMs, and increases the
     * delay for any subsequent attempts.
     */
    ExponentialBackoff.prototype.backoffAndWait = function () {
        var def = new promise_Deferred();
        // First schedule using the current base (which may be 0 and should be
        // honored as such).
        var delayWithJitterMs = this.currentBaseMs + this.jitterDelayMs();
        if (this.currentBaseMs > 0) {
            debug(backoff_LOG_TAG, "Backing off for " + delayWithJitterMs + " ms " + ("(base delay: " + this.currentBaseMs + " ms)"));
        }
        setTimeout(function () {
            def.resolve();
        }, delayWithJitterMs);
        // Apply backoff factor to determine next delay and ensure it is within
        // bounds.
        this.currentBaseMs *= this.backoffFactor;
        if (this.currentBaseMs < this.initialDelayMs) {
            this.currentBaseMs = this.initialDelayMs;
        }
        if (this.currentBaseMs > this.maxDelayMs) {
            this.currentBaseMs = this.maxDelayMs;
        }
        return def.promise;
    };
    /** Returns a random value in the range [-currentBaseMs/2, currentBaseMs/2] */
    ExponentialBackoff.prototype.jitterDelayMs = function () {
        return (Math.random() - 0.5) * this.currentBaseMs;
    };
    return ExponentialBackoff;
}();


//# sourceMappingURL=backoff.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/remote/persistent_stream.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var persistent_stream___extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();





var persistent_stream_LOG_TAG = 'PersistentStream';
var PersistentStreamState;
(function (PersistentStreamState) {
    /**
     * The streaming RPC is not running and there's no error condition.
     * Calling `start` will start the stream immediately without backoff.
     * While in this state isStarted will return false.
     */
    PersistentStreamState[PersistentStreamState["Initial"] = 0] = "Initial";
    /**
     * The stream is starting, and is waiting for an auth token to attach to
     * the initial request. While in this state, isStarted will return
     * true but isOpen will return false.
     */
    PersistentStreamState[PersistentStreamState["Auth"] = 1] = "Auth";
    /**
     * The streaming RPC is up and running. Requests and responses can flow
     * freely. Both isStarted and isOpen will return true.
     */
    PersistentStreamState[PersistentStreamState["Open"] = 2] = "Open";
    /**
     * The stream encountered an error. The next start attempt will back off.
     * While in this state isStarted() will return false.
     *
     */
    PersistentStreamState[PersistentStreamState["Error"] = 3] = "Error";
    /**
     * An in-between state after an error where the stream is waiting before
     * re-starting. After
     * waiting is complete, the stream will try to open. While in this
     * state isStarted() will return YES but isOpen will return false.
     */
    PersistentStreamState[PersistentStreamState["Backoff"] = 4] = "Backoff";
    /**
     * The stream has been explicitly stopped; no further events will be emitted.
     */
    PersistentStreamState[PersistentStreamState["Stopped"] = 5] = "Stopped";
})(PersistentStreamState || (PersistentStreamState = {}));
/**
 * Initial backoff time in milliseconds after an error.
 * Set to 1s according to https://cloud.google.com/apis/design/errors.
 */
var BACKOFF_INITIAL_DELAY_MS = 1000;
/** Maximum backoff time in milliseconds */
var BACKOFF_MAX_DELAY_MS = 60 * 1000;
var BACKOFF_FACTOR = 1.5;
/** The time a stream stays open after it is marked idle. */
var IDLE_TIMEOUT_MS = 60 * 1000;
/**
 * A PersistentStream is an abstract base class that represents a streaming RPC
 * to the Firestore backend. It's built on top of the connections own support
 * for streaming RPCs, and adds several critical features for our clients:
 *
 *   - Exponential backoff on failure
 *   - Authentication via CredentialsProvider
 *   - Dispatching all callbacks into the shared worker queue
 *
 * Subclasses of PersistentStream implement serialization of models to and
 * from the JSON representation of the protocol buffers for a specific
 * streaming RPC.
 *
 * ## Starting and Stopping
 *
 * Streaming RPCs are stateful and need to be `start`ed before messages can
 * be sent and received. The PersistentStream will call the onOpen function
 * of the listener once the stream is ready to accept requests.
 *
 * Should a `start` fail, PersistentStream will call the registered
 * onClose with a FirestoreError indicating what went wrong.
 *
 * A PersistentStream can be started and stopped repeatedly.
 *
 * Generic types:
 *  SendType: The type of the outgoing message of the underlying
 *    connection stream
 *  ReceiveType: The type of the incoming message of the underlying
 *    connection stream
 *  ListenerType: The type of the listener that will be used for callbacks
 */
var persistent_stream_PersistentStream = /** @class */function () {
    function PersistentStream(queue, connection, credentialsProvider,
    // Used for faster retries in testing
    initialBackoffDelay) {
        this.queue = queue;
        this.connection = connection;
        this.credentialsProvider = credentialsProvider;
        this.idle = false;
        this.stream = null;
        this.listener = null;
        this.backoff = new backoff_ExponentialBackoff(initialBackoffDelay ? initialBackoffDelay : BACKOFF_INITIAL_DELAY_MS, BACKOFF_FACTOR, BACKOFF_MAX_DELAY_MS);
        this.state = PersistentStreamState.Initial;
    }
    /**
     * Returns true if `start` has been called and no error has occurred. True
     * indicates the stream is open or in the process of opening (which
     * encompasses respecting backoff, getting auth tokens, and starting the
     * actual RPC). Use `isOpen` to determine if the stream is open and ready for
     * outbound requests.
     */
    PersistentStream.prototype.isStarted = function () {
        return this.state === PersistentStreamState.Backoff || this.state === PersistentStreamState.Auth || this.state === PersistentStreamState.Open;
    };
    /**
     * Returns true if the underlying RPC is open (the openHandler has been
     * called) and the stream is ready for outbound requests.
     */
    PersistentStream.prototype.isOpen = function () {
        return this.state === PersistentStreamState.Open;
    };
    /**
     * Starts the RPC. Only allowed if isStarted returns false. The stream is
     * not immediately ready for use: onOpen will be invoked when the RPC is ready
     * for outbound requests, at which point isOpen will return true.
     *
     *  When start returns, isStarted will return true.
     */
    PersistentStream.prototype.start = function (listener) {
        if (this.state === PersistentStreamState.Error) {
            this.performBackoff(listener);
            return;
        }
        assert_assert(this.state === PersistentStreamState.Initial, 'Already started');
        this.listener = listener;
        this.auth();
    };
    /**
     * Stops the RPC. This call is idempotent and allowed regardless of the
     * current isStarted state.
     *
     * When stop returns, isStarted and isOpen will both return false.
     */
    PersistentStream.prototype.stop = function () {
        if (this.isStarted()) {
            this.close(PersistentStreamState.Stopped);
        }
    };
    /**
     * After an error the stream will usually back off on the next attempt to
     * start it. If the error warrants an immediate restart of the stream, the
     * sender can use this to indicate that the receiver should not back off.
     *
     * Each error will call the onClose function. That function can decide to
     * inhibit backoff if required.
     */
    PersistentStream.prototype.inhibitBackoff = function () {
        assert_assert(!this.isStarted(), 'Can only inhibit backoff in a stopped state');
        this.state = PersistentStreamState.Initial;
        this.backoff.reset();
    };
    /**
     * Initializes the idle timer. If no write takes place within one minute, the
     * WebChannel stream will be closed.
     */
    PersistentStream.prototype.markIdle = function () {
        var _this = this;
        this.idle = true;
        this.queue.schedule(function () {
            return _this.handleIdleCloseTimer();
        }, IDLE_TIMEOUT_MS).catch(function (err) {
            // When the AsyncQueue gets drained during testing, pending Promises
            // (including these idle checks) will get rejected. We special-case
            // these cancelled idle checks to make sure that these specific Promise
            // rejections are not considered unhandled.
            assert_assert(err.code === Code.CANCELLED, "Received unexpected error in idle timeout closure. Expected CANCELLED, but was: " + err);
        });
    };
    /** Sends a message to the underlying stream. */
    PersistentStream.prototype.sendRequest = function (msg) {
        this.cancelIdleCheck();
        this.stream.send(msg);
    };
    /** Called by the idle timer when the stream should close due to inactivity. */
    PersistentStream.prototype.handleIdleCloseTimer = function () {
        if (this.isOpen() && this.idle) {
            // When timing out an idle stream there's no reason to force the stream into backoff when
            // it restarts so set the stream state to Initial instead of Error.
            return this.close(PersistentStreamState.Initial);
        }
        return Promise.resolve();
    };
    /** Marks the stream as active again. */
    PersistentStream.prototype.cancelIdleCheck = function () {
        this.idle = false;
    };
    /**
     * Closes the stream and cleans up as necessary:
     *
     * * closes the underlying GRPC stream;
     * * calls the onClose handler with the given 'error';
     * * sets internal stream state to 'finalState';
     * * adjusts the backoff timer based on the error
     *
     * A new stream can be opened by calling `start` unless `finalState` is set to
     * `PersistentStreamState.Stopped`.
     *
     * @param finalState the intended state of the stream after closing.
     * @param error the error the connection was closed with.
     */
    PersistentStream.prototype.close = function (finalState, error) {
        assert_assert(finalState == PersistentStreamState.Error || isNullOrUndefined(error), "Can't provide an error when not in an error state.");
        this.cancelIdleCheck();
        if (finalState != PersistentStreamState.Error) {
            // If this is an intentional close ensure we don't delay our next connection attempt.
            this.backoff.reset();
        } else if (error && error.code === Code.RESOURCE_EXHAUSTED) {
            debug(persistent_stream_LOG_TAG, 'Using maximum backoff delay to prevent overloading the backend.');
            this.backoff.resetToMax();
        }
        // Clean up the underlying stream because we are no longer interested in events.
        if (this.stream !== null) {
            this.tearDown();
            this.stream.close();
            this.stream = null;
        }
        // This state must be assigned before calling onClose() to allow the callback to
        // inhibit backoff or otherwise manipulate the state in its non-started state.
        this.state = finalState;
        var listener = this.listener;
        // Clear the listener to avoid bleeding of events from the underlying streams.
        this.listener = null;
        // If the caller explicitly requested a stream stop, don't notify them of a closing stream (it
        // could trigger undesirable recovery logic, etc.).
        if (finalState != PersistentStreamState.Stopped) {
            return listener.onClose(error);
        } else {
            return Promise.resolve();
        }
    };
    /**
     * Can be overridden to perform additional cleanup before the stream is closed.
     * Calling super.tearDown() is not required.
     */
    PersistentStream.prototype.tearDown = function () {};
    PersistentStream.prototype.auth = function () {
        var _this = this;
        assert_assert(this.state === PersistentStreamState.Initial, 'Must be in initial state to auth');
        this.state = PersistentStreamState.Auth;
        this.credentialsProvider.getToken( /*forceRefresh=*/false).then(function (token) {
            // Normally we'd have to schedule the callback on the AsyncQueue.
            // However, the following calls are safe to be called outside the
            // AsyncQueue since they don't chain asynchronous calls
            _this.startStream(token);
        }, function (error) {
            _this.queue.schedule(function () {
                if (_this.state !== PersistentStreamState.Stopped) {
                    // Stream can be stopped while waiting for authorization.
                    var rpcError = new FirestoreError(Code.UNKNOWN, 'Fetching auth token failed: ' + error.message);
                    return _this.handleStreamClose(rpcError);
                } else {
                    return Promise.resolve();
                }
            });
        });
    };
    PersistentStream.prototype.startStream = function (token) {
        var _this = this;
        if (this.state === PersistentStreamState.Stopped) {
            // Stream can be stopped while waiting for authorization.
            return;
        }
        assert_assert(this.state === PersistentStreamState.Auth, 'Trying to start stream in a non-auth state');
        // Helper function to dispatch to AsyncQueue and make sure that any
        // close will seem instantaneous and events are prevented from being
        // raised after the close call
        var dispatchIfStillActive = function dispatchIfStillActive(stream, fn) {
            _this.queue.schedule(function () {
                // Only raise events if the stream instance has not changed
                if (_this.stream === stream) {
                    return fn();
                } else {
                    return Promise.resolve();
                }
            });
        };
        // Only start stream if listener has not changed
        if (this.listener !== null) {
            var currentStream_1 = this.startRpc(token);
            this.stream = currentStream_1;
            this.stream.onOpen(function () {
                dispatchIfStillActive(currentStream_1, function () {
                    assert_assert(_this.state === PersistentStreamState.Auth, 'Expected stream to be in state auth, but was ' + _this.state);
                    _this.state = PersistentStreamState.Open;
                    return _this.listener.onOpen();
                });
            });
            this.stream.onClose(function (error) {
                dispatchIfStillActive(currentStream_1, function () {
                    return _this.handleStreamClose(error);
                });
            });
            this.stream.onMessage(function (msg) {
                dispatchIfStillActive(currentStream_1, function () {
                    return _this.onMessage(msg);
                });
            });
        }
    };
    PersistentStream.prototype.performBackoff = function (listener) {
        var _this = this;
        assert_assert(this.state === PersistentStreamState.Error, 'Should only perform backoff in an error case');
        this.state = PersistentStreamState.Backoff;
        this.backoff.backoffAndWait().then(function () {
            // Backoff does not run on the AsyncQueue, so we need to reschedule to
            // make sure the queue blocks
            _this.queue.schedule(function () {
                if (_this.state === PersistentStreamState.Stopped) {
                    // Stream can be stopped while waiting for backoff to complete.
                    return Promise.resolve();
                }
                _this.state = PersistentStreamState.Initial;
                _this.start(listener);
                assert_assert(_this.isStarted(), 'PersistentStream should have started');
                return Promise.resolve();
            });
        });
    };
    PersistentStream.prototype.handleStreamClose = function (error) {
        assert_assert(this.isStarted(), "Can't handle server close on non-started stream");
        debug(persistent_stream_LOG_TAG, "close with error: " + error);
        this.stream = null;
        // In theory the stream could close cleanly, however, in our current model
        // we never expect this to happen because if we stop a stream ourselves,
        // this callback will never be called. To prevent cases where we retry
        // without a backoff accidentally, we set the stream to error in all cases.
        return this.close(PersistentStreamState.Error, error);
    };
    return PersistentStream;
}();

/**
 * A PersistentStream that implements the Listen RPC.
 *
 * Once the Listen stream has called the openHandler, any number of listen and
 * unlisten calls calls can be sent to control what changes will be sent from
 * the server for ListenResponses.
 */
var PersistentListenStream = /** @class */function (_super) {
    persistent_stream___extends(PersistentListenStream, _super);
    function PersistentListenStream(databaseInfo, queue, connection, credentials, serializer, initialBackoffDelay) {
        var _this = _super.call(this, queue, connection, credentials, initialBackoffDelay) || this;
        _this.databaseInfo = databaseInfo;
        _this.serializer = serializer;
        return _this;
    }
    PersistentListenStream.prototype.startRpc = function (token) {
        return this.connection.openStream('Listen', token);
    };
    PersistentListenStream.prototype.onMessage = function (watchChangeProto) {
        // A successful response means the stream is healthy
        this.backoff.reset();
        var watchChange = this.serializer.fromWatchChange(watchChangeProto);
        var snapshot = this.serializer.versionFromListenResponse(watchChangeProto);
        return this.listener.onWatchChange(watchChange, snapshot);
    };
    /**
     * Registers interest in the results of the given query. If the query
     * includes a resumeToken it will be included in the request. Results that
     * affect the query will be streamed back as WatchChange messages that
     * reference the targetId.
     */
    PersistentListenStream.prototype.watch = function (queryData) {
        var request = {};
        request.database = this.serializer.encodedDatabaseId;
        request.addTarget = this.serializer.toTarget(queryData);
        var labels = this.serializer.toListenRequestLabels(queryData);
        if (labels) {
            request.labels = labels;
        }
        this.sendRequest(request);
    };
    /**
     * Unregisters interest in the results of the query associated with the
     * given targetId.
     */
    PersistentListenStream.prototype.unwatch = function (targetId) {
        var request = {};
        request.database = this.serializer.encodedDatabaseId;
        request.removeTarget = targetId;
        this.sendRequest(request);
    };
    return PersistentListenStream;
}(persistent_stream_PersistentStream);

/**
 * A Stream that implements the Write RPC.
 *
 * The Write RPC requires the caller to maintain special streamToken
 * state in between calls, to help the server understand which responses the
 * client has processed by the time the next request is made. Every response
 * will contain a streamToken; this value must be passed to the next
 * request.
 *
 * After calling start() on this stream, the next request must be a handshake,
 * containing whatever streamToken is on hand. Once a response to this
 * request is received, all pending mutations may be submitted. When
 * submitting multiple batches of mutations at the same time, it's
 * okay to use the same streamToken for the calls to writeMutations.
 *
 * TODO(b/33271235): Use proto types
 */
var persistent_stream_PersistentWriteStream = /** @class */function (_super) {
    persistent_stream___extends(PersistentWriteStream, _super);
    function PersistentWriteStream(databaseInfo, queue, connection, credentials, serializer, initialBackoffDelay) {
        var _this = _super.call(this, queue, connection, credentials, initialBackoffDelay) || this;
        _this.databaseInfo = databaseInfo;
        _this.serializer = serializer;
        _this.handshakeComplete_ = false;
        return _this;
    }
    Object.defineProperty(PersistentWriteStream.prototype, "handshakeComplete", {
        /**
         * Tracks whether or not a handshake has been successfully exchanged and
         * the stream is ready to accept mutations.
         */
        get: function get() {
            return this.handshakeComplete_;
        },
        enumerable: true,
        configurable: true
    });
    // Override of PersistentStream.start
    PersistentWriteStream.prototype.start = function (listener) {
        this.handshakeComplete_ = false;
        _super.prototype.start.call(this, listener);
    };
    PersistentWriteStream.prototype.tearDown = function () {
        if (this.handshakeComplete_) {
            this.writeMutations([]);
        }
    };
    PersistentWriteStream.prototype.startRpc = function (token) {
        return this.connection.openStream('Write', token);
    };
    PersistentWriteStream.prototype.onMessage = function (responseProto) {
        // Always capture the last stream token.
        assert_assert(!!responseProto.streamToken, 'Got a write response without a stream token');
        this.lastStreamToken = responseProto.streamToken;
        if (!this.handshakeComplete_) {
            // The first response is always the handshake response
            assert_assert(!responseProto.writeResults || responseProto.writeResults.length === 0, 'Got mutation results for handshake');
            this.handshakeComplete_ = true;
            return this.listener.onHandshakeComplete();
        } else {
            // A successful first write response means the stream is healthy,
            // Note, that we could consider a successful handshake healthy, however,
            // the write itself might be causing an error we want to back off from.
            this.backoff.reset();
            var results = this.serializer.fromWriteResults(responseProto.writeResults);
            var commitVersion = this.serializer.fromVersion(responseProto.commitTime);
            return this.listener.onMutationResult(commitVersion, results);
        }
    };
    /**
     * Sends an initial streamToken to the server, performing the handshake
     * required to make the StreamingWrite RPC work. Subsequent
     * calls should wait until onHandshakeComplete was called.
     */
    PersistentWriteStream.prototype.writeHandshake = function () {
        assert_assert(this.isOpen(), 'Writing handshake requires an opened stream');
        assert_assert(!this.handshakeComplete_, 'Handshake already completed');
        // TODO(dimond): Support stream resumption. We intentionally do not set the
        // stream token on the handshake, ignoring any stream token we might have.
        var request = {};
        request.database = this.serializer.encodedDatabaseId;
        this.sendRequest(request);
    };
    /** Sends a group of mutations to the Firestore backend to apply. */
    PersistentWriteStream.prototype.writeMutations = function (mutations) {
        var _this = this;
        assert_assert(this.isOpen(), 'Writing mutations requires an opened stream');
        assert_assert(this.handshakeComplete_, 'Handshake must be complete before writing mutations');
        assert_assert(this.lastStreamToken.length > 0, 'Trying to write mutation without a token');
        var request = {
            // Protos are typed with string, but we support UInt8Array on Node
            // tslint:disable-next-line:no-any
            streamToken: this.lastStreamToken,
            writes: mutations.map(function (mutation) {
                return _this.serializer.toMutation(mutation);
            })
        };
        this.sendRequest(request);
    };
    return PersistentWriteStream;
}(persistent_stream_PersistentStream);


//# sourceMappingURL=persistent_stream.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/remote/datastore.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



/**
 * Datastore is a wrapper around the external Google Cloud Datastore grpc API,
 * which provides an interface that is more convenient for the rest of the
 * client SDK architecture to consume.
 */
var datastore_Datastore = /** @class */function () {
    function Datastore(databaseInfo, queue, connection, credentials, serializer, initialBackoffDelay) {
        this.databaseInfo = databaseInfo;
        this.queue = queue;
        this.connection = connection;
        this.credentials = credentials;
        this.serializer = serializer;
        this.initialBackoffDelay = initialBackoffDelay;
    }
    Datastore.prototype.newPersistentWriteStream = function () {
        return new persistent_stream_PersistentWriteStream(this.databaseInfo, this.queue, this.connection, this.credentials, this.serializer, this.initialBackoffDelay);
    };
    Datastore.prototype.newPersistentWatchStream = function () {
        return new PersistentListenStream(this.databaseInfo, this.queue, this.connection, this.credentials, this.serializer, this.initialBackoffDelay);
    };
    Datastore.prototype.commit = function (mutations) {
        var _this = this;
        var params = {
            database: this.serializer.encodedDatabaseId,
            writes: mutations.map(function (m) {
                return _this.serializer.toMutation(m);
            })
        };
        return this.invokeRPC('Commit', params).then(function (response) {
            return _this.serializer.fromWriteResults(response.writeResults);
        });
    };
    Datastore.prototype.lookup = function (keys) {
        var _this = this;
        var params = {
            database: this.serializer.encodedDatabaseId,
            documents: keys.map(function (k) {
                return _this.serializer.toName(k);
            })
        };
        return this.invokeStreamingRPC('BatchGetDocuments', params).then(function (response) {
            var docs = maybeDocumentMap();
            response.forEach(function (proto) {
                var doc = _this.serializer.fromMaybeDocument(proto);
                docs = docs.insert(doc.key, doc);
            });
            var result = [];
            keys.forEach(function (key) {
                var doc = docs.get(key);
                assert_assert(!!doc, 'Missing entity in write response for ' + key);
                result.push(doc);
            });
            return result;
        });
    };
    /** Gets an auth token and invokes the provided RPC. */
    Datastore.prototype.invokeRPC = function (rpcName, request) {
        var _this = this;
        // TODO(mikelehen): Retry (with backoff) on token failures?
        return this.credentials.getToken( /*forceRefresh=*/false).then(function (token) {
            return _this.connection.invokeRPC(rpcName, request, token);
        });
    };
    /** Gets an auth token and invokes the provided RPC with streamed results. */
    Datastore.prototype.invokeStreamingRPC = function (rpcName, request) {
        var _this = this;
        // TODO(mikelehen): Retry (with backoff) on token failures?
        return this.credentials.getToken( /*forceRefresh=*/false).then(function (token) {
            return _this.connection.invokeStreamingRPC(rpcName, request, token);
        });
    };
    return Datastore;
}();


//# sourceMappingURL=datastore.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/core/transaction.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Internal transaction object responsible for accumulating the mutations to
 * perform and the base versions for any documents read.
 */
var transaction_Transaction = /** @class */function () {
    function Transaction(datastore) {
        this.datastore = datastore;
        // The version of each document that was read during this transaction.
        this.readVersions = documentVersionMap();
        this.mutations = [];
        this.committed = false;
    }
    Transaction.prototype.recordVersion = function (doc) {
        var docVersion = doc.version;
        if (doc instanceof document_NoDocument) {
            // For deleted docs, we must use baseVersion 0 when we overwrite them.
            docVersion = snapshot_version_SnapshotVersion.forDeletedDoc();
        }
        var existingVersion = this.readVersions.get(doc.key);
        if (existingVersion !== null) {
            if (!docVersion.equals(existingVersion)) {
                // This transaction will fail no matter what.
                throw new FirestoreError(Code.ABORTED, 'Document version changed between two reads.');
            }
        } else {
            this.readVersions = this.readVersions.insert(doc.key, docVersion);
        }
    };
    Transaction.prototype.lookup = function (keys) {
        var _this = this;
        if (this.committed) {
            return Promise.reject('Transaction has already completed.');
        }
        if (this.mutations.length > 0) {
            return Promise.reject('Transactions lookups are invalid after writes.');
        }
        return this.datastore.lookup(keys).then(function (docs) {
            docs.forEach(function (doc) {
                return _this.recordVersion(doc);
            });
            return docs;
        });
    };
    Transaction.prototype.write = function (mutations) {
        if (this.committed) {
            throw new FirestoreError(Code.FAILED_PRECONDITION, 'Transaction has already completed.');
        }
        this.mutations = this.mutations.concat(mutations);
    };
    /**
     * Returns the version of this document when it was read in this transaction,
     * as a precondition, or no precondition if it was not read.
     */
    Transaction.prototype.precondition = function (key) {
        var version = this.readVersions.get(key);
        if (version) {
            return mutation_Precondition.updateTime(version);
        } else {
            return mutation_Precondition.NONE;
        }
    };
    /**
     * Returns the precondition for a document if the operation is an update.
     */
    Transaction.prototype.preconditionForUpdate = function (key) {
        var version = this.readVersions.get(key);
        if (version && version.equals(snapshot_version_SnapshotVersion.forDeletedDoc())) {
            // The document doesn't exist, so fail the transaction.
            throw new FirestoreError(Code.FAILED_PRECONDITION, "Can't update a document that doesn't exist.");
        } else if (version) {
            // Document exists, base precondition on document update time.
            return mutation_Precondition.updateTime(version);
        } else {
            // Document was not read, so we just use the preconditions for a blind
            // update.
            return mutation_Precondition.exists(true);
        }
    };
    Transaction.prototype.set = function (key, data) {
        this.write(data.toMutations(key, this.precondition(key)));
    };
    Transaction.prototype.update = function (key, data) {
        this.write(data.toMutations(key, this.preconditionForUpdate(key)));
    };
    Transaction.prototype.delete = function (key) {
        this.write([new mutation_DeleteMutation(key, this.precondition(key))]);
        // Since the delete will be applied before all following writes, we need to
        // ensure that the precondition for the next write will be exists: false.
        this.readVersions = this.readVersions.insert(key, snapshot_version_SnapshotVersion.forDeletedDoc());
    };
    Transaction.prototype.commit = function () {
        var _this = this;
        var unwritten = this.readVersions;
        // For each mutation, note that the doc was written.
        this.mutations.forEach(function (mutation) {
            unwritten = unwritten.remove(mutation.key);
        });
        if (!unwritten.isEmpty()) {
            return Promise.reject(Error('Every document read in a transaction must also be written.'));
        }
        return this.datastore.commit(this.mutations).then(function () {
            _this.committed = true;
        });
    };
    return Transaction;
}();


//# sourceMappingURL=transaction.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/remote/remote_store.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */















var remote_store_LOG_TAG = 'RemoteStore';
// TODO(b/35853402): Negotiate this with the stream.
var MAX_PENDING_WRITES = 10;
// The RemoteStore notifies an onlineStateHandler with OnlineState.Failed if we
// fail to connect to the backend. This subsequently triggers get() requests to
// fail or use cached data, etc. Unfortunately, our connections have
// historically been subject to various transient failures. So we wait for
// multiple failures before notifying the onlineStateHandler.
var ONLINE_ATTEMPTS_BEFORE_FAILURE = 2;
/**
 * RemoteStore - An interface to remotely stored data, basically providing a
 * wrapper around the Datastore that is more reliable for the rest of the
 * system.
 *
 * RemoteStore is responsible for maintaining the connection to the server.
 * - maintaining a list of active listens.
 * - reconnecting when the connection is dropped.
 * - resuming all the active listens on reconnect.
 *
 * RemoteStore handles all incoming events from the Datastore.
 * - listening to the watch stream and repackaging the events as RemoteEvents
 * - notifying SyncEngine of any changes to the active listens.
 *
 * RemoteStore takes writes from other components and handles them reliably.
 * - pulling pending mutations from LocalStore and sending them to Datastore.
 * - retrying mutations that failed because of network problems.
 * - acking mutations to the SyncEngine once they are accepted or rejected.
 */
var remote_store_RemoteStore = /** @class */function () {
    function RemoteStore(databaseInfo, asyncQueue,
    /**
     * The local store, used to fill the write pipeline with outbound
     * mutations and resolve existence filter mismatches.
     */
    localStore,
    /** The client-side proxy for interacting with the backend. */
    datastore, onlineStateHandler) {
        this.databaseInfo = databaseInfo;
        this.asyncQueue = asyncQueue;
        this.localStore = localStore;
        this.datastore = datastore;
        this.onlineStateHandler = onlineStateHandler;
        this.pendingWrites = [];
        this.lastBatchSeen = BATCHID_UNKNOWN;
        /**
         * A mapping of watched targets that the client cares about tracking and the
         * user has explicitly called a 'listen' for this target.
         *
         * These targets may or may not have been sent to or acknowledged by the
         * server. On re-establishing the listen stream, these targets should be sent
         * to the server. The targets removed with unlistens are removed eagerly
         * without waiting for confirmation from the listen stream.
         */
        this.listenTargets = {};
        /**
         * A mapping of targetId to pending acks needed.
         *
         * If a targetId is present in this map, then we're waiting for watch to
         * acknowledge a removal or addition of the target. If a target is not in this
         * mapping, and it's in the listenTargets map, then we consider the target to
         * be active.
         *
         * We increment the count here every time we issue a request over the stream
         * to watch or unwatch. We then decrement the count every time we get a target
         * added or target removed message from the server. Once the count is equal to
         * 0 we know that the client and server are in the same state (once this state
         * is reached the targetId is removed from the map to free the memory).
         */
        this.pendingTargetResponses = {};
        this.accumulatedWatchChanges = [];
        this.watchStream = null;
        this.writeStream = null;
        /**
         * The online state of the watch stream. The state is set to healthy if and
         * only if there are messages received by the backend.
         */
        this.watchStreamOnlineState = OnlineState.Unknown;
        /** A count of consecutive failures to open the stream. */
        this.watchStreamFailures = 0;
        /** Whether the client should fire offline warning. */
        this.shouldWarnOffline = true;
    }
    /**
     * Starts up the remote store, creating streams, restoring state from
     * LocalStore, etc.
     */
    RemoteStore.prototype.start = function () {
        return this.enableNetwork();
    };
    RemoteStore.prototype.setOnlineStateToHealthy = function () {
        this.shouldWarnOffline = false;
        this.updateAndBroadcastOnlineState(OnlineState.Healthy);
    };
    RemoteStore.prototype.setOnlineStateToUnknown = function () {
        // The state is set to unknown when a healthy stream is closed (e.g. due to
        // a token timeout) or when we have no active listens and therefore there's
        // no need to start the stream. Assuming there is (possibly in the future)
        // an active listen, then we will eventually move to state Online or Failed,
        // but we always want to make at least ONLINE_ATTEMPTS_BEFORE_FAILURE
        // attempts before failing, so we reset the count here.
        this.watchStreamFailures = 0;
        this.updateAndBroadcastOnlineState(OnlineState.Unknown);
    };
    RemoteStore.prototype.updateOnlineStateAfterFailure = function () {
        // The first failure after we are successfully connected moves us to the
        // 'Unknown' state. We then may make multiple attempts (based on
        // ONLINE_ATTEMPTS_BEFORE_FAILURE) before we actually report failure.
        if (this.watchStreamOnlineState === OnlineState.Healthy) {
            this.setOnlineStateToUnknown();
        } else {
            this.watchStreamFailures++;
            if (this.watchStreamFailures >= ONLINE_ATTEMPTS_BEFORE_FAILURE) {
                if (this.shouldWarnOffline) {
                    debug(remote_store_LOG_TAG, 'Could not reach Firestore backend.');
                    this.shouldWarnOffline = false;
                }
                this.updateAndBroadcastOnlineState(OnlineState.Failed);
            }
        }
    };
    RemoteStore.prototype.updateAndBroadcastOnlineState = function (onlineState) {
        var didChange = this.watchStreamOnlineState !== onlineState;
        this.watchStreamOnlineState = onlineState;
        if (didChange) {
            this.onlineStateHandler(onlineState);
        }
    };
    RemoteStore.prototype.isNetworkEnabled = function () {
        assert_assert(this.watchStream == null == (this.writeStream == null), 'WatchStream and WriteStream should both be null or non-null');
        return this.watchStream != null;
    };
    /** Re-enables the network. Only to be called as the counterpart to disableNetwork(). */
    RemoteStore.prototype.enableNetwork = function () {
        var _this = this;
        assert_assert(this.watchStream == null, 'enableNetwork() called with non-null watchStream.');
        assert_assert(this.writeStream == null, 'enableNetwork() called with non-null writeStream.');
        // Create new streams (but note they're not started yet).
        this.watchStream = this.datastore.newPersistentWatchStream();
        this.writeStream = this.datastore.newPersistentWriteStream();
        // Load any saved stream token from persistent storage
        return this.localStore.getLastStreamToken().then(function (token) {
            _this.writeStream.lastStreamToken = token;
            if (_this.shouldStartWatchStream()) {
                _this.startWatchStream();
            }
            _this.updateAndBroadcastOnlineState(OnlineState.Unknown);
            return _this.fillWritePipeline(); // This may start the writeStream.
        });
    };
    /** Temporarily disables the network. The network can be re-enabled using enableNetwork(). */
    RemoteStore.prototype.disableNetwork = function () {
        this.updateAndBroadcastOnlineState(OnlineState.Failed);
        // NOTE: We're guaranteed not to get any further events from these streams (not even a close
        // event).
        this.watchStream.stop();
        this.writeStream.stop();
        this.cleanUpWatchStreamState();
        this.cleanUpWriteStreamState();
        this.writeStream = null;
        this.watchStream = null;
        return Promise.resolve();
    };
    RemoteStore.prototype.shutdown = function () {
        debug(remote_store_LOG_TAG, 'RemoteStore shutting down.');
        this.disableNetwork();
        return Promise.resolve(undefined);
    };
    /** Starts new listen for the given query. Uses resume token if provided */
    RemoteStore.prototype.listen = function (queryData) {
        assert_assert(!obj_contains(this.listenTargets, queryData.targetId), 'listen called with duplicate targetId!');
        // Mark this as something the client is currently listening for.
        this.listenTargets[queryData.targetId] = queryData;
        if (this.shouldStartWatchStream()) {
            // The listen will be sent in onWatchStreamOpen
            this.startWatchStream();
        } else if (this.isNetworkEnabled() && this.watchStream.isOpen()) {
            this.sendWatchRequest(queryData);
        }
    };
    /** Removes the listen from server */
    RemoteStore.prototype.unlisten = function (targetId) {
        assert_assert(obj_contains(this.listenTargets, targetId), 'unlisten called without assigned target ID!');
        var queryData = this.listenTargets[targetId];
        delete this.listenTargets[targetId];
        if (this.isNetworkEnabled() && this.watchStream.isOpen()) {
            this.sendUnwatchRequest(targetId);
            if (obj_isEmpty(this.listenTargets)) {
                this.watchStream.markIdle();
            }
        }
    };
    /**
     * We need to increment the the expected number of pending responses we're due
     * from watch so we wait for the ack to process any messages from this target.
     */
    RemoteStore.prototype.sendWatchRequest = function (queryData) {
        this.recordPendingTargetRequest(queryData.targetId);
        this.watchStream.watch(queryData);
    };
    /**
     * We need to increment the expected number of pending responses we're due
     * from watch so we wait for the removal on the server before we process any
     * messages from this target.
     */
    RemoteStore.prototype.sendUnwatchRequest = function (targetId) {
        this.recordPendingTargetRequest(targetId);
        this.watchStream.unwatch(targetId);
    };
    /**
     * Increment the mapping of how many acks are needed from watch before we can
     * consider the server to be 'in-sync' with the client's active targets.
     */
    RemoteStore.prototype.recordPendingTargetRequest = function (targetId) {
        // For each request we get we need to record we need a response for it.
        this.pendingTargetResponses[targetId] = (this.pendingTargetResponses[targetId] || 0) + 1;
    };
    RemoteStore.prototype.startWatchStream = function () {
        assert_assert(this.shouldStartWatchStream(), 'startWriteStream() called when shouldStartWatchStream() is false.');
        this.watchStream.start({
            onOpen: this.onWatchStreamOpen.bind(this),
            onClose: this.onWatchStreamClose.bind(this),
            onWatchChange: this.onWatchStreamChange.bind(this)
        });
    };
    /**
     * Returns whether the watch stream should be started because there are
     * active targets trying to be listened too
     */
    RemoteStore.prototype.shouldStartWatchStream = function () {
        return this.isNetworkEnabled() && !this.watchStream.isStarted() && !obj_isEmpty(this.listenTargets);
    };
    RemoteStore.prototype.cleanUpWatchStreamState = function () {
        // If the connection is closed then we'll never get a snapshot version for
        // the accumulated changes and so we'll never be able to complete the batch.
        // When we start up again the server is going to resend these changes
        // anyway, so just toss the accumulated state.
        this.accumulatedWatchChanges = [];
        this.pendingTargetResponses = {};
    };
    RemoteStore.prototype.onWatchStreamOpen = function () {
        var _this = this;
        // TODO(b/35852690): close the stream again (with some timeout?) if no watch
        // targets are active
        forEachNumber(this.listenTargets, function (targetId, queryData) {
            _this.sendWatchRequest(queryData);
        });
        return Promise.resolve();
    };
    RemoteStore.prototype.onWatchStreamClose = function (error) {
        assert_assert(this.isNetworkEnabled(), 'onWatchStreamClose() should only be called when the network is enabled');
        this.cleanUpWatchStreamState();
        // If there was an error, retry the connection.
        if (this.shouldStartWatchStream()) {
            this.updateOnlineStateAfterFailure();
            this.startWatchStream();
        } else {
            // No need to restart watch stream because there are no active targets.
            // The online state is set to unknown because there is no active attempt
            // at establishing a connection
            this.setOnlineStateToUnknown();
        }
        return Promise.resolve();
    };
    RemoteStore.prototype.onWatchStreamChange = function (watchChange, snapshotVersion) {
        // Mark the connection as healthy because we got a message from the server
        this.setOnlineStateToHealthy();
        if (watchChange instanceof watch_change_WatchTargetChange && watchChange.state === WatchTargetChangeState.Removed && watchChange.cause) {
            // There was an error on a target, don't wait for a consistent snapshot
            // to raise events
            return this.handleTargetError(watchChange);
        }
        // Accumulate watch changes but don't process them if there's no
        // snapshotVersion or it's older than a previous snapshot we've processed
        // (can happen after we resume a target using a resume token).
        this.accumulatedWatchChanges.push(watchChange);
        if (!snapshotVersion.equals(snapshot_version_SnapshotVersion.MIN) && snapshotVersion.compareTo(this.localStore.getLastRemoteSnapshotVersion()) >= 0) {
            var changes = this.accumulatedWatchChanges;
            this.accumulatedWatchChanges = [];
            return this.handleWatchChangeBatch(snapshotVersion, changes);
        } else {
            return Promise.resolve();
        }
    };
    /**
     * Takes a batch of changes from the Datastore, repackages them as a
     * RemoteEvent, and passes that on to the listener, which is typically the
     * SyncEngine.
     */
    RemoteStore.prototype.handleWatchChangeBatch = function (snapshotVersion, changes) {
        var _this = this;
        var aggregator = new watch_change_WatchChangeAggregator(snapshotVersion, this.listenTargets, this.pendingTargetResponses);
        aggregator.addChanges(changes);
        var remoteEvent = aggregator.createRemoteEvent();
        // Get the new response counts from the aggregator
        this.pendingTargetResponses = aggregator.pendingTargetResponses;
        var promises = [];
        // Handle existence filters and existence filter mismatches.
        forEachNumber(aggregator.existenceFilters, function (targetId, filter) {
            var queryData = _this.listenTargets[targetId];
            if (!queryData) {
                // A watched target might have been removed already.
                return;
            }
            var query = queryData.query;
            if (query.isDocumentQuery()) {
                if (filter.count === 0) {
                    // The existence filter told us the document does not exist.
                    // We need to deduce that this document does not exist and apply
                    // a deleted document to our updates. Without applying a deleted
                    // document there might be another query that will raise this
                    // document as part of a snapshot until it is resolved,
                    // essentially exposing inconsistency between queries.
                    var key = new document_key_DocumentKey(query.path);
                    var deletedDoc = new document_NoDocument(key, snapshotVersion);
                    remoteEvent.addDocumentUpdate(deletedDoc);
                } else {
                    assert_assert(filter.count === 1, 'Single document existence filter with count: ' + filter.count);
                }
            } else {
                // Not a document query.
                var promise = _this.localStore.remoteDocumentKeys(targetId).then(function (trackedRemote) {
                    if (remoteEvent.targetChanges[targetId]) {
                        var mapping = remoteEvent.targetChanges[targetId].mapping;
                        if (mapping !== null) {
                            if (mapping instanceof UpdateMapping) {
                                trackedRemote = mapping.applyToKeySet(trackedRemote);
                            } else {
                                assert_assert(mapping instanceof ResetMapping, 'Expected either reset or update mapping but got something else: ' + mapping);
                                trackedRemote = mapping.documents;
                            }
                        }
                    }
                    if (trackedRemote.size !== filter.count) {
                        // Existence filter mismatch, resetting mapping.
                        // Make sure the mismatch is exposed in the remote event.
                        remoteEvent.handleExistenceFilterMismatch(targetId);
                        // Clear the resume token for the query, since we're in a
                        // known mismatch state.
                        var newQueryData = new query_data_QueryData(query, targetId, queryData.purpose);
                        _this.listenTargets[targetId] = newQueryData;
                        // Cause a hard reset by unwatching and rewatching
                        // immediately, but deliberately don't send a resume token
                        // so that we get a full update.
                        // Make sure we expect that this acks are going to happen.
                        _this.sendUnwatchRequest(targetId);
                        // Mark the query we send as being on behalf of an existence
                        // filter mismatch, but don't actually retain that in
                        // listenTargets. This ensures that we flag the first
                        // re-listen this way without impacting future listens of
                        // this target (that might happen e.g. on reconnect).
                        var requestQueryData = new query_data_QueryData(query, targetId, QueryPurpose.ExistenceFilterMismatch);
                        _this.sendWatchRequest(requestQueryData);
                    }
                });
                promises.push(promise);
            }
        });
        return Promise.all(promises).then(function () {
            // Update in-memory resume tokens. LocalStore will update the
            // persistent view of these when applying the completed RemoteEvent.
            forEachNumber(remoteEvent.targetChanges, function (targetId, change) {
                if (change.resumeToken.length > 0) {
                    var queryData = _this.listenTargets[targetId];
                    // A watched target might have been removed already.
                    if (queryData) {
                        _this.listenTargets[targetId] = queryData.update({
                            resumeToken: change.resumeToken,
                            snapshotVersion: change.snapshotVersion
                        });
                    }
                }
            });
            // Finally handle remote event
            return _this.syncEngine.applyRemoteEvent(remoteEvent);
        });
    };
    /** Handles an error on a target */
    RemoteStore.prototype.handleTargetError = function (watchChange) {
        var _this = this;
        assert_assert(!!watchChange.cause, 'Handling target error without a cause');
        var error = watchChange.cause;
        var promiseChain = Promise.resolve();
        watchChange.targetIds.forEach(function (targetId) {
            promiseChain = promiseChain.then(function () {
                if (obj_contains(_this.listenTargets, targetId)) {
                    delete _this.listenTargets[targetId];
                    return _this.syncEngine.rejectListen(targetId, error);
                } else {
                    // A watched target might have been removed already.
                    return Promise.resolve();
                }
            });
        });
        return promiseChain;
    };
    RemoteStore.prototype.cleanUpWriteStreamState = function () {
        this.lastBatchSeen = BATCHID_UNKNOWN;
        this.pendingWrites = [];
    };
    /**
     * Notifies that there are new mutations to process in the queue. This is
     * typically called by SyncEngine after it has sent mutations to LocalStore.
     */
    RemoteStore.prototype.fillWritePipeline = function () {
        var _this = this;
        if (!this.canWriteMutations()) {
            return Promise.resolve();
        } else {
            return this.localStore.nextMutationBatch(this.lastBatchSeen).then(function (batch) {
                if (batch === null) {
                    if (_this.pendingWrites.length == 0) {
                        _this.writeStream.markIdle();
                    }
                    return Promise.resolve();
                } else {
                    _this.commit(batch);
                    return _this.fillWritePipeline();
                }
            });
        }
    };
    /**
     * Returns true if the backend can accept additional write requests.
     *
     * When sending mutations to the write stream (e.g. in fillWritePipeline),
     * call this method first to check if more mutations can be sent.
     *
     * Currently the only thing that can prevent the backend from accepting
     * write requests is if there are too many requests already outstanding. As
     * writes complete the backend will be able to accept more.
     */
    RemoteStore.prototype.canWriteMutations = function () {
        return this.isNetworkEnabled() && this.pendingWrites.length < MAX_PENDING_WRITES;
    };
    // For testing
    RemoteStore.prototype.outstandingWrites = function () {
        return this.pendingWrites.length;
    };
    /**
     * Given mutations to commit, actually commits them to the Datastore. Note
     * that this does *not* return a Promise specifically because the AsyncQueue
     * should not block operations for this.
     */
    RemoteStore.prototype.commit = function (batch) {
        assert_assert(this.canWriteMutations(), "commit called when batches can't be written");
        this.lastBatchSeen = batch.batchId;
        this.pendingWrites.push(batch);
        if (this.shouldStartWriteStream()) {
            this.startWriteStream();
        } else if (this.isNetworkEnabled() && this.writeStream.handshakeComplete) {
            this.writeStream.writeMutations(batch.mutations);
        }
    };
    RemoteStore.prototype.shouldStartWriteStream = function () {
        return this.isNetworkEnabled() && !this.writeStream.isStarted() && this.pendingWrites.length > 0;
    };
    RemoteStore.prototype.startWriteStream = function () {
        assert_assert(this.shouldStartWriteStream(), 'startWriteStream() called when shouldStartWriteStream() is false.');
        this.writeStream.start({
            onOpen: this.onWriteStreamOpen.bind(this),
            onClose: this.onWriteStreamClose.bind(this),
            onHandshakeComplete: this.onWriteHandshakeComplete.bind(this),
            onMutationResult: this.onMutationResult.bind(this)
        });
    };
    RemoteStore.prototype.onWriteStreamOpen = function () {
        this.writeStream.writeHandshake();
        return Promise.resolve();
    };
    RemoteStore.prototype.onWriteHandshakeComplete = function () {
        var _this = this;
        // Record the stream token.
        return this.localStore.setLastStreamToken(this.writeStream.lastStreamToken).then(function () {
            // Drain any pending writes.
            //
            // Note that at this point pendingWrites contains mutations that
            // have already been accepted by fillWritePipeline/commitBatch. If
            // the pipeline is full, canWriteMutations will be false, despite
            // the fact that we actually need to send mutations over.
            //
            // This also means that this method indirectly respects the limits
            // imposed by canWriteMutations since writes can't be added to the
            // pendingWrites array when canWriteMutations is false. If the
            // limits imposed by canWriteMutations actually protect us from
            // DOSing ourselves then those limits won't be exceeded here and
            // we'll continue to make progress.
            for (var _i = 0, _a = _this.pendingWrites; _i < _a.length; _i++) {
                var batch = _a[_i];
                _this.writeStream.writeMutations(batch.mutations);
            }
        });
    };
    RemoteStore.prototype.onMutationResult = function (commitVersion, results) {
        var _this = this;
        // This is a response to a write containing mutations and should be
        // correlated to the first pending write.
        assert_assert(this.pendingWrites.length > 0, 'Got result for empty pending writes');
        var batch = this.pendingWrites.shift();
        var success = mutation_batch_MutationBatchResult.from(batch, commitVersion, results, this.writeStream.lastStreamToken);
        return this.syncEngine.applySuccessfulWrite(success).then(function () {
            // It's possible that with the completion of this mutation another
            // slot has freed up.
            return _this.fillWritePipeline();
        });
    };
    RemoteStore.prototype.onWriteStreamClose = function (error) {
        var _this = this;
        assert_assert(this.isNetworkEnabled(), 'onWriteStreamClose() should only be called when the network is enabled');
        // If the write stream closed due to an error, invoke the error callbacks if
        // there are pending writes.
        if (error && this.pendingWrites.length > 0) {
            assert_assert(!!error, 'We have pending writes, but the write stream closed without an error');
            // A promise that is resolved after we processed the error
            var errorHandling = void 0;
            if (this.writeStream.handshakeComplete) {
                // This error affects the actual write.
                errorHandling = this.handleWriteError(error);
            } else {
                // If there was an error before the handshake has finished, it's
                // possible that the server is unable to process the stream token
                // we're sending. (Perhaps it's too old?)
                errorHandling = this.handleHandshakeError(error);
            }
            return errorHandling.then(function () {
                // The write stream might have been started by refilling the write
                // pipeline for failed writes
                if (_this.shouldStartWriteStream()) {
                    _this.startWriteStream();
                }
            });
        } else {
            // No pending writes, nothing to do
            return Promise.resolve();
        }
    };
    RemoteStore.prototype.handleHandshakeError = function (error) {
        // Reset the token if it's a permanent error or the error code is
        // ABORTED, signaling the write stream is no longer valid.
        if (isPermanentError(error.code) || error.code === Code.ABORTED) {
            debug(remote_store_LOG_TAG, 'RemoteStore error before completed handshake; resetting stream token: ', this.writeStream.lastStreamToken);
            this.writeStream.lastStreamToken = emptyByteString();
            return this.localStore.setLastStreamToken(emptyByteString());
        } else {
            // Some other error, don't reset stream token. Our stream logic will
            // just retry with exponential backoff.
            return Promise.resolve();
        }
    };
    RemoteStore.prototype.handleWriteError = function (error) {
        var _this = this;
        if (isPermanentError(error.code)) {
            // This was a permanent error, the request itself was the problem
            // so it's not going to succeed if we resend it.
            var batch = this.pendingWrites.shift();
            // In this case it's also unlikely that the server itself is melting
            // down -- this was just a bad request so inhibit backoff on the next
            // restart.
            this.writeStream.inhibitBackoff();
            return this.syncEngine.rejectFailedWrite(batch.batchId, error).then(function () {
                // It's possible that with the completion of this mutation
                // another slot has freed up.
                return _this.fillWritePipeline();
            });
        } else {
            // Transient error, just let the retry logic kick in.
            return Promise.resolve();
        }
    };
    RemoteStore.prototype.createTransaction = function () {
        return new transaction_Transaction(this.datastore);
    };
    RemoteStore.prototype.handleUserChange = function (user) {
        debug(remote_store_LOG_TAG, 'RemoteStore changing users: uid=', user.uid);
        // Tear down and re-create our network streams. This will ensure we get a fresh auth token
        // for the new user and re-fill the write pipeline with new mutations from the LocalStore
        // (since mutations are per-user).
        this.disableNetwork();
        return this.enableNetwork();
    };
    return RemoteStore;
}();


//# sourceMappingURL=remote_store.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/core/firestore_client.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */













var firestore_client_LOG_TAG = 'FirestoreClient';
/**
 * FirestoreClient is a top-level class that constructs and owns all of the
 * pieces of the client SDK architecture. It is responsible for creating the
 * async queue that is shared by all of the other components in the system.
 */
var firestore_client_FirestoreClient = /** @class */function () {
    function FirestoreClient(platform, databaseInfo, credentials,
    /**
     * Asynchronous queue responsible for all of our internal processing. When
     * we get incoming work from the user (via public API) or the network
     * (incoming GRPC messages), we should always schedule onto this queue.
     * This ensures all of our work is properly serialized (e.g. we don't
     * start processing a new operation while the previous one is waiting for
     * an async I/O to complete).
     */
    asyncQueue) {
        this.platform = platform;
        this.databaseInfo = databaseInfo;
        this.credentials = credentials;
        this.asyncQueue = asyncQueue;
    }
    /**
     * Starts up the FirestoreClient, returning only whether or not enabling
     * persistence succeeded.
     *
     * The intent here is to "do the right thing" as far as users are concerned.
     * Namely, in cases where offline persistence is requested and possible,
     * enable it, but otherwise fall back to persistence disabled. For the most
     * part we expect this to succeed one way or the other so we don't expect our
     * users to actually wait on the firestore.enablePersistence Promise since
     * they generally won't care.
     *
     * Of course some users actually do care about whether or not persistence
     * was successfully enabled, so the Promise returned from this method
     * indicates this outcome.
     *
     * This presents a problem though: even before enablePersistence resolves or
     * rejects, users may have made calls to e.g. firestore.collection() which
     * means that the FirestoreClient in there will be available and will be
     * enqueuing actions on the async queue.
     *
     * Meanwhile any failure of an operation on the async queue causes it to
     * panic and reject any further work, on the premise that unhandled errors
     * are fatal.
     *
     * Consequently the fallback is handled internally here in start, and if the
     * fallback succeeds we signal success to the async queue even though the
     * start() itself signals failure.
     *
     * @param usePersistence Whether or not to attempt to enable persistence.
     * @returns A deferred result indicating the user-visible result of enabling
     *     offline persistence. This method will reject this if IndexedDB fails to
     *     start for any reason. If usePersistence is false this is
     *     unconditionally resolved.
     */
    FirestoreClient.prototype.start = function (usePersistence) {
        var _this = this;
        // We defer our initialization until we get the current user from
        // setUserChangeListener(). We block the async queue until we got the
        // initial user and the initialization is completed. This will prevent
        // any scheduled work from happening before initialization is completed.
        //
        // If initializationDone resolved then the FirestoreClient is in a usable
        // state.
        var initializationDone = new promise_Deferred();
        // If usePersistence is true, certain classes of errors while starting are
        // recoverable but only by falling back to persistence disabled.
        //
        // If there's an error in the first case but not in recovery we cannot
        // reject the promise blocking the async queue because this will cause the
        // async queue to panic.
        var persistenceResult = new promise_Deferred();
        var initialized = false;
        this.credentials.setUserChangeListener(function (user) {
            if (!initialized) {
                initialized = true;
                _this.initializePersistence(usePersistence, persistenceResult).then(function () {
                    return _this.initializeRest(user);
                }).then(initializationDone.resolve, initializationDone.reject);
            } else {
                _this.asyncQueue.schedule(function () {
                    return _this.handleUserChange(user);
                });
            }
        });
        // Block the async queue until initialization is done
        this.asyncQueue.schedule(function () {
            return initializationDone.promise;
        });
        // Return only the result of enabling persistence. Note that this does not
        // need to await the completion of initializationDone because the result of
        // this method should not reflect any other kind of failure to start.
        return persistenceResult.promise;
    };
    /** Enables the network connection and requeues all pending operations. */
    FirestoreClient.prototype.enableNetwork = function () {
        var _this = this;
        return this.asyncQueue.schedule(function () {
            return _this.remoteStore.enableNetwork();
        });
    };
    /**
     * Initializes persistent storage, attempting to use IndexedDB if
     * usePersistence is true or memory-only if false.
     *
     * If IndexedDB fails because it's already open in another tab or because the
     * platform can't possibly support our implementation then this method rejects
     * the persistenceResult and falls back on memory-only persistence.
     *
     * @param usePersistence indicates whether or not to use offline persistence
     * @param persistenceResult A deferred result indicating the user-visible
     *     result of enabling offline persistence. This method will reject this if
     *     IndexedDB fails to start for any reason. If usePersistence is false
     *     this is unconditionally resolved.
     * @returns a Promise indicating whether or not initialization should
     *     continue, i.e. that one of the persistence implementations actually
     *     succeeded.
     */
    FirestoreClient.prototype.initializePersistence = function (usePersistence, persistenceResult) {
        var _this = this;
        if (usePersistence) {
            return this.startIndexedDbPersistence().then(persistenceResult.resolve).catch(function (error) {
                // Regardless of whether or not the retry succeeds, from an user
                // perspective, offline persistence has failed.
                persistenceResult.reject(error);
                // An unknown failure on the first stage shuts everything down.
                if (!_this.canFallback(error)) {
                    return Promise.reject(error);
                }
                console.warn('Error enabling offline storage. Falling back to' + ' storage disabled: ' + error);
                return _this.startMemoryPersistence();
            });
        } else {
            // When usePersistence == false, enabling offline persistence is defined
            // to unconditionally succeed. This allows start() to have the same
            // signature for both cases, despite the fact that the returned promise
            // is only used in the enablePersistence call.
            persistenceResult.resolve();
            return this.startMemoryPersistence();
        }
    };
    FirestoreClient.prototype.canFallback = function (error) {
        return error.code === Code.FAILED_PRECONDITION || error.code === Code.UNIMPLEMENTED;
    };
    /**
     * Starts IndexedDB-based persistence.
     *
     * @returns A promise indicating success or failure.
     */
    FirestoreClient.prototype.startIndexedDbPersistence = function () {
        // TODO(http://b/33384523): For now we just disable garbage collection
        // when persistence is enabled.
        this.garbageCollector = new no_op_garbage_collector_NoOpGarbageCollector();
        var storagePrefix = indexeddb_persistence_IndexedDbPersistence.buildStoragePrefix(this.databaseInfo);
        // Opt to use proto3 JSON in case the platform doesn't support Uint8Array.
        var serializer = new serializer_JsonProtoSerializer(this.databaseInfo.databaseId, {
            useProto3Json: true
        });
        this.persistence = new indexeddb_persistence_IndexedDbPersistence(storagePrefix, serializer);
        return this.persistence.start();
    };
    /**
     * Starts Memory-backed persistence. In practice this cannot fail.
     *
     * @returns A promise that will successfully resolve.
     */
    FirestoreClient.prototype.startMemoryPersistence = function () {
        this.garbageCollector = new eager_garbage_collector_EagerGarbageCollector();
        this.persistence = new memory_persistence_MemoryPersistence();
        return this.persistence.start();
    };
    /**
     * Initializes the rest of the FirestoreClient, assuming the initial user
     * has been obtained from the credential provider and some persistence
     * implementation is available in this.persistence.
     */
    FirestoreClient.prototype.initializeRest = function (user) {
        var _this = this;
        return this.platform.loadConnection(this.databaseInfo).then(function (connection) {
            _this.localStore = new local_store_LocalStore(_this.persistence, user, _this.garbageCollector);
            var serializer = _this.platform.newSerializer(_this.databaseInfo.databaseId);
            var datastore = new datastore_Datastore(_this.databaseInfo, _this.asyncQueue, connection, _this.credentials, serializer);
            var onlineStateChangedHandler = function onlineStateChangedHandler(onlineState) {
                _this.eventMgr.onOnlineStateChanged(onlineState);
            };
            _this.remoteStore = new remote_store_RemoteStore(_this.databaseInfo, _this.asyncQueue, _this.localStore, datastore, onlineStateChangedHandler);
            _this.syncEngine = new sync_engine_SyncEngine(_this.localStore, _this.remoteStore, user);
            // Setup wiring between sync engine and remote store
            _this.remoteStore.syncEngine = _this.syncEngine;
            _this.eventMgr = new event_manager_EventManager(_this.syncEngine);
            // NOTE: RemoteStore depends on LocalStore (for persisting stream
            // tokens, refilling mutation queue, etc.) so must be started after
            // LocalStore.
            return _this.localStore.start();
        }).then(function () {
            return _this.remoteStore.start();
        });
    };
    FirestoreClient.prototype.handleUserChange = function (user) {
        this.asyncQueue.verifyOperationInProgress();
        debug(firestore_client_LOG_TAG, 'User Changed: ' + user.uid);
        return this.syncEngine.handleUserChange(user);
    };
    /** Disables the network connection. Pending operations will not complete. */
    FirestoreClient.prototype.disableNetwork = function () {
        var _this = this;
        return this.asyncQueue.schedule(function () {
            return _this.remoteStore.disableNetwork();
        });
    };
    FirestoreClient.prototype.shutdown = function () {
        var _this = this;
        return this.asyncQueue.schedule(function () {
            _this.credentials.removeUserChangeListener();
            return _this.remoteStore.shutdown();
        }).then(function () {
            // PORTING NOTE: LocalStore does not need an explicit shutdown on web.
            return _this.persistence.shutdown();
        });
    };
    FirestoreClient.prototype.listen = function (query, observer, options) {
        var _this = this;
        var listener = new event_manager_QueryListener(query, observer, options);
        this.asyncQueue.schedule(function () {
            return _this.eventMgr.listen(listener);
        });
        return listener;
    };
    FirestoreClient.prototype.unlisten = function (listener) {
        var _this = this;
        this.asyncQueue.schedule(function () {
            return _this.eventMgr.unlisten(listener);
        });
    };
    FirestoreClient.prototype.write = function (mutations) {
        var _this = this;
        var deferred = new promise_Deferred();
        this.asyncQueue.schedule(function () {
            return _this.syncEngine.write(mutations, deferred);
        });
        return deferred.promise;
    };
    FirestoreClient.prototype.databaseId = function () {
        return this.databaseInfo.databaseId;
    };
    FirestoreClient.prototype.transaction = function (updateFunction) {
        var _this = this;
        // We have to wait for the async queue to be sure syncEngine is initialized.
        return this.asyncQueue.schedule(function () {
            return Promise.resolve();
        }).then(function () {
            return _this.syncEngine.runTransaction(updateFunction);
        });
    };
    return FirestoreClient;
}();


//# sourceMappingURL=firestore_client.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/util/async_observer.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/*
 * A wrapper implementation of Observer<T> that will dispatch events
 * asynchronously. To allow immediate silencing, a mute call is added which
 * causes events scheduled to no longer be raised.
 */
var AsyncObserver = /** @class */function () {
    function AsyncObserver(observer) {
        this.observer = observer;
        /**
         * When set to true, will not raise future events. Necessary to deal with
         * async detachment of listener.
         */
        this.muted = false;
    }
    AsyncObserver.prototype.next = function (value) {
        this.scheduleEvent(this.observer.next, value);
    };
    AsyncObserver.prototype.error = function (error) {
        this.scheduleEvent(this.observer.error, error);
    };
    AsyncObserver.prototype.mute = function () {
        this.muted = true;
    };
    AsyncObserver.prototype.scheduleEvent = function (eventHandler, event) {
        var _this = this;
        if (!this.muted) {
            setTimeout(function () {
                if (!_this.muted) {
                    eventHandler(event);
                }
            }, 0);
        }
    };
    return AsyncObserver;
}();


//# sourceMappingURL=async_observer.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/util/async_queue.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




var async_queue_AsyncQueue = /** @class */function () {
    function AsyncQueue() {
        // The last promise in the queue.
        this.tail = Promise.resolve();
        // A list with timeout handles and their respective deferred promises.
        // Contains an entry for each operation that is queued to run in the future
        // (i.e. it has a delay that has not yet elapsed). Prior to cleanup, this list
        // may also contain entries that have already been run (in which case `handle` is
        // null).
        this.delayedOperations = [];
        // The number of operations that are queued to be run in the future (i.e. they
        // have a delay that has not yet elapsed). Unlike `delayedOperations`, this
        // is guaranteed to only contain operations that have not yet been run.
        //
        // Visible for testing.
        this.delayedOperationsCount = 0;
        // Flag set while there's an outstanding AsyncQueue operation, used for
        // assertion sanity-checks.
        this.operationInProgress = false;
    }
    /**
     * Adds a new operation to the queue. Returns a promise that will be resolved
     * when the promise returned by the new operation is (with its value).
     *
     * Can optionally specify a delay (in milliseconds) to wait before queuing the
     * operation.
     */
    AsyncQueue.prototype.schedule = function (op, delay) {
        var _this = this;
        if (this.failure) {
            fail('AsyncQueue is already failed: ' + (this.failure.stack || this.failure.message));
        }
        if ((delay || 0) > 0) {
            this.delayedOperationsCount++;
            var delayedOp_1 = {
                handle: null,
                op: op,
                deferred: new promise_Deferred()
            };
            delayedOp_1.handle = setTimeout(function () {
                _this.scheduleInternal(function () {
                    return delayedOp_1.op().then(function (result) {
                        delayedOp_1.deferred.resolve(result);
                    });
                });
                delayedOp_1.handle = null;
                _this.delayedOperationsCount--;
                if (_this.delayedOperationsCount === 0) {
                    _this.delayedOperations = [];
                }
            }, delay);
            this.delayedOperations.push(delayedOp_1);
            return delayedOp_1.deferred.promise;
        } else {
            return this.scheduleInternal(op);
        }
    };
    AsyncQueue.prototype.scheduleInternal = function (op) {
        var _this = this;
        this.tail = this.tail.then(function () {
            _this.operationInProgress = true;
            return op().catch(function (error) {
                _this.failure = error;
                _this.operationInProgress = false;
                var message = error.stack || error.message || '';
                log_error('INTERNAL UNHANDLED ERROR: ', message);
                // Escape the promise chain and throw the error globally so that
                // e.g. any global crash reporting library detects and reports it.
                // (but not for simulated errors in our tests since this breaks mocha)
                if (message.indexOf('Firestore Test Simulated Error') < 0) {
                    setTimeout(function () {
                        throw error;
                    }, 0);
                }
                // Re-throw the error so that this.tail becomes a rejected Promise and
                // all further attempts to chain (via .then) will just short-circuit
                // and return the rejected Promise.
                throw error;
            }).then(function () {
                _this.operationInProgress = false;
            });
        });
        return this.tail;
    };
    /**
     * Verifies there's an operation currently in-progress on the AsyncQueue.
     * Unfortunately we can't verify that the running code is in the promise chain
     * of that operation, so this isn't a foolproof check, but it should be enough
     * to catch some bugs.
     */
    AsyncQueue.prototype.verifyOperationInProgress = function () {
        assert_assert(this.operationInProgress, 'verifyOpInProgress() called when no op in progress on this queue.');
    };
    /**
     * Waits until all currently scheduled tasks are finished executing. Tasks
     * scheduled with a delay can be rejected or queued for immediate execution.
     */
    AsyncQueue.prototype.drain = function (executeDelayedTasks) {
        var _this = this;
        this.delayedOperations.forEach(function (entry) {
            if (entry.handle) {
                clearTimeout(entry.handle);
                if (executeDelayedTasks) {
                    _this.scheduleInternal(entry.op).then(entry.deferred.resolve, entry.deferred.reject);
                } else {
                    entry.deferred.reject(new FirestoreError(Code.CANCELLED, 'Operation cancelled by shutdown'));
                }
            }
        });
        this.delayedOperations = [];
        this.delayedOperationsCount = 0;
        return this.schedule(function () {
            return Promise.resolve();
        });
    };
    return AsyncQueue;
}();


//# sourceMappingURL=async_queue.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/auth/user.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Simple wrapper around a nullable UID. Mostly exists to make code more
 * readable.
 */
var User = /** @class */function () {
    function User(uid) {
        this.uid = uid;
    }
    User.prototype.isUnauthenticated = function () {
        return this.uid == null;
    };
    /**
     * Returns a key representing this user, suitable for inclusion in a
     * dictionary.
     */
    User.prototype.toKey = function () {
        if (this.isUnauthenticated()) {
            return 'anonymous-user';
        } else {
            return 'uid:' + this.uid;
        }
    };
    User.prototype.equals = function (otherUser) {
        return otherUser.uid === this.uid;
    };
    /** A user with a null UID. */
    User.UNAUTHENTICATED = new User(null);
    // TODO(mikelehen): Look into getting a proper uid-equivalent for
    // non-FirebaseAuth providers.
    User.GOOGLE_CREDENTIALS = new User('google-credentials-uid');
    User.FIRST_PARTY = new User('first-party-uid');
    return User;
}();


//# sourceMappingURL=user.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/api/credentials.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var OAuthToken = /** @class */function () {
    function OAuthToken(value, user) {
        this.user = user;
        this.type = 'OAuth';
        this.authHeaders = { Authorization: "Bearer " + value };
    }
    return OAuthToken;
}();

/** A CredentialsProvider that always yields an empty token. */
var credentials_EmptyCredentialsProvider = /** @class */function () {
    function EmptyCredentialsProvider() {
        /**
         * Stores the User listener registered with setUserChangeListener()
         * This isn't actually necessary since the UID never changes, but we use this
         * to verify the listen contract is adhered to in tests.
         */
        this.userListener = null;
    }
    EmptyCredentialsProvider.prototype.getToken = function (forceRefresh) {
        return Promise.resolve(null);
    };
    EmptyCredentialsProvider.prototype.setUserChangeListener = function (listener) {
        assert_assert(!this.userListener, 'Can only call setUserChangeListener() once.');
        this.userListener = listener;
        // Fire with initial user.
        listener(User.UNAUTHENTICATED);
    };
    EmptyCredentialsProvider.prototype.removeUserChangeListener = function () {
        assert_assert(this.userListener !== null, 'removeUserChangeListener() when no listener registered');
        this.userListener = null;
    };
    return EmptyCredentialsProvider;
}();

var credentials_FirebaseCredentialsProvider = /** @class */function () {
    function FirebaseCredentialsProvider(app) {
        var _this = this;
        this.app = app;
        /**
         * The auth token listener registered with FirebaseApp, retained here so we
         * can unregister it.
         */
        this.tokenListener = null;
        /**
         * Counter used to detect if the user changed while a getToken request was
         * outstanding.
         */
        this.userCounter = 0;
        /** The User listener registered with setUserChangeListener(). */
        this.userListener = null;
        // We listen for token changes but all we really care about is knowing when
        // the uid may have changed.
        this.tokenListener = function () {
            var newUser = _this.getUser();
            if (!_this.currentUser || !newUser.equals(_this.currentUser)) {
                _this.currentUser = newUser;
                _this.userCounter++;
                if (_this.userListener) {
                    _this.userListener(_this.currentUser);
                }
            }
        };
        this.userCounter = 0;
        // Will fire at least once where we set this.currentUser
        this.app.INTERNAL.addAuthTokenListener(this.tokenListener);
    }
    FirebaseCredentialsProvider.prototype.getToken = function (forceRefresh) {
        var _this = this;
        assert_assert(this.tokenListener != null, 'getToken cannot be called after listener removed.');
        // Take note of the current value of the userCounter so that this method can
        // fail (with an ABORTED error) if there is a user change while the request
        // is outstanding.
        var initialUserCounter = this.userCounter;
        return this.app.INTERNAL.getToken(forceRefresh).then(function (tokenData) {
            // Cancel the request since the user changed while the request was
            // outstanding so the response is likely for a previous user (which
            // user, we can't be sure).
            if (_this.userCounter !== initialUserCounter) {
                throw new FirestoreError(Code.ABORTED, 'getToken aborted due to uid change.');
            } else {
                if (tokenData) {
                    assert_assert(typeof tokenData.accessToken === 'string', 'Invalid tokenData returned from getToken():' + tokenData);
                    return new OAuthToken(tokenData.accessToken, _this.currentUser);
                } else {
                    return null;
                }
            }
        });
    };
    FirebaseCredentialsProvider.prototype.setUserChangeListener = function (listener) {
        assert_assert(!this.userListener, 'Can only call setUserChangeListener() once.');
        this.userListener = listener;
        // Fire the initial event, but only if we received the initial user
        if (this.currentUser) {
            listener(this.currentUser);
        }
    };
    FirebaseCredentialsProvider.prototype.removeUserChangeListener = function () {
        assert_assert(this.tokenListener != null, 'removeUserChangeListener() called twice');
        assert_assert(this.userListener !== null, 'removeUserChangeListener() called when no listener registered');
        this.app.INTERNAL.removeAuthTokenListener(this.tokenListener);
        this.tokenListener = null;
        this.userListener = null;
    };
    FirebaseCredentialsProvider.prototype.getUser = function () {
        // TODO(mikelehen): Remove this check once we're shipping with firebase.js.
        if (typeof this.app.INTERNAL.getUid !== 'function') {
            fail('This version of the Firestore SDK requires at least version' + ' 3.7.0 of firebase.js.');
        }
        var currentUid = this.app.INTERNAL.getUid();
        assert_assert(currentUid === null || typeof currentUid === 'string', 'Received invalid UID: ' + currentUid);
        return new User(currentUid);
    };
    return FirebaseCredentialsProvider;
}();

/*
 * FirstPartyToken provides a fresh token each time its value
 * is requested, because if the token is too old, requests will be rejected.
 * TODO(b/33147818) this implementation violates the current assumption that
 * tokens are immutable.  We need to either revisit this assumption or come
 * up with some way for FPA to use the listen/unlisten interface.
 */
var credentials_FirstPartyToken = /** @class */function () {
    function FirstPartyToken(gapi, sessionIndex) {
        this.gapi = gapi;
        this.sessionIndex = sessionIndex;
        this.type = 'FirstParty';
        this.user = User.FIRST_PARTY;
        assert_assert(this.gapi && this.gapi['auth'] && this.gapi['auth']['getAuthHeaderValueForFirstParty'], 'unexpected gapi interface');
    }
    Object.defineProperty(FirstPartyToken.prototype, "authHeaders", {
        get: function get() {
            return {
                Authorization: this.gapi['auth']['getAuthHeaderValueForFirstParty']([]),
                'X-Goog-AuthUser': this.sessionIndex
            };
        },
        enumerable: true,
        configurable: true
    });
    return FirstPartyToken;
}();

/*
 * Provides user credentials required for the Firestore JavaScript SDK
 * to authenticate the user, using technique that is only available
 * to applications hosted by Google.
 */
var credentials_FirstPartyCredentialsProvider = /** @class */function () {
    function FirstPartyCredentialsProvider(gapi, sessionIndex) {
        this.gapi = gapi;
        this.sessionIndex = sessionIndex;
        assert_assert(this.gapi && this.gapi['auth'] && this.gapi['auth']['getAuthHeaderValueForFirstParty'], 'unexpected gapi interface');
    }
    FirstPartyCredentialsProvider.prototype.getToken = function (forceRefresh) {
        return Promise.resolve(new credentials_FirstPartyToken(this.gapi, this.sessionIndex));
    };
    // TODO(33108925): can someone switch users w/o a page refresh?
    // TODO(33110621): need to understand token/session lifecycle
    FirstPartyCredentialsProvider.prototype.setUserChangeListener = function (listener) {
        // Fire with initial uid.
        listener(User.FIRST_PARTY);
    };
    FirstPartyCredentialsProvider.prototype.removeUserChangeListener = function () {};
    return FirstPartyCredentialsProvider;
}();

/**
 * Builds a CredentialsProvider depending on the type of
 * the credentials passed in.
 */
function makeCredentialsProvider(credentials) {
    if (!credentials) {
        return new credentials_EmptyCredentialsProvider();
    }
    switch (credentials.type) {
        case 'gapi':
            return new credentials_FirstPartyCredentialsProvider(credentials.client, credentials.sessionIndex || '0');
        case 'provider':
            return credentials.client;
        default:
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'makeCredentialsProvider failed due to invalid credential type');
    }
}

//# sourceMappingURL=credentials.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/api/observer.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function isPartialObserver(obj) {
    return observer_implementsAnyMethods(obj, ['next', 'error', 'complete']);
}
/**
 * Returns true if obj is an object and contains at least one of the specified
 * methods.
 */
function observer_implementsAnyMethods(obj, methods) {
    if (typeof obj !== 'object' || obj === null) {
        return false;
    }
    var object = obj;
    for (var _i = 0, methods_1 = methods; _i < methods_1.length; _i++) {
        var method = methods_1[_i];
        if (method in object && typeof object[method] === 'function') {
            return true;
        }
    }
    return false;
}

//# sourceMappingURL=observer.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/api/field_value.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var api_field_value___extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();

/**
 * An opaque base class for FieldValue sentinel objects in our public API,
 * with public static methods for creating said sentinel objects.
 */
// tslint:disable-next-line:class-as-namespace  We use this as a base class.
var FieldValueImpl = /** @class */function () {
    function FieldValueImpl() {}
    FieldValueImpl.delete = function () {
        return DeleteFieldValueImpl.instance;
    };
    FieldValueImpl.serverTimestamp = function () {
        return ServerTimestampFieldValueImpl.instance;
    };
    return FieldValueImpl;
}();

var DeleteFieldValueImpl = /** @class */function (_super) {
    api_field_value___extends(DeleteFieldValueImpl, _super);
    function DeleteFieldValueImpl() {
        return _super.call(this) || this;
    }
    /** Singleton instance. */
    DeleteFieldValueImpl.instance = new DeleteFieldValueImpl();
    return DeleteFieldValueImpl;
}(FieldValueImpl);

var ServerTimestampFieldValueImpl = /** @class */function (_super) {
    api_field_value___extends(ServerTimestampFieldValueImpl, _super);
    function ServerTimestampFieldValueImpl() {
        return _super.call(this) || this;
    }
    /** Singleton instance. */
    ServerTimestampFieldValueImpl.instance = new ServerTimestampFieldValueImpl();
    return ServerTimestampFieldValueImpl;
}(FieldValueImpl);

// Public instance that disallows construction at runtime. This constructor is
// used when exporting FieldValueImpl on firebase.firestore.FieldValue and will
// be called FieldValue publicly. Internally we still use FieldValueImpl which
// has a type-checked private constructor. Note that FieldValueImpl and
// PublicFieldValue can be used interchangeably in instanceof checks.
// For our internal TypeScript code PublicFieldValue doesn't exist as a type,
// and so we need to use FieldValueImpl as type and export it too.
// tslint:disable-next-line:variable-name  We treat this as a class name.
var PublicFieldValue = makeConstructorPrivate(FieldValueImpl, 'Use FieldValue.<field>() instead.');

//# sourceMappingURL=field_value.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/api/user_data_converter.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
















var RESERVED_FIELD_REGEX = /^__.*__$/;
/** The result of parsing document data (e.g. for a setData call). */
var user_data_converter_ParsedSetData = /** @class */function () {
    function ParsedSetData(data, fieldMask, fieldTransforms) {
        this.data = data;
        this.fieldMask = fieldMask;
        this.fieldTransforms = fieldTransforms;
    }
    ParsedSetData.prototype.toMutations = function (key, precondition) {
        var mutations = [];
        if (this.fieldMask !== null) {
            mutations.push(new mutation_PatchMutation(key, this.data, this.fieldMask, precondition));
        } else {
            mutations.push(new mutation_SetMutation(key, this.data, precondition));
        }
        if (this.fieldTransforms.length > 0) {
            mutations.push(new mutation_TransformMutation(key, this.fieldTransforms));
        }
        return mutations;
    };
    return ParsedSetData;
}();

/** The result of parsing "update" data (i.e. for an updateData call). */
var user_data_converter_ParsedUpdateData = /** @class */function () {
    function ParsedUpdateData(data, fieldMask, fieldTransforms) {
        this.data = data;
        this.fieldMask = fieldMask;
        this.fieldTransforms = fieldTransforms;
    }
    ParsedUpdateData.prototype.toMutations = function (key, precondition) {
        var mutations = [new mutation_PatchMutation(key, this.data, this.fieldMask, precondition)];
        if (this.fieldTransforms.length > 0) {
            mutations.push(new mutation_TransformMutation(key, this.fieldTransforms));
        }
        return mutations;
    };
    return ParsedUpdateData;
}();

/*
 * Represents what type of API method provided the data being parsed; useful
 * for determining which error conditions apply during parsing and providing
 * better error messages.
 */
var UserDataSource;
(function (UserDataSource) {
    UserDataSource[UserDataSource["Set"] = 0] = "Set";
    UserDataSource[UserDataSource["Update"] = 1] = "Update";
    UserDataSource[UserDataSource["MergeSet"] = 2] = "MergeSet";
    UserDataSource[UserDataSource["QueryValue"] = 3] = "QueryValue"; // from a where clause or cursor bound
})(UserDataSource || (UserDataSource = {}));
function isWrite(dataSource) {
    switch (dataSource) {
        case UserDataSource.Set: // fall through
        case UserDataSource.MergeSet: // fall through
        case UserDataSource.Update:
            return true;
        case UserDataSource.QueryValue:
            return false;
        default:
            throw fail("Unexpected case for UserDataSource: " + dataSource);
    }
}
/** A "context" object passed around while parsing user data. */
var user_data_converter_ParseContext = /** @class */function () {
    /**
     * Initializes a ParseContext with the given source and path.
     *
     * @param dataSource Indicates what kind of API method this data came from.
     * @param methodName The name of the method the user called to create this
     *     ParseContext.
     * @param path A path within the object being parsed. This could be an empty
     *     path (in which case the context represents the root of the data being
     *     parsed), or a nonempty path (indicating the context represents a nested
     *     location within the data).
     * @param arrayElement Whether or not this context corresponds to an element
     *     of an array.
     * @param fieldTransforms A mutable list of field transforms encountered while
     *     parsing the data.
     * @param fieldMask A mutable list of field paths encountered while parsing
     *     the data.
     *
     * TODO(b/34871131): We don't support array paths right now, so path can be
     * null to indicate the context represents any location within an array (in
     * which case certain features will not work and errors will be somewhat
     * compromised).
     */
    function ParseContext(dataSource, methodName, path, arrayElement, fieldTransforms, fieldMask) {
        this.dataSource = dataSource;
        this.methodName = methodName;
        this.path = path;
        this.arrayElement = arrayElement;
        // Minor hack: If fieldTransforms is undefined, we assume this is an
        // external call and we need to validate the entire path.
        if (fieldTransforms === undefined) {
            this.validatePath();
        }
        this.arrayElement = arrayElement !== undefined ? arrayElement : false;
        this.fieldTransforms = fieldTransforms || [];
        this.fieldMask = fieldMask || [];
    }
    ParseContext.prototype.childContextForField = function (field) {
        var childPath = this.path == null ? null : this.path.child(field);
        var context = new ParseContext(this.dataSource, this.methodName, childPath,
        /*arrayElement=*/false, this.fieldTransforms, this.fieldMask);
        context.validatePathSegment(field);
        return context;
    };
    ParseContext.prototype.childContextForFieldPath = function (field) {
        var childPath = this.path == null ? null : this.path.child(field);
        var context = new ParseContext(this.dataSource, this.methodName, childPath,
        /*arrayElement=*/false, this.fieldTransforms, this.fieldMask);
        context.validatePath();
        return context;
    };
    ParseContext.prototype.childContextForArray = function (index) {
        // TODO(b/34871131): We don't support array paths right now; so make path
        // null.
        return new ParseContext(this.dataSource, this.methodName,
        /*path=*/null,
        /*arrayElement=*/true, this.fieldTransforms, this.fieldMask);
    };
    ParseContext.prototype.createError = function (reason) {
        var fieldDescription = this.path === null || this.path.isEmpty() ? '' : " (found in field " + this.path.toString() + ")";
        return new FirestoreError(Code.INVALID_ARGUMENT, "Function " + this.methodName + "() called with invalid data. " + reason + fieldDescription);
    };
    ParseContext.prototype.validatePath = function () {
        // TODO(b/34871131): Remove null check once we have proper paths for fields
        // within arrays.
        if (this.path === null) {
            return;
        }
        for (var i = 0; i < this.path.length; i++) {
            this.validatePathSegment(this.path.get(i));
        }
    };
    ParseContext.prototype.validatePathSegment = function (segment) {
        if (isWrite(this.dataSource) && RESERVED_FIELD_REGEX.test(segment)) {
            throw this.createError('Document fields cannot begin and end with __');
        }
    };
    ParseContext.prototype.isWrite = function () {
        return this.dataSource === UserDataSource.Set || this.dataSource === UserDataSource.Update;
    };
    return ParseContext;
}();
/**
 * A placeholder object for DocumentReferences in this file, in order to
 * avoid a circular dependency. See the comments for `DataPreConverter` for
 * the full context.
 */
var DocumentKeyReference = /** @class */function () {
    function DocumentKeyReference(databaseId, key) {
        this.databaseId = databaseId;
        this.key = key;
    }
    return DocumentKeyReference;
}();

/**
 * Helper for parsing raw user input (provided via the API) into internal model
 * classes.
 */
var user_data_converter_UserDataConverter = /** @class */function () {
    function UserDataConverter(preConverter) {
        this.preConverter = preConverter;
    }
    /** Parse document data from a non-merge set() call.*/
    UserDataConverter.prototype.parseSetData = function (methodName, input) {
        var context = new user_data_converter_ParseContext(UserDataSource.Set, methodName, path_FieldPath.EMPTY_PATH);
        validatePlainObject('Data must be an object, but it was:', context, input);
        var updateData = this.parseData(input, context);
        return new user_data_converter_ParsedSetData(updateData,
        /* fieldMask= */null, context.fieldTransforms);
    };
    /** Parse document data from a set() call with '{merge:true}'. */
    UserDataConverter.prototype.parseMergeData = function (methodName, input) {
        var context = new user_data_converter_ParseContext(UserDataSource.MergeSet, methodName, path_FieldPath.EMPTY_PATH);
        validatePlainObject('Data must be an object, but it was:', context, input);
        var updateData = this.parseData(input, context);
        var fieldMask = new mutation_FieldMask(context.fieldMask);
        return new user_data_converter_ParsedSetData(updateData, fieldMask, context.fieldTransforms);
    };
    /** Parse update data from an update() call. */
    UserDataConverter.prototype.parseUpdateData = function (methodName, input) {
        var _this = this;
        var context = new user_data_converter_ParseContext(UserDataSource.Update, methodName, path_FieldPath.EMPTY_PATH);
        validatePlainObject('Data must be an object, but it was:', context, input);
        var fieldMaskPaths = [];
        var updateData = field_value_ObjectValue.EMPTY;
        obj_forEach(input, function (key, value) {
            var path = fieldPathFromDotSeparatedString(methodName, key);
            var childContext = context.childContextForFieldPath(path);
            value = _this.runPreConverter(value, childContext);
            if (value instanceof DeleteFieldValueImpl) {
                // Add it to the field mask, but don't add anything to updateData.
                fieldMaskPaths.push(path);
            } else {
                var parsedValue = _this.parseData(value, childContext);
                if (parsedValue != null) {
                    fieldMaskPaths.push(path);
                    updateData = updateData.set(path, parsedValue);
                }
            }
        });
        var mask = new mutation_FieldMask(fieldMaskPaths);
        return new user_data_converter_ParsedUpdateData(updateData, mask, context.fieldTransforms);
    };
    /** Parse update data from a list of field/value arguments. */
    UserDataConverter.prototype.parseUpdateVarargs = function (methodName, field, value, moreFieldsAndValues) {
        var context = new user_data_converter_ParseContext(UserDataSource.Update, methodName, path_FieldPath.EMPTY_PATH);
        var keys = [fieldPathFromArgument(methodName, field)];
        var values = [value];
        if (moreFieldsAndValues.length % 2 !== 0) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + methodName + "() needs to be called with an even number " + 'of arguments that alternate between field names and values.');
        }
        for (var i = 0; i < moreFieldsAndValues.length; i += 2) {
            keys.push(fieldPathFromArgument(methodName, moreFieldsAndValues[i]));
            values.push(moreFieldsAndValues[i + 1]);
        }
        var fieldMaskPaths = [];
        var updateData = field_value_ObjectValue.EMPTY;
        for (var i = 0; i < keys.length; ++i) {
            var path = keys[i];
            var childContext = context.childContextForFieldPath(path);
            var value_1 = this.runPreConverter(values[i], childContext);
            if (value_1 instanceof DeleteFieldValueImpl) {
                // Add it to the field mask, but don't add anything to updateData.
                fieldMaskPaths.push(path);
            } else {
                var parsedValue = this.parseData(value_1, childContext);
                if (parsedValue != null) {
                    fieldMaskPaths.push(path);
                    updateData = updateData.set(path, parsedValue);
                }
            }
        }
        var mask = new mutation_FieldMask(fieldMaskPaths);
        return new user_data_converter_ParsedUpdateData(updateData, mask, context.fieldTransforms);
    };
    /**
     * Parse a "query value" (e.g. value in a where filter or a value in a cursor
     * bound).
     */
    UserDataConverter.prototype.parseQueryValue = function (methodName, input) {
        var context = new user_data_converter_ParseContext(UserDataSource.QueryValue, methodName, path_FieldPath.EMPTY_PATH);
        var parsed = this.parseData(input, context);
        assert_assert(parsed != null, 'Parsed data should not be null.');
        assert_assert(context.fieldTransforms.length === 0, 'Field transforms should have been disallowed.');
        return parsed;
    };
    /** Sends data through this.preConverter, handling any thrown errors. */
    UserDataConverter.prototype.runPreConverter = function (input, context) {
        try {
            return this.preConverter(input);
        } catch (e) {
            var message = errorMessage(e);
            throw context.createError(message);
        }
    };
    /**
     * Internal helper for parsing user data.
     *
     * @param input Data to be parsed.
     * @param context A context object representing the current path being parsed,
     * the source of the data being parsed, etc.
     * @return The parsed value, or null if the value was a FieldValue sentinel
     * that should not be included in the resulting parsed data.
     */
    UserDataConverter.prototype.parseData = function (input, context) {
        input = this.runPreConverter(input, context);
        if (input instanceof Array) {
            // TODO(b/34871131): Include the path containing the array in the error
            // message.
            if (context.arrayElement) {
                throw context.createError('Nested arrays are not supported');
            }
            // If context.path is null we are already inside an array and we don't
            // support field mask paths more granular than the top-level array.
            if (context.path) {
                context.fieldMask.push(context.path);
            }
            return this.parseArray(input, context);
        } else if (looksLikeJsonObject(input)) {
            validatePlainObject('Unsupported field value:', context, input);
            return this.parseObject(input, context);
        } else {
            // If context.path is null, we are inside an array and we should have
            // already added the root of the array to the field mask.
            if (context.path) {
                context.fieldMask.push(context.path);
            }
            return this.parseScalarValue(input, context);
        }
    };
    UserDataConverter.prototype.parseArray = function (array, context) {
        var result = [];
        var entryIndex = 0;
        for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
            var entry = array_1[_i];
            var parsedEntry = this.parseData(entry, context.childContextForArray(entryIndex));
            if (parsedEntry == null) {
                // Just include nulls in the array for fields being replaced with a
                // sentinel.
                parsedEntry = NullValue.INSTANCE;
            }
            result.push(parsedEntry);
            entryIndex++;
        }
        return new field_value_ArrayValue(result);
    };
    UserDataConverter.prototype.parseObject = function (obj, context) {
        var _this = this;
        var result = new sorted_map_SortedMap(primitiveComparator);
        obj_forEach(obj, function (key, val) {
            var parsedValue = _this.parseData(val, context.childContextForField(key));
            if (parsedValue != null) {
                result = result.insert(key, parsedValue);
            }
        });
        return new field_value_ObjectValue(result);
    };
    /**
     * Helper to parse a scalar value (i.e. not an Object or Array)
     *
     * @return The parsed value, or null if the value was a FieldValue sentinel
     * that should not be included in the resulting parsed data.
     */
    UserDataConverter.prototype.parseScalarValue = function (value, context) {
        if (value === null) {
            return NullValue.INSTANCE;
        } else if (typeof value === 'number') {
            if (isSafeInteger(value)) {
                return new IntegerValue(value);
            } else {
                return new DoubleValue(value);
            }
        } else if (typeof value === 'boolean') {
            return field_value_BooleanValue.of(value);
        } else if (typeof value === 'string') {
            return new field_value_StringValue(value);
        } else if (value instanceof Date) {
            return new TimestampValue(timestamp_Timestamp.fromDate(value));
        } else if (value instanceof geo_point_GeoPoint) {
            return new GeoPointValue(value);
        } else if (value instanceof blob_Blob) {
            return new BlobValue(value);
        } else if (value instanceof DocumentKeyReference) {
            return new field_value_RefValue(value.databaseId, value.key);
        } else if (value instanceof FieldValueImpl) {
            if (value instanceof DeleteFieldValueImpl) {
                if (context.dataSource == UserDataSource.MergeSet) {
                    return null;
                } else if (context.dataSource === UserDataSource.Update) {
                    assert_assert(context.path == null || context.path.length > 0, 'FieldValue.delete() at the top level should have already' + ' been handled.');
                    throw context.createError('FieldValue.delete() can only appear at the top level ' + 'of your update data');
                } else {
                    // We shouldn't encounter delete sentinels for queries or non-merge set() calls.
                    throw context.createError('FieldValue.delete() can only be used with update() and set() with {merge:true}');
                }
            } else if (value instanceof ServerTimestampFieldValueImpl) {
                if (!isWrite(context.dataSource)) {
                    throw context.createError('FieldValue.serverTimestamp() can only be used with set()' + ' and update()');
                }
                if (context.path === null) {
                    throw context.createError('FieldValue.serverTimestamp() is not currently' + ' supported inside arrays');
                }
                context.fieldTransforms.push(new FieldTransform(context.path, ServerTimestampTransform.instance));
                // Return null so this value is omitted from the parsed result.
                return null;
            } else {
                return fail('Unknown FieldValue type: ' + value);
            }
        } else {
            throw context.createError("Unsupported field value: " + valueDescription(value));
        }
    };
    return UserDataConverter;
}();

/**
 * Checks whether an object looks like a JSON object that should be converted
 * into a struct. Normal class/prototype instances are considered to look like
 * JSON objects since they should be converted to a struct value. Arrays, Dates,
 * GeoPoints, etc. are not considered to look like JSON objects since they map
 * to specific FieldValue types other than ObjectValue.
 */
function looksLikeJsonObject(input) {
    return typeof input === 'object' && input !== null && !(input instanceof Array) && !(input instanceof Date) && !(input instanceof geo_point_GeoPoint) && !(input instanceof blob_Blob) && !(input instanceof DocumentKeyReference) && !(input instanceof FieldValueImpl);
}
function validatePlainObject(message, context, input) {
    if (!looksLikeJsonObject(input) || !isPlainObject(input)) {
        var description = valueDescription(input);
        if (description === 'an object') {
            // Massage the error if it was an object.
            throw context.createError(message + ' a custom object');
        } else {
            throw context.createError(message + ' ' + description);
        }
    }
}
/**
 * Helper that calls fromDotSeparatedString() but wraps any error thrown.
 */
function fieldPathFromArgument(methodName, path) {
    if (path instanceof field_path_FieldPath) {
        return path._internalPath;
    } else if (typeof path === 'string') {
        return fieldPathFromDotSeparatedString(methodName, path);
    } else {
        var message = 'Field path arguments must be of type string or FieldPath.';
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + methodName + "() called with invalid data. " + message);
    }
}
/**
 * Wraps fromDotSeparatedString with an error message about the method that
 * was thrown.
 * @param methodName The publicly visible method name
 * @param path The dot-separated string form of a field path which will be split
 * on dots.
 */
function fieldPathFromDotSeparatedString(methodName, path) {
    try {
        return fromDotSeparatedString(path)._internalPath;
    } catch (e) {
        var message = errorMessage(e);
        throw new FirestoreError(Code.INVALID_ARGUMENT, "Function " + methodName + "() called with invalid data. " + message);
    }
}
/**
 * Extracts the message from a caught exception, which should be an Error object
 * though JS doesn't guarantee that.
 */
function errorMessage(error) {
    return error instanceof Error ? error.message : error.toString();
}

//# sourceMappingURL=user_data_converter.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/api/database.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var database___extends = this && this.__extends || function () {
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {
        d.__proto__ = b;
    } || function (d, b) {
        for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
        }
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
























// The objects that are a part of this API are exposed to third-parties as
// compiled javascript so we want to flag our private members with a leading
// underscore to discourage their use.
// tslint:disable:strip-private-property-underscore
var DEFAULT_HOST = 'firestore.googleapis.com';
var DEFAULT_SSL = true;
/**
 * A concrete type describing all the values that can be applied via a
 * user-supplied firestore.Settings object. This is a separate type so that
 * defaults can be supplied and the value can be checked for equality.
 */
var database_FirestoreSettings = /** @class */function () {
    function FirestoreSettings(settings) {
        if (settings.host === undefined) {
            if (settings.ssl !== undefined) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
            }
            this.host = DEFAULT_HOST;
            this.ssl = DEFAULT_SSL;
        } else {
            validateNamedType('settings', 'string', 'host', settings.host);
            this.host = settings.host;
            validateNamedOptionalType('settings', 'boolean', 'ssl', settings.ssl);
            this.ssl = defaulted(settings.ssl, DEFAULT_SSL);
        }
        validateOptionNames('settings', settings, ['host', 'ssl', 'credentials']);
        validateNamedOptionalType('settings', 'object', 'credentials', settings.credentials);
        this.credentials = settings.credentials;
    }
    FirestoreSettings.prototype.equals = function (other) {
        return this.host === other.host && this.ssl === other.ssl && this.credentials === other.credentials;
    };
    return FirestoreSettings;
}();
var FirestoreConfig = /** @class */function () {
    function FirestoreConfig() {}
    return FirestoreConfig;
}();
/**
 * The root reference to the database.
 */
var database_Firestore = /** @class */function () {
    function Firestore(databaseIdOrApp) {
        var _this = this;
        this._queue = new async_queue_AsyncQueue();
        this.INTERNAL = {
            delete: function _delete() {
                if (_this._firestoreClient) {
                    return _this._firestoreClient.shutdown();
                } else {
                    return Promise.resolve();
                }
            },
            // Exposed via INTERNAL for use in tests.
            disableNetwork: function disableNetwork() {
                return _this._firestoreClient.disableNetwork();
            },
            enableNetwork: function enableNetwork() {
                return _this._firestoreClient.enableNetwork();
            },
            drainAsyncQueue: function drainAsyncQueue(executeDelayedTasks) {
                return _this._queue.drain(executeDelayedTasks);
            }
        };
        var config = new FirestoreConfig();
        if (typeof databaseIdOrApp.options === 'object') {
            // This is very likely a Firebase app object
            // TODO(b/34177605): Can we somehow use instanceof?
            var app = databaseIdOrApp;
            config.firebaseApp = app;
            config.databaseId = Firestore.databaseIdFromApp(app);
            config.persistenceKey = config.firebaseApp.name;
            config.credentials = new credentials_FirebaseCredentialsProvider(app);
        } else {
            var external_1 = databaseIdOrApp;
            if (!external_1.projectId) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide projectId');
            }
            config.databaseId = new database_info_DatabaseId(external_1.projectId, external_1.database);
            // Use a default persistenceKey that lines up with FirebaseApp.
            config.persistenceKey = '[DEFAULT]';
            config.credentials = new credentials_EmptyCredentialsProvider();
        }
        config.settings = new database_FirestoreSettings({});
        this._config = config;
        this._databaseId = config.databaseId;
    }
    Firestore.prototype.settings = function (settingsLiteral) {
        validateExactNumberOfArgs('Firestore.settings', arguments, 1);
        validateArgType('Firestore.settings', 'object', 1, settingsLiteral);
        if (obj_contains(settingsLiteral, 'persistence')) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, '"persistence" is now specified with a separate call to ' + 'firestore.enablePersistence().');
        }
        var newSettings = new database_FirestoreSettings(settingsLiteral);
        if (this._firestoreClient && !this._config.settings.equals(newSettings)) {
            throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and its settings can no longer ' + 'be changed. You can only call settings() before calling any other ' + 'methods on a Firestore object.');
        }
        this._config.settings = newSettings;
        if (newSettings.credentials !== undefined) {
            this._config.credentials = makeCredentialsProvider(newSettings.credentials);
        }
    };
    Firestore.prototype.enablePersistence = function () {
        if (this._firestoreClient) {
            throw new FirestoreError(Code.FAILED_PRECONDITION, 'Firestore has already been started and persistence can no longer ' + 'be enabled. You can only call enablePersistence() before calling ' + 'any other methods on a Firestore object.');
        }
        return this.configureClient( /* persistence= */true);
    };
    Firestore.prototype.ensureClientConfigured = function () {
        if (!this._firestoreClient) {
            this.configureClient( /* persistence= */false);
        }
        return this._firestoreClient;
    };
    Firestore.prototype.configureClient = function (persistence) {
        var _this = this;
        assert_assert(!!this._config.settings.host, 'FirestoreSettings.host cannot be falsey');
        assert_assert(!this._firestoreClient, 'configureClient() called multiple times');
        var databaseInfo = new DatabaseInfo(this._config.databaseId, this._config.persistenceKey, this._config.settings.host, this._config.settings.ssl);
        var preConverter = function preConverter(value) {
            if (value instanceof database_DocumentReference) {
                var thisDb = _this._config.databaseId;
                var otherDb = value.firestore._config.databaseId;
                if (!otherDb.equals(thisDb)) {
                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Document reference is for database ' + (otherDb.projectId + "/" + otherDb.database + " but should be ") + ("for database " + thisDb.projectId + "/" + thisDb.database));
                }
                return new DocumentKeyReference(_this._config.databaseId, value._key);
            } else {
                return value;
            }
        };
        this._dataConverter = new user_data_converter_UserDataConverter(preConverter);
        this._firestoreClient = new firestore_client_FirestoreClient(platform_PlatformSupport.getPlatform(), databaseInfo, this._config.credentials, this._queue);
        return this._firestoreClient.start(persistence);
    };
    Firestore.databaseIdFromApp = function (app) {
        var options = app.options;
        if (!obj_contains(options, 'projectId')) {
            // TODO(b/62673263): We can safely remove the special handling of
            // 'firestoreId' once alpha testers have upgraded.
            if (obj_contains(options, 'firestoreId')) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, '"firestoreId" is now specified as "projectId" in ' + 'firebase.initializeApp.');
            }
            throw new FirestoreError(Code.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
        }
        if (obj_contains(options, 'firestoreOptions')) {
            // TODO(b/62673263): We can safely remove the special handling of
            // 'firestoreOptions' once alpha testers have upgraded.
            throw new FirestoreError(Code.INVALID_ARGUMENT, '"firestoreOptions" values are now specified with ' + 'Firestore.settings()');
        }
        var projectId = options['projectId'];
        if (!projectId || typeof projectId !== 'string') {
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'projectId must be a string in FirebaseApp.options');
        }
        return new database_info_DatabaseId(projectId);
    };
    Object.defineProperty(Firestore.prototype, "app", {
        get: function get() {
            if (!this._config.firebaseApp) {
                throw new FirestoreError(Code.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is " + 'not available');
            }
            return this._config.firebaseApp;
        },
        enumerable: true,
        configurable: true
    });
    Firestore.prototype.collection = function (pathString) {
        validateExactNumberOfArgs('Firestore.collection', arguments, 1);
        validateArgType('Firestore.collection', 'string', 1, pathString);
        if (!pathString) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide a non-empty collection path to collection()');
        }
        this.ensureClientConfigured();
        return new database_CollectionReference(path_ResourcePath.fromString(pathString), this);
    };
    Firestore.prototype.doc = function (pathString) {
        validateExactNumberOfArgs('Firestore.doc', arguments, 1);
        validateArgType('Firestore.doc', 'string', 1, pathString);
        if (!pathString) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide a non-empty document path to doc()');
        }
        this.ensureClientConfigured();
        return database_DocumentReference.forPath(path_ResourcePath.fromString(pathString), this);
    };
    Firestore.prototype.runTransaction = function (updateFunction) {
        var _this = this;
        validateExactNumberOfArgs('Firestore.runTransaction', arguments, 1);
        validateArgType('Firestore.runTransaction', 'function', 1, updateFunction);
        return this.ensureClientConfigured().transaction(function (transaction) {
            return updateFunction(new database_Transaction(_this, transaction));
        });
    };
    Firestore.prototype.batch = function () {
        this.ensureClientConfigured();
        return new database_WriteBatch(this);
    };
    Object.defineProperty(Firestore, "logLevel", {
        get: function get() {
            switch (getLogLevel()) {
                case LogLevel.DEBUG:
                    return 'debug';
                case LogLevel.ERROR:
                    return 'error';
                case LogLevel.SILENT:
                    return 'silent';
                default:
                    return fail('Unknown log level: ' + getLogLevel());
            }
        },
        enumerable: true,
        configurable: true
    });
    Firestore.setLogLevel = function (level) {
        validateExactNumberOfArgs('Firestore.setLogLevel', arguments, 1);
        validateArgType('Firestore.setLogLevel', 'string', 1, level);
        switch (level) {
            case 'debug':
                setLogLevel(LogLevel.DEBUG);
                break;
            case 'error':
                setLogLevel(LogLevel.ERROR);
                break;
            case 'silent':
                setLogLevel(LogLevel.SILENT);
                break;
            default:
                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid log level: ' + level);
        }
    };
    return Firestore;
}();

/**
 * A reference to a transaction.
 */
var database_Transaction = /** @class */function () {
    function Transaction(_firestore, _transaction) {
        this._firestore = _firestore;
        this._transaction = _transaction;
    }
    Transaction.prototype.get = function (documentRef) {
        var _this = this;
        validateExactNumberOfArgs('Transaction.get', arguments, 1);
        var ref = validateReference('Transaction.get', documentRef, this._firestore);
        return this._transaction.lookup([ref._key]).then(function (docs) {
            if (!docs || docs.length !== 1) {
                return fail('Mismatch in docs returned from document lookup.');
            }
            var doc = docs[0];
            if (doc instanceof document_NoDocument) {
                return new database_DocumentSnapshot(_this._firestore, ref._key, null, false);
            }
            return new database_DocumentSnapshot(_this._firestore, ref._key, doc, false);
        });
    };
    Transaction.prototype.set = function (documentRef, value, options) {
        validateBetweenNumberOfArgs('Transaction.set', arguments, 2, 3);
        var ref = validateReference('Transaction.set', documentRef, this._firestore);
        options = validateSetOptions('Transaction.set', options);
        var parsed = options.merge ? this._firestore._dataConverter.parseMergeData('Transaction.set', value) : this._firestore._dataConverter.parseSetData('Transaction.set', value);
        this._transaction.set(ref._key, parsed);
        return this;
    };
    Transaction.prototype.update = function (documentRef, fieldOrUpdateData, value) {
        var moreFieldsAndValues = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            moreFieldsAndValues[_i - 3] = arguments[_i];
        }
        var ref;
        var parsed;
        if (typeof fieldOrUpdateData === 'string' || fieldOrUpdateData instanceof field_path_FieldPath) {
            validateAtLeastNumberOfArgs('Transaction.update', arguments, 3);
            ref = validateReference('Transaction.update', documentRef, this._firestore);
            parsed = this._firestore._dataConverter.parseUpdateVarargs('Transaction.update', fieldOrUpdateData, value, moreFieldsAndValues);
        } else {
            validateExactNumberOfArgs('Transaction.update', arguments, 2);
            ref = validateReference('Transaction.update', documentRef, this._firestore);
            parsed = this._firestore._dataConverter.parseUpdateData('Transaction.update', fieldOrUpdateData);
        }
        this._transaction.update(ref._key, parsed);
        return this;
    };
    Transaction.prototype.delete = function (documentRef) {
        validateExactNumberOfArgs('Transaction.delete', arguments, 1);
        var ref = validateReference('Transaction.delete', documentRef, this._firestore);
        this._transaction.delete(ref._key);
        return this;
    };
    return Transaction;
}();

var database_WriteBatch = /** @class */function () {
    function WriteBatch(_firestore) {
        this._firestore = _firestore;
        this._mutations = [];
        this._committed = false;
    }
    WriteBatch.prototype.set = function (documentRef, value, options) {
        validateBetweenNumberOfArgs('WriteBatch.set', arguments, 2, 3);
        this.verifyNotCommitted();
        var ref = validateReference('WriteBatch.set', documentRef, this._firestore);
        options = validateSetOptions('WriteBatch.set', options);
        var parsed = options.merge ? this._firestore._dataConverter.parseMergeData('WriteBatch.set', value) : this._firestore._dataConverter.parseSetData('WriteBatch.set', value);
        this._mutations = this._mutations.concat(parsed.toMutations(ref._key, mutation_Precondition.NONE));
        return this;
    };
    WriteBatch.prototype.update = function (documentRef, fieldOrUpdateData, value) {
        var moreFieldsAndValues = [];
        for (var _i = 3; _i < arguments.length; _i++) {
            moreFieldsAndValues[_i - 3] = arguments[_i];
        }
        this.verifyNotCommitted();
        var ref;
        var parsed;
        if (typeof fieldOrUpdateData === 'string' || fieldOrUpdateData instanceof field_path_FieldPath) {
            validateAtLeastNumberOfArgs('WriteBatch.update', arguments, 3);
            ref = validateReference('WriteBatch.update', documentRef, this._firestore);
            parsed = this._firestore._dataConverter.parseUpdateVarargs('WriteBatch.update', fieldOrUpdateData, value, moreFieldsAndValues);
        } else {
            validateExactNumberOfArgs('WriteBatch.update', arguments, 2);
            ref = validateReference('WriteBatch.update', documentRef, this._firestore);
            parsed = this._firestore._dataConverter.parseUpdateData('WriteBatch.update', fieldOrUpdateData);
        }
        this._mutations = this._mutations.concat(parsed.toMutations(ref._key, mutation_Precondition.exists(true)));
        return this;
    };
    WriteBatch.prototype.delete = function (documentRef) {
        validateExactNumberOfArgs('WriteBatch.delete', arguments, 1);
        this.verifyNotCommitted();
        var ref = validateReference('WriteBatch.delete', documentRef, this._firestore);
        this._mutations = this._mutations.concat(new mutation_DeleteMutation(ref._key, mutation_Precondition.NONE));
        return this;
    };
    WriteBatch.prototype.commit = function () {
        this.verifyNotCommitted();
        this._committed = true;
        if (this._mutations.length > 0) {
            return this._firestore.ensureClientConfigured().write(this._mutations);
        } else {
            return Promise.resolve();
        }
    };
    WriteBatch.prototype.verifyNotCommitted = function () {
        if (this._committed) {
            throw new FirestoreError(Code.FAILED_PRECONDITION, 'A write batch can no longer be used after commit() ' + 'has been called.');
        }
    };
    return WriteBatch;
}();

/**
 * A reference to a particular document in a collection in the database.
 */
var database_DocumentReference = /** @class */function () {
    function DocumentReference(_key, firestore) {
        this._key = _key;
        this.firestore = firestore;
        this._firestoreClient = this.firestore.ensureClientConfigured();
    }
    DocumentReference.forPath = function (path, firestore) {
        if (path.length % 2 !== 0) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid document reference. Document ' + 'references must have an even number of segments, but ' + (path.canonicalString() + " has " + path.length));
        }
        return new DocumentReference(new document_key_DocumentKey(path), firestore);
    };
    Object.defineProperty(DocumentReference.prototype, "id", {
        get: function get() {
            return this._key.path.lastSegment();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentReference.prototype, "parent", {
        get: function get() {
            return new database_CollectionReference(this._key.path.popLast(), this.firestore);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentReference.prototype, "path", {
        get: function get() {
            return this._key.path.canonicalString();
        },
        enumerable: true,
        configurable: true
    });
    DocumentReference.prototype.collection = function (pathString) {
        validateExactNumberOfArgs('DocumentReference.collection', arguments, 1);
        validateArgType('DocumentReference.collection', 'string', 1, pathString);
        if (!pathString) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Must provide a non-empty collection name to collection()');
        }
        var path = path_ResourcePath.fromString(pathString);
        return new database_CollectionReference(this._key.path.child(path), this.firestore);
    };
    DocumentReference.prototype.isEqual = function (other) {
        if (!(other instanceof DocumentReference)) {
            throw invalidClassError('isEqual', 'DocumentReference', 1, other);
        }
        return this.firestore === other.firestore && this._key.equals(other._key);
    };
    DocumentReference.prototype.set = function (value, options) {
        validateBetweenNumberOfArgs('DocumentReference.set', arguments, 1, 2);
        options = validateSetOptions('DocumentReference.set', options);
        var parsed = options.merge ? this.firestore._dataConverter.parseMergeData('DocumentReference.set', value) : this.firestore._dataConverter.parseSetData('DocumentReference.set', value);
        return this._firestoreClient.write(parsed.toMutations(this._key, mutation_Precondition.NONE));
    };
    DocumentReference.prototype.update = function (fieldOrUpdateData, value) {
        var moreFieldsAndValues = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            moreFieldsAndValues[_i - 2] = arguments[_i];
        }
        var parsed;
        if (typeof fieldOrUpdateData === 'string' || fieldOrUpdateData instanceof field_path_FieldPath) {
            validateAtLeastNumberOfArgs('DocumentReference.update', arguments, 2);
            parsed = this.firestore._dataConverter.parseUpdateVarargs('DocumentReference.update', fieldOrUpdateData, value, moreFieldsAndValues);
        } else {
            validateExactNumberOfArgs('DocumentReference.update', arguments, 1);
            parsed = this.firestore._dataConverter.parseUpdateData('DocumentReference.update', fieldOrUpdateData);
        }
        return this._firestoreClient.write(parsed.toMutations(this._key, mutation_Precondition.exists(true)));
    };
    DocumentReference.prototype.delete = function () {
        validateExactNumberOfArgs('DocumentReference.delete', arguments, 0);
        return this._firestoreClient.write([new mutation_DeleteMutation(this._key, mutation_Precondition.NONE)]);
    };
    DocumentReference.prototype.onSnapshot = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        validateBetweenNumberOfArgs('DocumentReference.onSnapshot', arguments, 1, 4);
        var options = {
            includeMetadataChanges: false
        };
        var observer;
        var currArg = 0;
        if (typeof args[currArg] === 'object' && !isPartialObserver(args[currArg])) {
            options = args[currArg];
            validateOptionNames('DocumentReference.onSnapshot', options, ['includeMetadataChanges']);
            validateNamedOptionalType('DocumentReference.onSnapshot', 'boolean', 'includeMetadataChanges', options.includeMetadataChanges);
            currArg++;
        }
        var internalOptions = {
            includeDocumentMetadataChanges: options.includeMetadataChanges,
            includeQueryMetadataChanges: options.includeMetadataChanges
        };
        if (isPartialObserver(args[currArg])) {
            observer = args[currArg];
        } else {
            validateArgType('DocumentReference.onSnapshot', 'function', currArg, args[currArg]);
            validateOptionalArgType('DocumentReference.onSnapshot', 'function', currArg + 1, args[currArg + 1]);
            validateOptionalArgType('DocumentReference.onSnapshot', 'function', currArg + 2, args[currArg + 2]);
            observer = {
                next: args[currArg],
                error: args[currArg + 1],
                complete: args[currArg + 2]
            };
        }
        return this.onSnapshotInternal(internalOptions, observer);
    };
    DocumentReference.prototype.onSnapshotInternal = function (options, observer) {
        var _this = this;
        var errHandler = function errHandler(err) {
            console.error('Uncaught Error in onSnapshot:', err);
        };
        if (observer.error) {
            errHandler = observer.error.bind(observer);
        }
        var asyncObserver = new AsyncObserver({
            next: function next(snapshot) {
                if (observer.next) {
                    assert_assert(snapshot.docs.size <= 1, 'Too many documents returned on a document query');
                    var doc = snapshot.docs.get(_this._key);
                    observer.next(new database_DocumentSnapshot(_this.firestore, _this._key, doc, snapshot.fromCache));
                }
            },
            error: errHandler
        });
        var internalListener = this._firestoreClient.listen(query_Query.atPath(this._key.path), asyncObserver, options);
        return function () {
            asyncObserver.mute();
            _this._firestoreClient.unlisten(internalListener);
        };
    };
    DocumentReference.prototype.get = function () {
        var _this = this;
        validateExactNumberOfArgs('DocumentReference.get', arguments, 0);
        return new Promise(function (resolve, reject) {
            var unlisten = _this.onSnapshotInternal({
                includeQueryMetadataChanges: true,
                includeDocumentMetadataChanges: true,
                waitForSyncWhenOnline: true
            }, {
                next: function next(snap) {
                    // Remove query first before passing event to user to avoid
                    // user actions affecting the now stale query.
                    unlisten();
                    if (!snap.exists && snap.metadata.fromCache) {
                        // TODO(dimond): If we're online and the document doesn't
                        // exist then we resolve with a doc.exists set to false. If
                        // we're offline however, we reject the Promise in this
                        // case. Two options: 1) Cache the negative response from
                        // the server so we can deliver that even when you're
                        // offline 2) Actually reject the Promise in the online case
                        // if the document doesn't exist.
                        reject(new FirestoreError(Code.ABORTED, 'Failed to get document because the client is ' + 'offline.'));
                    } else {
                        resolve(snap);
                    }
                },
                error: reject
            });
        });
    };
    return DocumentReference;
}();

var database_DocumentSnapshot = /** @class */function () {
    function DocumentSnapshot(_firestore, _key, _document, _fromCache) {
        this._firestore = _firestore;
        this._key = _key;
        this._document = _document;
        this._fromCache = _fromCache;
    }
    DocumentSnapshot.prototype.data = function () {
        validateExactNumberOfArgs('DocumentSnapshot.data', arguments, 0);
        if (!this._document) {
            throw new FirestoreError(Code.NOT_FOUND, "This document doesn't exist. Check doc.exists to make sure " + 'the document exists before calling doc.data().');
        }
        return this.convertObject(this._document.data);
    };
    DocumentSnapshot.prototype.get = function (fieldPath) {
        validateExactNumberOfArgs('DocumentSnapshot.get', arguments, 1);
        if (!this._document) {
            throw new FirestoreError(Code.NOT_FOUND, "This document doesn't exist. Check doc.exists to make sure " + 'the document exists before calling doc.get().');
        }
        var value = this._document.data.field(fieldPathFromArgument('DocumentSnapshot.get', fieldPath));
        return value === undefined ? undefined : this.convertValue(value);
    };
    Object.defineProperty(DocumentSnapshot.prototype, "id", {
        get: function get() {
            return this._key.path.lastSegment();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentSnapshot.prototype, "ref", {
        get: function get() {
            return new database_DocumentReference(this._key, this._firestore);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentSnapshot.prototype, "exists", {
        get: function get() {
            return this._document !== null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DocumentSnapshot.prototype, "metadata", {
        get: function get() {
            return {
                hasPendingWrites: this._document !== null && this._document.hasLocalMutations,
                fromCache: this._fromCache
            };
        },
        enumerable: true,
        configurable: true
    });
    DocumentSnapshot.prototype.convertObject = function (data) {
        var _this = this;
        var result = {};
        data.forEach(function (key, value) {
            result[key] = _this.convertValue(value);
        });
        return result;
    };
    DocumentSnapshot.prototype.convertValue = function (value) {
        if (value instanceof field_value_ObjectValue) {
            return this.convertObject(value);
        } else if (value instanceof field_value_ArrayValue) {
            return this.convertArray(value);
        } else if (value instanceof field_value_RefValue) {
            var key = value.value();
            var database = this._firestore.ensureClientConfigured().databaseId();
            if (!value.databaseId.equals(database)) {
                // TODO(b/64130202): Somehow support foreign references.
                log_error("Document " + this._key.path + " contains a document " + "reference within a different database (" + (value.databaseId.projectId + "/" + value.databaseId.database + ") which is not ") + "supported. It will be treated as a reference in the current " + ("database (" + database.projectId + "/" + database.database + ") ") + "instead.");
            }
            return new database_DocumentReference(key, this._firestore);
        } else {
            return value.value();
        }
    };
    DocumentSnapshot.prototype.convertArray = function (data) {
        var _this = this;
        return data.internalValue.map(function (value) {
            return _this.convertValue(value);
        });
    };
    return DocumentSnapshot;
}();

var database_Query = /** @class */function () {
    function Query(_query, firestore) {
        this._query = _query;
        this.firestore = firestore;
    }
    Query.prototype.where = function (field, opStr, value) {
        validateExactNumberOfArgs('Query.where', arguments, 3);
        validateArgType('Query.where', 'string', 2, opStr);
        validateDefined('Query.where', 3, value);
        var fieldValue;
        var fieldPath = fieldPathFromArgument('Query.where', field);
        if (fieldPath.isKeyField()) {
            if (typeof value === 'string') {
                if (value.indexOf('/') !== -1) {
                    // TODO(dimond): Allow slashes once ancestor queries are supported
                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Function Query.where() requires its third parameter to be a ' + 'valid document ID if the first parameter is ' + 'FieldPath.documentId(), but it contains a slash.');
                }
                if (value === '') {
                    throw new FirestoreError(Code.INVALID_ARGUMENT, 'Function Query.where() requires its third parameter to be a ' + 'valid document ID if the first parameter is ' + 'FieldPath.documentId(), but it was an empty string.');
                }
                var path = this._query.path.child(new path_ResourcePath([value]));
                assert_assert(path.length % 2 === 0, 'Path should be a document key');
                fieldValue = new field_value_RefValue(this.firestore._databaseId, new document_key_DocumentKey(path));
            } else if (value instanceof database_DocumentReference) {
                var ref = value;
                fieldValue = new field_value_RefValue(this.firestore._databaseId, ref._key);
            } else {
                throw new FirestoreError(Code.INVALID_ARGUMENT, "Function Query.where() requires its third parameter to be a " + "string or a DocumentReference if the first parameter is " + "FieldPath.documentId(), but it was: " + (valueDescription(value) + "."));
            }
        } else {
            fieldValue = this.firestore._dataConverter.parseQueryValue('Query.where', value);
        }
        var filter = fieldFilter(fieldPath, query_RelationOp.fromString(opStr), fieldValue);
        this.validateNewFilter(filter);
        return new Query(this._query.addFilter(filter), this.firestore);
    };
    Query.prototype.orderBy = function (field, directionStr) {
        validateBetweenNumberOfArgs('Query.orderBy', arguments, 1, 2);
        validateOptionalArgType('Query.orderBy', 'string', 2, directionStr);
        var direction;
        if (directionStr === undefined || directionStr === 'asc') {
            direction = Direction.ASCENDING;
        } else if (directionStr === 'desc') {
            direction = Direction.DESCENDING;
        } else {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Function Query.orderBy() has unknown direction '" + directionStr + "', " + "expected 'asc' or 'desc'.");
        }
        if (this._query.startAt !== null) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call Query.startAt() or ' + 'Query.startAfter() before calling Query.orderBy().');
        }
        if (this._query.endAt !== null) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. You must not call Query.endAt() or ' + 'Query.endBefore() before calling Query.orderBy().');
        }
        var fieldPath = fieldPathFromArgument('Query.orderBy', field);
        var orderBy = new query_OrderBy(fieldPath, direction);
        this.validateNewOrderBy(orderBy);
        return new Query(this._query.addOrderBy(orderBy), this.firestore);
    };
    Query.prototype.limit = function (n) {
        validateExactNumberOfArgs('Query.limit', arguments, 1);
        validateArgType('Query.limit', 'number', 1, n);
        if (n <= 0) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid Query. Query limit (" + n + ") is invalid. Limit must be " + 'positive.');
        }
        return new Query(this._query.withLimit(n), this.firestore);
    };
    Query.prototype.startAt = function (docOrField) {
        var fields = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            fields[_i - 1] = arguments[_i];
        }
        validateAtLeastNumberOfArgs('Query.startAt', arguments, 1);
        var bound = this.boundFromDocOrFields('Query.startAt', docOrField, fields,
        /*before=*/true);
        return new Query(this._query.withStartAt(bound), this.firestore);
    };
    Query.prototype.startAfter = function (docOrField) {
        var fields = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            fields[_i - 1] = arguments[_i];
        }
        validateAtLeastNumberOfArgs('Query.startAfter', arguments, 1);
        var bound = this.boundFromDocOrFields('Query.startAfter', docOrField, fields,
        /*before=*/false);
        return new Query(this._query.withStartAt(bound), this.firestore);
    };
    Query.prototype.endBefore = function (docOrField) {
        var fields = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            fields[_i - 1] = arguments[_i];
        }
        validateAtLeastNumberOfArgs('Query.endBefore', arguments, 1);
        var bound = this.boundFromDocOrFields('Query.endBefore', docOrField, fields,
        /*before=*/true);
        return new Query(this._query.withEndAt(bound), this.firestore);
    };
    Query.prototype.endAt = function (docOrField) {
        var fields = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            fields[_i - 1] = arguments[_i];
        }
        validateAtLeastNumberOfArgs('Query.endAt', arguments, 1);
        var bound = this.boundFromDocOrFields('Query.endAt', docOrField, fields,
        /*before=*/false);
        return new Query(this._query.withEndAt(bound), this.firestore);
    };
    Query.prototype.isEqual = function (other) {
        if (!(other instanceof Query)) {
            throw invalidClassError('isEqual', 'Query', 1, other);
        }
        return this.firestore === other.firestore && this._query.equals(other._query);
    };
    /** Helper function to create a bound from a document or fields */
    Query.prototype.boundFromDocOrFields = function (methodName, docOrField, fields, before) {
        validateDefined(methodName, 1, docOrField);
        if (docOrField instanceof database_DocumentSnapshot) {
            if (fields.length > 0) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, "Too many arguments provided to " + methodName + "().");
            }
            var snap = docOrField;
            if (!snap.exists) {
                throw new FirestoreError(Code.NOT_FOUND, "Can't use a DocumentSnapshot that doesn't exist for " + (methodName + "()."));
            }
            return this.boundFromDocument(methodName, snap._document, before);
        } else {
            var allFields = [docOrField].concat(fields);
            return this.boundFromFields(methodName, allFields, before);
        }
    };
    /**
     * Create a Bound from a query and a document.
     *
     * Note that the Bound will always include the key of the document
     * and so only the provided document will compare equal to the returned
     * position.
     *
     * Will throw if the document does not contain all fields of the order by
     * of the query.
     */
    Query.prototype.boundFromDocument = function (methodName, doc, before) {
        var components = [];
        // Because people expect to continue/end a query at the exact document
        // provided, we need to use the implicit sort order rather than the explicit
        // sort order, because it's guaranteed to contain the document key. That way
        // the position becomes unambiguous and the query continues/ends exactly at
        // the provided document. Without the key (by using the explicit sort
        // orders), multiple documents could match the position, yielding duplicate
        // results.
        for (var _i = 0, _a = this._query.orderBy; _i < _a.length; _i++) {
            var orderBy = _a[_i];
            if (orderBy.field.isKeyField()) {
                components.push(new field_value_RefValue(this.firestore._databaseId, doc.key));
            } else {
                var value = doc.field(orderBy.field);
                if (value !== undefined) {
                    components.push(value);
                } else {
                    var field = orderBy.field.canonicalString();
                    throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You are trying to start or end a query using a " + ("document for which the field '" + field + "' (used as the ") + "orderBy) does not exist.");
                }
            }
        }
        return new query_Bound(components, before);
    };
    /**
     * Converts a list of field values to a Bound for the given query.
     */
    Query.prototype.boundFromFields = function (methodName, values, before) {
        // Use explicit order by's because it has to match the query the user made
        var orderBy = this._query.explicitOrderBy;
        if (values.length > orderBy.length) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Too many arguments provided to " + methodName + "(). " + "The number of arguments must be less than or equal to the " + "number of Query.orderBy() clauses");
        }
        var components = [];
        for (var i = 0; i < values.length; i++) {
            var rawValue = values[i];
            var orderByComponent = orderBy[i];
            if (orderByComponent.field.isKeyField()) {
                if (typeof rawValue !== 'string') {
                    throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. Expected a string for document ID in " + (methodName + "(), but got a " + typeof rawValue));
                }
                if (rawValue.indexOf('/') !== -1) {
                    throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. Document ID '" + rawValue + "' contains a slash in " + (methodName + "()"));
                }
                var key = new document_key_DocumentKey(this._query.path.child(rawValue));
                components.push(new field_value_RefValue(this.firestore._databaseId, key));
            } else {
                var wrapped = this.firestore._dataConverter.parseQueryValue(methodName, rawValue);
                components.push(wrapped);
            }
        }
        return new query_Bound(components, before);
    };
    Query.prototype.onSnapshot = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        validateBetweenNumberOfArgs('Query.onSnapshot', arguments, 1, 4);
        var options = {};
        var observer;
        var currArg = 0;
        if (typeof args[currArg] === 'object' && !isPartialObserver(args[currArg])) {
            options = args[currArg];
            validateOptionNames('Query.onSnapshot', options, ['includeQueryMetadataChanges', 'includeDocumentMetadataChanges']);
            validateNamedOptionalType('Query.onSnapshot', 'boolean', 'includeDocumentMetadataChanges', options.includeDocumentMetadataChanges);
            validateNamedOptionalType('Query.onSnapshot', 'boolean', 'includeQueryMetadataChanges', options.includeQueryMetadataChanges);
            currArg++;
        }
        if (isPartialObserver(args[currArg])) {
            observer = args[currArg];
        } else {
            validateArgType('Query.onSnapshot', 'function', currArg, args[currArg]);
            validateOptionalArgType('Query.onSnapshot', 'function', currArg + 1, args[currArg + 1]);
            validateOptionalArgType('Query.onSnapshot', 'function', currArg + 2, args[currArg + 2]);
            observer = {
                next: args[currArg],
                error: args[currArg + 1],
                complete: args[currArg + 2]
            };
        }
        return this.onSnapshotInternal(options, observer);
    };
    Query.prototype.onSnapshotInternal = function (options, observer) {
        var _this = this;
        var errHandler = function errHandler(err) {
            console.error('Uncaught Error in onSnapshot:', err);
        };
        if (observer.error) {
            errHandler = observer.error.bind(observer);
        }
        var asyncObserver = new AsyncObserver({
            next: function next(result) {
                if (observer.next) {
                    observer.next(new database_QuerySnapshot(_this.firestore, _this._query, result));
                }
            },
            error: errHandler
        });
        var firestoreClient = this.firestore.ensureClientConfigured();
        var internalListener = firestoreClient.listen(this._query, asyncObserver, options);
        return function () {
            asyncObserver.mute();
            firestoreClient.unlisten(internalListener);
        };
    };
    Query.prototype.get = function () {
        var _this = this;
        validateExactNumberOfArgs('Query.get', arguments, 0);
        return new Promise(function (resolve, reject) {
            var unlisten = _this.onSnapshotInternal({
                includeDocumentMetadataChanges: false,
                includeQueryMetadataChanges: true,
                waitForSyncWhenOnline: true
            }, {
                next: function next(result) {
                    // Remove query first before passing event to user to avoid
                    // user actions affecting the now stale query.
                    unlisten();
                    resolve(result);
                },
                error: reject
            });
        });
    };
    Query.prototype.validateNewFilter = function (filter) {
        if (filter instanceof query_RelationFilter && filter.isInequality()) {
            var existingField = this._query.getInequalityFilterField();
            if (existingField !== null && !existingField.equals(filter.field)) {
                throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid query. All where filters with an inequality' + ' (<, <=, >, or >=) must be on the same field. But you have' + (" inequality filters on '" + existingField.toString() + "'") + (" and '" + filter.field.toString() + "'"));
            }
            var firstOrderByField = this._query.getFirstOrderByField();
            if (firstOrderByField !== null) {
                this.validateOrderByAndInequalityMatch(filter.field, firstOrderByField);
            }
        }
    };
    Query.prototype.validateNewOrderBy = function (orderBy) {
        if (this._query.getFirstOrderByField() === null) {
            // This is the first order by. It must match any inequality.
            var inequalityField = this._query.getInequalityFilterField();
            if (inequalityField !== null) {
                this.validateOrderByAndInequalityMatch(inequalityField, orderBy.field);
            }
        }
    };
    Query.prototype.validateOrderByAndInequalityMatch = function (inequality, orderBy) {
        if (!orderBy.equals(inequality)) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, "Invalid query. You have a where filter with an inequality " + ("(<, <=, >, or >=) on field '" + inequality.toString() + "' ") + ("and so you must also use '" + inequality.toString() + "' ") + "as your first Query.orderBy(), but your first Query.orderBy() " + ("is on field '" + orderBy.toString() + "' instead."));
        }
    };
    return Query;
}();

var database_QuerySnapshot = /** @class */function () {
    function QuerySnapshot(_firestore, _originalQuery, _snapshot) {
        this._firestore = _firestore;
        this._originalQuery = _originalQuery;
        this._snapshot = _snapshot;
        this._cachedChanges = null;
        this.metadata = {
            fromCache: _snapshot.fromCache,
            hasPendingWrites: _snapshot.hasPendingWrites
        };
    }
    Object.defineProperty(QuerySnapshot.prototype, "docs", {
        get: function get() {
            var result = [];
            this.forEach(function (doc) {
                return result.push(doc);
            });
            return result;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QuerySnapshot.prototype, "empty", {
        get: function get() {
            return this._snapshot.docs.isEmpty();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QuerySnapshot.prototype, "size", {
        get: function get() {
            return this._snapshot.docs.size;
        },
        enumerable: true,
        configurable: true
    });
    QuerySnapshot.prototype.forEach = function (callback, thisArg) {
        var _this = this;
        validateBetweenNumberOfArgs('QuerySnapshot.forEach', arguments, 1, 2);
        validateArgType('QuerySnapshot.forEach', 'function', 1, callback);
        this._snapshot.docs.forEach(function (doc) {
            callback.call(thisArg, _this.convertToDocumentImpl(doc));
        });
    };
    Object.defineProperty(QuerySnapshot.prototype, "query", {
        get: function get() {
            return new database_Query(this._originalQuery, this._firestore);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(QuerySnapshot.prototype, "docChanges", {
        get: function get() {
            if (!this._cachedChanges) {
                this._cachedChanges = changesFromSnapshot(this._firestore, this._snapshot);
            }
            return this._cachedChanges;
        },
        enumerable: true,
        configurable: true
    });
    QuerySnapshot.prototype.convertToDocumentImpl = function (doc) {
        return new database_DocumentSnapshot(this._firestore, doc.key, doc, this.metadata.fromCache);
    };
    return QuerySnapshot;
}();

var database_CollectionReference = /** @class */function (_super) {
    database___extends(CollectionReference, _super);
    function CollectionReference(path, firestore) {
        var _this = _super.call(this, query_Query.atPath(path), firestore) || this;
        if (path.length % 2 !== 1) {
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Invalid collection reference. Collection ' + 'references must have an odd number of segments, but ' + (path.canonicalString() + " has " + path.length));
        }
        return _this;
    }
    Object.defineProperty(CollectionReference.prototype, "id", {
        get: function get() {
            return this._query.path.lastSegment();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CollectionReference.prototype, "parent", {
        get: function get() {
            var parentPath = this._query.path.popLast();
            if (parentPath.isEmpty()) {
                return null;
            } else {
                return new database_DocumentReference(new document_key_DocumentKey(parentPath), this.firestore);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CollectionReference.prototype, "path", {
        get: function get() {
            return this._query.path.canonicalString();
        },
        enumerable: true,
        configurable: true
    });
    CollectionReference.prototype.doc = function (pathString) {
        validateBetweenNumberOfArgs('CollectionReference.doc', arguments, 0, 1);
        // We allow omission of 'pathString' but explicitly prohibit passing in both
        // 'undefined' and 'null'.
        if (arguments.length === 0) {
            pathString = misc_AutoId.newId();
        }
        validateArgType('CollectionReference.doc', 'string', 1, pathString);
        if (pathString === '') {
            throw new FirestoreError(Code.INVALID_ARGUMENT, 'Document path must be a non-empty string');
        }
        var path = path_ResourcePath.fromString(pathString);
        return database_DocumentReference.forPath(this._query.path.child(path), this.firestore);
    };
    CollectionReference.prototype.add = function (value) {
        validateExactNumberOfArgs('CollectionReference.add', arguments, 1);
        validateArgType('CollectionReference.add', 'object', 1, value);
        var docRef = this.doc();
        return docRef.set(value).then(function () {
            return docRef;
        });
    };
    return CollectionReference;
}(database_Query);

function validateSetOptions(methodName, options) {
    if (options === undefined) {
        return {
            merge: false
        };
    }
    validateOptionNames(methodName, options, ['merge']);
    validateNamedOptionalType(methodName, 'boolean', 'merge', options.merge);
    return options;
}
function validateReference(methodName, documentRef, firestore) {
    if (!(documentRef instanceof database_DocumentReference)) {
        throw invalidClassError(methodName, 'DocumentReference', 1, documentRef);
    } else if (documentRef.firestore !== firestore) {
        throw new FirestoreError(Code.INVALID_ARGUMENT, 'Provided document reference is from a different Firestore instance.');
    } else {
        return documentRef;
    }
}
/**
 * Calculates the array of firestore.DocumentChange's for a given ViewSnapshot.
 *
 * Exported for testing.
 */
function changesFromSnapshot(firestore, snapshot) {
    if (snapshot.oldDocs.isEmpty()) {
        // Special case the first snapshot because index calculation is easy and
        // fast
        var lastDoc_1;
        var index_1 = 0;
        return snapshot.docChanges.map(function (change) {
            var doc = new database_DocumentSnapshot(firestore, change.doc.key, change.doc, snapshot.fromCache);
            assert_assert(change.type === ChangeType.Added, 'Invalid event type for first snapshot');
            assert_assert(!lastDoc_1 || snapshot.query.docComparator(lastDoc_1, change.doc) < 0, 'Got added events in wrong order');
            lastDoc_1 = change.doc;
            return {
                type: 'added',
                doc: doc,
                oldIndex: -1,
                newIndex: index_1++
            };
        });
    } else {
        // A DocumentSet that is updated incrementally as changes are applied to use
        // to lookup the index of a document.
        var indexTracker_1 = snapshot.oldDocs;
        return snapshot.docChanges.map(function (change) {
            var doc = new database_DocumentSnapshot(firestore, change.doc.key, change.doc, snapshot.fromCache);
            var oldIndex = -1;
            var newIndex = -1;
            if (change.type !== ChangeType.Added) {
                oldIndex = indexTracker_1.indexOf(change.doc.key);
                assert_assert(oldIndex >= 0, 'Index for document not found');
                indexTracker_1 = indexTracker_1.delete(change.doc.key);
            }
            if (change.type !== ChangeType.Removed) {
                indexTracker_1 = indexTracker_1.add(change.doc);
                newIndex = indexTracker_1.indexOf(change.doc.key);
            }
            return { type: resultChangeType(change.type), doc: doc, oldIndex: oldIndex, newIndex: newIndex };
        });
    }
}
function resultChangeType(type) {
    switch (type) {
        case ChangeType.Added:
            return 'added';
        case ChangeType.Modified:
        case ChangeType.Metadata:
            return 'modified';
        case ChangeType.Removed:
            return 'removed';
        default:
            return fail('Unknown change type: ' + type);
    }
}
// Export the classes with a private constructor (it will fail if invoked
// at runtime). Note that this still allows instanceof checks.
// We're treating the variables as class names, so disable checking for lower
// case variable names.
// tslint:disable:variable-name
var PublicFirestore = makeConstructorPrivate(database_Firestore, 'Use firebase.firestore() instead.');
var PublicTransaction = makeConstructorPrivate(database_Transaction, 'Use firebase.firestore().runTransaction() instead.');
var PublicWriteBatch = makeConstructorPrivate(database_WriteBatch, 'Use firebase.firestore().batch() instead.');
var PublicDocumentReference = makeConstructorPrivate(database_DocumentReference, 'Use firebase.firestore().doc() instead.');
var PublicDocumentSnapshot = makeConstructorPrivate(database_DocumentSnapshot);
var PublicQuery = makeConstructorPrivate(database_Query);
var PublicQuerySnapshot = makeConstructorPrivate(database_QuerySnapshot);
var PublicCollectionReference = makeConstructorPrivate(database_CollectionReference, 'Use firebase.firestore().collection() instead.');
// tslint:enable:variable-name

//# sourceMappingURL=database.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/src/platform/config.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */






var firestoreNamespace = {
  Firestore: PublicFirestore,
  GeoPoint: geo_point_GeoPoint,
  Blob: PublicBlob,
  Transaction: PublicTransaction,
  WriteBatch: PublicWriteBatch,
  DocumentReference: PublicDocumentReference,
  DocumentSnapshot: PublicDocumentSnapshot,
  Query: PublicQuery,
  QuerySnapshot: PublicQuerySnapshot,
  CollectionReference: PublicCollectionReference,
  FieldPath: field_path_FieldPath,
  FieldValue: PublicFieldValue,
  setLogLevel: database_Firestore.setLogLevel
};
/**
 * Configures Firestore as part of the Firebase SDK by calling registerService.
 */
function configureForFirebase(firebase) {
  firebase.INTERNAL.registerService('firestore', function (app) {
    return new database_Firestore(app);
  }, shallowCopy(firestoreNamespace));
}
/**
 * Exports the Firestore namespace into the provided `exportObject` object under
 * the key 'firestore'. This is used for wrapped binary that exposes Firestore
 * as a goog module.
 */
function configureForStandalone(exportObject) {
  var copiedNamespace = shallowCopy(firestoreNamespace);
  // Unlike the use with Firebase, the standalone allows the use of the
  // constructor, so export it's internal class
  copiedNamespace['Firestore'] = database_Firestore;
  exportObject['firestore'] = copiedNamespace;
}

//# sourceMappingURL=config.js.map
// CONCATENATED MODULE: ../node_modules/@firebase/firestore/dist/esm/index.js
/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



function registerFirestore(instance) {
  configureForFirebase(instance);
}
registerFirestore(esm);

//# sourceMappingURL=index.js.map
// CONCATENATED MODULE: ./components/fire.js



console.log('firebase:', esm);
var fire_config = {
	apiKey: 'AIzaSyCDLzg1z67fO1nxguLdSRK3Tf5bDwgPsM4',
	authDomain: 'dev-radar.firebaseapp.com',
	databaseURL: 'https://dev-radar.firebaseio.com',
	projectId: 'dev-radar',
	storageBucket: 'dev-radar.appspot.com',
	messagingSenderId: '549078923980'
};

esm.initializeApp(fire_config);
esm.firestore().enablePersistence().then(function () {
	var db = esm.firestore();
}).catch(function (err) {
	if (err.code === 'failed-precondition') {
		console.log('mult tabs open. can only persist on at a time');
	} else if (err.code === 'unimplemented') {
		console.log('browser doesnt support persistence features');
	}
	var db = esm.firestore();
});

/* harmony default export */ var fire = (esm.default);
var fire_firestore = esm.firestore();
// EXTERNAL MODULE: ../node_modules/preact-material-components/Card/style.css
var Card_style = __webpack_require__("UlEV");
var Card_style_default = /*#__PURE__*/__webpack_require__.n(Card_style);

// EXTERNAL MODULE: ../node_modules/preact-material-components/Button/style.css
var Button_style = __webpack_require__("aqQ4");
var Button_style_default = /*#__PURE__*/__webpack_require__.n(Button_style);

// CONCATENATED MODULE: ./components/article/index.js


function article__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function article__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function article__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





// import style from './style';

var article_Article = function (_Component) {
	article__inherits(Article, _Component);

	function Article() {
		article__classCallCheck(this, Article);

		return article__possibleConstructorReturn(this, _Component.apply(this, arguments));
	}

	Article.prototype.render = function render(state, props) {
		return Object(preact_min["h"])(
			'article',
			{ className: 'article' },
			Object(preact_min["h"])(
				preact_material_components_Card,
				null,
				Object(preact_min["h"])(
					preact_material_components_Card.Primary,
					null,
					Object(preact_min["h"])(
						preact_material_components_Card.Title,
						null,
						state.feedsrc
					),
					Object(preact_min["h"])(
						preact_material_components_Card.Subtitle,
						null,
						Object(preact_min["h"])(
							'a',
							{ href: state.link },
							state.title
						)
					)
				),
				Object(preact_min["h"])(
					preact_material_components_Card.SupportingText,
					null,
					'Created on: ',
					state.createdOn.toDateString()
				)
			)
		);
	};

	return Article;
}(preact_min["Component"]);


// CONCATENATED MODULE: ./components/articleList/index.js
var articleList__extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };



function articleList__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function articleList__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function articleList__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }





// import style from './style';

var articleList_ArticleList = function (_Component) {
	articleList__inherits(ArticleList, _Component);

	function ArticleList(props) {
		articleList__classCallCheck(this, ArticleList);

		var _this = articleList__possibleConstructorReturn(this, _Component.call(this, props));

		_this.state = {
			articles: [
				// {
				// 	createdOn: '2017-12-09T23:49:41.778Z',
				// 	feedsrc: 'Echo JS',
				// 	labels: [],
				// 	link: 'https://is.gd/9ouvi9',
				// 	opengraph: {},
				// 	sentiment: {},
				// 	title: 'React newsletter: 68'
				// }
			]
		};
		return _this;
	}

	ArticleList.prototype.componentWillMount = function componentWillMount() {
		var _this2 = this;

		console.log('firestore:', fire_firestore);
		// firestore
		// 	.collection('publicArticles')
		// 	.orderBy('createdOn')
		// 	.limit(50)
		// 	.get()
		// 	.then(snapshot => {
		// 		const arts = [];
		// 		snapshot.forEach(doc => arts.push(doc.data()));
		// 		this.setState({ articles: arts });
		// 	});
		fire_firestore.collection('publicArticles').orderBy('createdOn', 'asc')
		// .limit(50)
		.onSnapshot({ includeQueryMetadataChanges: true }, function (snapshot) {
			var arts = _this2.state.articles;
			console.log('snapshot:', snapshot);
			snapshot.docChanges.forEach(function (change) {
				console.log('change:', change);
				// if (change.type === 'added') {
				// 	console.log('new article: ', change.doc.data());
				// }
				var source = snapshot.metadata.fromCache ? 'local cache' : 'server';
				console.log('data came from ' + source);
				arts.unshift(change.doc.data());
			});
			_this2.setState({ articles: arts });
		});
	};

	ArticleList.prototype.render = function render(props, state) {
		return Object(preact_min["h"])(
			'section',
			null,
			lodash_map_default()(state.articles, function (article, key) {
				return Object(preact_min["h"])(article_Article, articleList__extends({ key: key }, article));
			})
		);
	};

	return ArticleList;
}(preact_min["Component"]);


// EXTERNAL MODULE: ./routes/home/style.css
var home_style = __webpack_require__("ZAL5");
var home_style_default = /*#__PURE__*/__webpack_require__.n(home_style);

// CONCATENATED MODULE: ./routes/home/index.js


function home__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function home__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function home__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }








var home__ref = Object(preact_min["h"])(
	'h1',
	null,
	'Home route'
);

var home__ref2 = Object(preact_min["h"])(articleList_ArticleList, null);

var home_Home = function (_Component) {
	home__inherits(Home, _Component);

	function Home() {
		home__classCallCheck(this, Home);

		return home__possibleConstructorReturn(this, _Component.apply(this, arguments));
	}

	Home.prototype.render = function render() {
		return Object(preact_min["h"])(
			'div',
			{ 'class': home_style_default.a.home },
			home__ref,
			home__ref2
		);
	};

	return Home;
}(preact_min["Component"]);


// EXTERNAL MODULE: ./routes/profile/style.css
var profile_style = __webpack_require__("Tv6c");
var profile_style_default = /*#__PURE__*/__webpack_require__.n(profile_style);

// CONCATENATED MODULE: ./routes/profile/index.js


function profile__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function profile__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function profile__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






var profile_Profile = function (_Component) {
	profile__inherits(Profile, _Component);

	function Profile() {
		var _temp, _this, _ret;

		profile__classCallCheck(this, Profile);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = profile__possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.state = {
			time: Date.now(),
			count: 10
		}, _this.updateTime = function () {
			_this.setState({ time: Date.now() });
		}, _this.increment = function () {
			_this.setState({ count: _this.state.count + 1 });
		}, _temp), profile__possibleConstructorReturn(_this, _ret);
	}

	// gets called when this route is navigated to
	Profile.prototype.componentDidMount = function componentDidMount() {
		// start a timer for the clock:
		this.timer = setInterval(this.updateTime, 1000);
	};

	// gets called just before navigating away from the route


	Profile.prototype.componentWillUnmount = function componentWillUnmount() {
		clearInterval(this.timer);
	};

	// update the current time


	// Note: `user` comes from the URL, courtesy of our router
	Profile.prototype.render = function render(_ref, _ref2) {
		var user = _ref.user;
		var time = _ref2.time,
		    count = _ref2.count;

		return Object(preact_min["h"])(
			'div',
			{ 'class': profile_style_default.a.profile },
			Object(preact_min["h"])(
				'h1',
				null,
				'Profile: ',
				user
			),
			Object(preact_min["h"])(
				'p',
				null,
				'This is the user profile for a user named ',
				user,
				'.'
			),
			Object(preact_min["h"])(
				'div',
				null,
				'Current time: ',
				new Date(time).toLocaleString()
			),
			Object(preact_min["h"])(
				'p',
				null,
				Object(preact_min["h"])(
					preact_material_components_Button,
					{ raised: true, primary: true, ripple: true, onClick: this.increment },
					'Click Me'
				),
				' ',
				'Clicked ',
				count,
				' times.'
			)
		);
	};

	return Profile;
}(preact_min["Component"]);


// CONCATENATED MODULE: ./components/app.js


function app__classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function app__possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function app__inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }







// import Home from 'async!../routes/home';
// import Profile from 'async!../routes/profile';

var app__ref = Object(preact_min["h"])(header_Header, null);

var app__ref2 = Object(preact_min["h"])(home_Home, { path: '/' });

var app__ref3 = Object(preact_min["h"])(profile_Profile, { path: '/profile/', user: 'me' });

var app__ref4 = Object(preact_min["h"])(profile_Profile, { path: '/profile/:user' });

var app_App = function (_Component) {
	app__inherits(App, _Component);

	function App() {
		var _temp, _this, _ret;

		app__classCallCheck(this, App);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = app__possibleConstructorReturn(this, _Component.call.apply(_Component, [this].concat(args))), _this), _this.handleRoute = function (e) {
			_this.currentUrl = e.url;
		}, _temp), app__possibleConstructorReturn(_this, _ret);
	}
	/** Gets fired when the route changes.
  *	@param {Object} event		"change" event from [preact-router](http://git.io/preact-router)
  *	@param {string} event.url	The newly routed URL
  */


	App.prototype.render = function render() {
		return Object(preact_min["h"])(
			'div',
			{ id: 'app' },
			app__ref,
			Object(preact_min["h"])(
				preact_router_es_Router,
				{ onChange: this.handleRoute },
				app__ref2,
				app__ref3,
				app__ref4
			)
		);
	};

	return App;
}(preact_min["Component"]);


// CONCATENATED MODULE: ./index.js



/* harmony default export */ var index_0 = __webpack_exports__["default"] = (app_App);

/***/ }),

/***/ "KM04":
/***/ (function(module, exports, __webpack_require__) {

!function () {
  "use strict";
  function e() {}function t(t, n) {
    var o,
        r,
        i,
        l,
        a = E;for (l = arguments.length; l-- > 2;) {
      W.push(arguments[l]);
    }n && null != n.children && (W.length || W.push(n.children), delete n.children);while (W.length) {
      if ((r = W.pop()) && void 0 !== r.pop) for (l = r.length; l--;) {
        W.push(r[l]);
      } else "boolean" == typeof r && (r = null), (i = "function" != typeof t) && (null == r ? r = "" : "number" == typeof r ? r += "" : "string" != typeof r && (i = !1)), i && o ? a[a.length - 1] += r : a === E ? a = [r] : a.push(r), o = i;
    }var u = new e();return u.nodeName = t, u.children = a, u.attributes = null == n ? void 0 : n, u.key = null == n ? void 0 : n.key, void 0 !== S.vnode && S.vnode(u), u;
  }function n(e, t) {
    for (var n in t) {
      e[n] = t[n];
    }return e;
  }function o(e, o) {
    return t(e.nodeName, n(n({}, e.attributes), o), arguments.length > 2 ? [].slice.call(arguments, 2) : e.children);
  }function r(e) {
    !e.__d && (e.__d = !0) && 1 == A.push(e) && (S.debounceRendering || P)(i);
  }function i() {
    var e,
        t = A;A = [];while (e = t.pop()) {
      e.__d && k(e);
    }
  }function l(e, t, n) {
    return "string" == typeof t || "number" == typeof t ? void 0 !== e.splitText : "string" == typeof t.nodeName ? !e._componentConstructor && a(e, t.nodeName) : n || e._componentConstructor === t.nodeName;
  }function a(e, t) {
    return e.__n === t || e.nodeName.toLowerCase() === t.toLowerCase();
  }function u(e) {
    var t = n({}, e.attributes);t.children = e.children;var o = e.nodeName.defaultProps;if (void 0 !== o) for (var r in o) {
      void 0 === t[r] && (t[r] = o[r]);
    }return t;
  }function _(e, t) {
    var n = t ? document.createElementNS("http://www.w3.org/2000/svg", e) : document.createElement(e);return n.__n = e, n;
  }function p(e) {
    var t = e.parentNode;t && t.removeChild(e);
  }function c(e, t, n, o, r) {
    if ("className" === t && (t = "class"), "key" === t) ;else if ("ref" === t) n && n(null), o && o(e);else if ("class" !== t || r) {
      if ("style" === t) {
        if (o && "string" != typeof o && "string" != typeof n || (e.style.cssText = o || ""), o && "object" == typeof o) {
          if ("string" != typeof n) for (var i in n) {
            i in o || (e.style[i] = "");
          }for (var i in o) {
            e.style[i] = "number" == typeof o[i] && !1 === V.test(i) ? o[i] + "px" : o[i];
          }
        }
      } else if ("dangerouslySetInnerHTML" === t) o && (e.innerHTML = o.__html || "");else if ("o" == t[0] && "n" == t[1]) {
        var l = t !== (t = t.replace(/Capture$/, ""));t = t.toLowerCase().substring(2), o ? n || e.addEventListener(t, f, l) : e.removeEventListener(t, f, l), (e.__l || (e.__l = {}))[t] = o;
      } else if ("list" !== t && "type" !== t && !r && t in e) s(e, t, null == o ? "" : o), null != o && !1 !== o || e.removeAttribute(t);else {
        var a = r && t !== (t = t.replace(/^xlink\:?/, ""));null == o || !1 === o ? a ? e.removeAttributeNS("http://www.w3.org/1999/xlink", t.toLowerCase()) : e.removeAttribute(t) : "function" != typeof o && (a ? e.setAttributeNS("http://www.w3.org/1999/xlink", t.toLowerCase(), o) : e.setAttribute(t, o));
      }
    } else e.className = o || "";
  }function s(e, t, n) {
    try {
      e[t] = n;
    } catch (e) {}
  }function f(e) {
    return this.__l[e.type](S.event && S.event(e) || e);
  }function d() {
    var e;while (e = D.pop()) {
      S.afterMount && S.afterMount(e), e.componentDidMount && e.componentDidMount();
    }
  }function h(e, t, n, o, r, i) {
    H++ || (R = null != r && void 0 !== r.ownerSVGElement, j = null != e && !("__preactattr_" in e));var l = m(e, t, n, o, i);return r && l.parentNode !== r && r.appendChild(l), --H || (j = !1, i || d()), l;
  }function m(e, t, n, o, r) {
    var i = e,
        l = R;if (null != t && "boolean" != typeof t || (t = ""), "string" == typeof t || "number" == typeof t) return e && void 0 !== e.splitText && e.parentNode && (!e._component || r) ? e.nodeValue != t && (e.nodeValue = t) : (i = document.createTextNode(t), e && (e.parentNode && e.parentNode.replaceChild(i, e), b(e, !0))), i.__preactattr_ = !0, i;var u = t.nodeName;if ("function" == typeof u) return U(e, t, n, o);if (R = "svg" === u || "foreignObject" !== u && R, u += "", (!e || !a(e, u)) && (i = _(u, R), e)) {
      while (e.firstChild) {
        i.appendChild(e.firstChild);
      }e.parentNode && e.parentNode.replaceChild(i, e), b(e, !0);
    }var p = i.firstChild,
        c = i.__preactattr_,
        s = t.children;if (null == c) {
      c = i.__preactattr_ = {};for (var f = i.attributes, d = f.length; d--;) {
        c[f[d].name] = f[d].value;
      }
    }return !j && s && 1 === s.length && "string" == typeof s[0] && null != p && void 0 !== p.splitText && null == p.nextSibling ? p.nodeValue != s[0] && (p.nodeValue = s[0]) : (s && s.length || null != p) && v(i, s, n, o, j || null != c.dangerouslySetInnerHTML), g(i, t.attributes, c), R = l, i;
  }function v(e, t, n, o, r) {
    var i,
        a,
        u,
        _,
        c,
        s = e.childNodes,
        f = [],
        d = {},
        h = 0,
        v = 0,
        y = s.length,
        g = 0,
        w = t ? t.length : 0;if (0 !== y) for (var C = 0; C < y; C++) {
      var x = s[C],
          N = x.__preactattr_,
          k = w && N ? x._component ? x._component.__k : N.key : null;null != k ? (h++, d[k] = x) : (N || (void 0 !== x.splitText ? !r || x.nodeValue.trim() : r)) && (f[g++] = x);
    }if (0 !== w) for (var C = 0; C < w; C++) {
      _ = t[C], c = null;var k = _.key;if (null != k) h && void 0 !== d[k] && (c = d[k], d[k] = void 0, h--);else if (!c && v < g) for (i = v; i < g; i++) {
        if (void 0 !== f[i] && l(a = f[i], _, r)) {
          c = a, f[i] = void 0, i === g - 1 && g--, i === v && v++;break;
        }
      }c = m(c, _, n, o), u = s[C], c && c !== e && c !== u && (null == u ? e.appendChild(c) : c === u.nextSibling ? p(u) : e.insertBefore(c, u));
    }if (h) for (var C in d) {
      void 0 !== d[C] && b(d[C], !1);
    }while (v <= g) {
      void 0 !== (c = f[g--]) && b(c, !1);
    }
  }function b(e, t) {
    var n = e._component;n ? L(n) : (null != e.__preactattr_ && e.__preactattr_.ref && e.__preactattr_.ref(null), !1 !== t && null != e.__preactattr_ || p(e), y(e));
  }function y(e) {
    e = e.lastChild;while (e) {
      var t = e.previousSibling;b(e, !0), e = t;
    }
  }function g(e, t, n) {
    var o;for (o in n) {
      t && null != t[o] || null == n[o] || c(e, o, n[o], n[o] = void 0, R);
    }for (o in t) {
      "children" === o || "innerHTML" === o || o in n && t[o] === ("value" === o || "checked" === o ? e[o] : n[o]) || c(e, o, n[o], n[o] = t[o], R);
    }
  }function w(e) {
    var t = e.constructor.name;(I[t] || (I[t] = [])).push(e);
  }function C(e, t, n) {
    var o,
        r = I[e.name];if (e.prototype && e.prototype.render ? (o = new e(t, n), T.call(o, t, n)) : (o = new T(t, n), o.constructor = e, o.render = x), r) for (var i = r.length; i--;) {
      if (r[i].constructor === e) {
        o.__b = r[i].__b, r.splice(i, 1);break;
      }
    }return o;
  }function x(e, t, n) {
    return this.constructor(e, n);
  }function N(e, t, n, o, i) {
    e.__x || (e.__x = !0, (e.__r = t.ref) && delete t.ref, (e.__k = t.key) && delete t.key, !e.base || i ? e.componentWillMount && e.componentWillMount() : e.componentWillReceiveProps && e.componentWillReceiveProps(t, o), o && o !== e.context && (e.__c || (e.__c = e.context), e.context = o), e.__p || (e.__p = e.props), e.props = t, e.__x = !1, 0 !== n && (1 !== n && !1 === S.syncComponentUpdates && e.base ? r(e) : k(e, 1, i)), e.__r && e.__r(e));
  }function k(e, t, o, r) {
    if (!e.__x) {
      var i,
          l,
          a,
          _ = e.props,
          p = e.state,
          c = e.context,
          s = e.__p || _,
          f = e.__s || p,
          m = e.__c || c,
          v = e.base,
          y = e.__b,
          g = v || y,
          w = e._component,
          x = !1;if (v && (e.props = s, e.state = f, e.context = m, 2 !== t && e.shouldComponentUpdate && !1 === e.shouldComponentUpdate(_, p, c) ? x = !0 : e.componentWillUpdate && e.componentWillUpdate(_, p, c), e.props = _, e.state = p, e.context = c), e.__p = e.__s = e.__c = e.__b = null, e.__d = !1, !x) {
        i = e.render(_, p, c), e.getChildContext && (c = n(n({}, c), e.getChildContext()));var U,
            T,
            M = i && i.nodeName;if ("function" == typeof M) {
          var W = u(i);l = w, l && l.constructor === M && W.key == l.__k ? N(l, W, 1, c, !1) : (U = l, e._component = l = C(M, W, c), l.__b = l.__b || y, l.__u = e, N(l, W, 0, c, !1), k(l, 1, o, !0)), T = l.base;
        } else a = g, U = w, U && (a = e._component = null), (g || 1 === t) && (a && (a._component = null), T = h(a, i, c, o || !v, g && g.parentNode, !0));if (g && T !== g && l !== w) {
          var E = g.parentNode;E && T !== E && (E.replaceChild(T, g), U || (g._component = null, b(g, !1)));
        }if (U && L(U), e.base = T, T && !r) {
          var P = e,
              V = e;while (V = V.__u) {
            (P = V).base = T;
          }T._component = P, T._componentConstructor = P.constructor;
        }
      }if (!v || o ? D.unshift(e) : x || (e.componentDidUpdate && e.componentDidUpdate(s, f, m), S.afterUpdate && S.afterUpdate(e)), null != e.__h) while (e.__h.length) {
        e.__h.pop().call(e);
      }H || r || d();
    }
  }function U(e, t, n, o) {
    var r = e && e._component,
        i = r,
        l = e,
        a = r && e._componentConstructor === t.nodeName,
        _ = a,
        p = u(t);while (r && !_ && (r = r.__u)) {
      _ = r.constructor === t.nodeName;
    }return r && _ && (!o || r._component) ? (N(r, p, 3, n, o), e = r.base) : (i && !a && (L(i), e = l = null), r = C(t.nodeName, p, n), e && !r.__b && (r.__b = e, l = null), N(r, p, 1, n, o), e = r.base, l && e !== l && (l._component = null, b(l, !1))), e;
  }function L(e) {
    S.beforeUnmount && S.beforeUnmount(e);var t = e.base;e.__x = !0, e.componentWillUnmount && e.componentWillUnmount(), e.base = null;var n = e._component;n ? L(n) : t && (t.__preactattr_ && t.__preactattr_.ref && t.__preactattr_.ref(null), e.__b = t, p(t), w(e), y(t)), e.__r && e.__r(null);
  }function T(e, t) {
    this.__d = !0, this.context = t, this.props = e, this.state = this.state || {};
  }function M(e, t, n) {
    return h(n, e, {}, !1, t, !1);
  }var S = {},
      W = [],
      E = [],
      P = "function" == typeof Promise ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout,
      V = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i,
      A = [],
      D = [],
      H = 0,
      R = !1,
      j = !1,
      I = {};n(T.prototype, { setState: function setState(e, t) {
      var o = this.state;this.__s || (this.__s = n({}, o)), n(o, "function" == typeof e ? e(o, this.props) : e), t && (this.__h = this.__h || []).push(t), r(this);
    }, forceUpdate: function forceUpdate(e) {
      e && (this.__h = this.__h || []).push(e), k(this, 2);
    }, render: function render() {} });var $ = { h: t, createElement: t, cloneElement: o, Component: T, render: M, rerender: i, options: S }; true ? module.exports = $ : self.preact = $;
}();
//# sourceMappingURL=preact.min.js.map

/***/ }),

/***/ "LbTS":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "RYBc":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "TO+D":
/***/ (function(module, exports) {

module.exports = function (el, options) {
  options = options || {};

  var elementDocument = el.ownerDocument || el;
  var basicTabbables = [];
  var orderedTabbables = [];

  // A node is "available" if
  // - it's computed style
  var isUnavailable = createIsUnavailable(elementDocument);

  var candidateSelectors = ['input', 'select', 'a[href]', 'textarea', 'button', '[tabindex]'];

  var candidates = el.querySelectorAll(candidateSelectors);

  if (options.includeContainer) {
    var matches = Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

    if (candidateSelectors.some(function (candidateSelector) {
      return matches.call(el, candidateSelector);
    })) {
      candidates = Array.prototype.slice.apply(candidates);
      candidates.unshift(el);
    }
  }

  var candidate, candidateIndex;
  for (var i = 0, l = candidates.length; i < l; i++) {
    candidate = candidates[i];
    candidateIndex = parseInt(candidate.getAttribute('tabindex'), 10) || candidate.tabIndex;

    if (candidateIndex < 0 || candidate.tagName === 'INPUT' && candidate.type === 'hidden' || candidate.disabled || isUnavailable(candidate, elementDocument)) {
      continue;
    }

    if (candidateIndex === 0) {
      basicTabbables.push(candidate);
    } else {
      orderedTabbables.push({
        index: i,
        tabIndex: candidateIndex,
        node: candidate
      });
    }
  }

  var tabbableNodes = orderedTabbables.sort(function (a, b) {
    return a.tabIndex === b.tabIndex ? a.index - b.index : a.tabIndex - b.tabIndex;
  }).map(function (a) {
    return a.node;
  });

  Array.prototype.push.apply(tabbableNodes, basicTabbables);

  return tabbableNodes;
};

function createIsUnavailable(elementDocument) {
  // Node cache must be refreshed on every check, in case
  // the content of the element has changed
  var isOffCache = [];

  // "off" means `display: none;`, as opposed to "hidden",
  // which means `visibility: hidden;`. getComputedStyle
  // accurately reflects visiblity in context but not
  // "off" state, so we need to recursively check parents.

  function isOff(node, nodeComputedStyle) {
    if (node === elementDocument.documentElement) return false;

    // Find the cached node (Array.prototype.find not available in IE9)
    for (var i = 0, length = isOffCache.length; i < length; i++) {
      if (isOffCache[i][0] === node) return isOffCache[i][1];
    }

    nodeComputedStyle = nodeComputedStyle || elementDocument.defaultView.getComputedStyle(node);

    var result = false;

    if (nodeComputedStyle.display === 'none') {
      result = true;
    } else if (node.parentNode) {
      result = isOff(node.parentNode);
    }

    isOffCache.push([node, result]);

    return result;
  }

  return function isUnavailable(node) {
    if (node === elementDocument.documentElement) return false;

    var computedStyle = elementDocument.defaultView.getComputedStyle(node);

    if (isOff(node, computedStyle)) return true;

    return computedStyle.visibility === 'hidden';
  };
}

/***/ }),

/***/ "Tv6c":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin
module.exports = {"profile":"profile__t2Dqz"};

/***/ }),

/***/ "UlEV":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "ZAL5":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin
module.exports = {"home":"home__MseGd"};

/***/ }),

/***/ "aqQ4":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "l262":
/***/ (function(module, exports) {

module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),

/***/ "rq4c":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "sEh6":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "u+vq":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "ySUw":
/***/ (function(module, exports, __webpack_require__) {

var tabbable = __webpack_require__("TO+D");

var listeningFocusTrap = null;

function focusTrap(element, userOptions) {
  var tabbableNodes = [];
  var firstTabbableNode = null;
  var lastTabbableNode = null;
  var nodeFocusedBeforeActivation = null;
  var active = false;
  var paused = false;
  var tabEvent = null;

  var container = typeof element === 'string' ? document.querySelector(element) : element;

  var config = userOptions || {};
  config.returnFocusOnDeactivate = userOptions && userOptions.returnFocusOnDeactivate !== undefined ? userOptions.returnFocusOnDeactivate : true;
  config.escapeDeactivates = userOptions && userOptions.escapeDeactivates !== undefined ? userOptions.escapeDeactivates : true;

  var trap = {
    activate: activate,
    deactivate: deactivate,
    pause: pause,
    unpause: unpause
  };

  return trap;

  function activate(activateOptions) {
    if (active) return;

    var defaultedActivateOptions = {
      onActivate: activateOptions && activateOptions.onActivate !== undefined ? activateOptions.onActivate : config.onActivate
    };

    active = true;
    paused = false;
    nodeFocusedBeforeActivation = document.activeElement;

    if (defaultedActivateOptions.onActivate) {
      defaultedActivateOptions.onActivate();
    }

    addListeners();
    return trap;
  }

  function deactivate(deactivateOptions) {
    if (!active) return;

    var defaultedDeactivateOptions = {
      returnFocus: deactivateOptions && deactivateOptions.returnFocus !== undefined ? deactivateOptions.returnFocus : config.returnFocusOnDeactivate,
      onDeactivate: deactivateOptions && deactivateOptions.onDeactivate !== undefined ? deactivateOptions.onDeactivate : config.onDeactivate
    };

    removeListeners();

    if (defaultedDeactivateOptions.onDeactivate) {
      defaultedDeactivateOptions.onDeactivate();
    }

    if (defaultedDeactivateOptions.returnFocus) {
      setTimeout(function () {
        tryFocus(nodeFocusedBeforeActivation);
      }, 0);
    }

    active = false;
    paused = false;
    return this;
  }

  function pause() {
    if (paused || !active) return;
    paused = true;
    removeListeners();
  }

  function unpause() {
    if (!paused || !active) return;
    paused = false;
    addListeners();
  }

  function addListeners() {
    if (!active) return;

    // There can be only one listening focus trap at a time
    if (listeningFocusTrap) {
      listeningFocusTrap.pause();
    }
    listeningFocusTrap = trap;

    updateTabbableNodes();
    tryFocus(firstFocusNode());
    document.addEventListener('focus', checkFocus, true);
    document.addEventListener('click', checkClick, true);
    document.addEventListener('mousedown', checkPointerDown, true);
    document.addEventListener('touchstart', checkPointerDown, true);
    document.addEventListener('keydown', checkKey, true);

    return trap;
  }

  function removeListeners() {
    if (!active || listeningFocusTrap !== trap) return;

    document.removeEventListener('focus', checkFocus, true);
    document.removeEventListener('click', checkClick, true);
    document.removeEventListener('mousedown', checkPointerDown, true);
    document.removeEventListener('touchstart', checkPointerDown, true);
    document.removeEventListener('keydown', checkKey, true);

    listeningFocusTrap = null;

    return trap;
  }

  function getNodeForOption(optionName) {
    var optionValue = config[optionName];
    var node = optionValue;
    if (!optionValue) {
      return null;
    }
    if (typeof optionValue === 'string') {
      node = document.querySelector(optionValue);
      if (!node) {
        throw new Error('`' + optionName + '` refers to no known node');
      }
    }
    if (typeof optionValue === 'function') {
      node = optionValue();
      if (!node) {
        throw new Error('`' + optionName + '` did not return a node');
      }
    }
    return node;
  }

  function firstFocusNode() {
    var node;
    if (getNodeForOption('initialFocus') !== null) {
      node = getNodeForOption('initialFocus');
    } else if (container.contains(document.activeElement)) {
      node = document.activeElement;
    } else {
      node = tabbableNodes[0] || getNodeForOption('fallbackFocus');
    }

    if (!node) {
      throw new Error('You can\'t have a focus-trap without at least one focusable element');
    }

    return node;
  }

  // This needs to be done on mousedown and touchstart instead of click
  // so that it precedes the focus event
  function checkPointerDown(e) {
    if (config.clickOutsideDeactivates && !container.contains(e.target)) {
      deactivate({ returnFocus: false });
    }
  }

  function checkClick(e) {
    if (config.clickOutsideDeactivates) return;
    if (container.contains(e.target)) return;
    e.preventDefault();
    e.stopImmediatePropagation();
  }

  function checkFocus(e) {
    if (container.contains(e.target)) return;
    e.preventDefault();
    e.stopImmediatePropagation();
    // Checking for a blur method here resolves a Firefox issue (#15)
    if (typeof e.target.blur === 'function') e.target.blur();

    if (tabEvent) {
      readjustFocus(tabEvent);
    }
  }

  function checkKey(e) {
    if (e.key === 'Tab' || e.keyCode === 9) {
      handleTab(e);
    }

    if (config.escapeDeactivates !== false && isEscapeEvent(e)) {
      deactivate();
    }
  }

  function handleTab(e) {
    updateTabbableNodes();

    if (e.target.hasAttribute('tabindex') && Number(e.target.getAttribute('tabindex')) < 0) {
      return tabEvent = e;
    }

    e.preventDefault();
    var currentFocusIndex = tabbableNodes.indexOf(e.target);

    if (e.shiftKey) {
      if (e.target === firstTabbableNode || tabbableNodes.indexOf(e.target) === -1) {
        return tryFocus(lastTabbableNode);
      }
      return tryFocus(tabbableNodes[currentFocusIndex - 1]);
    }

    if (e.target === lastTabbableNode) return tryFocus(firstTabbableNode);

    tryFocus(tabbableNodes[currentFocusIndex + 1]);
  }

  function updateTabbableNodes() {
    tabbableNodes = tabbable(container);
    firstTabbableNode = tabbableNodes[0];
    lastTabbableNode = tabbableNodes[tabbableNodes.length - 1];
  }

  function readjustFocus(e) {
    if (e.shiftKey) return tryFocus(lastTabbableNode);

    tryFocus(firstTabbableNode);
  }
}

function isEscapeEvent(e) {
  return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;
}

function tryFocus(node) {
  if (!node || !node.focus) return;
  if (node === document.activeElement) return;

  node.focus();
  if (node.tagName.toLowerCase() === 'input') {
    node.select();
  }
}

module.exports = focusTrap;

/***/ }),

/***/ "yYyN":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1,
    PARTIAL_COMPARE_FLAG = 2;

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/,
    reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = function () {
  try {
    return freeProcess && freeProcess.binding('util');
  } catch (e) {}
}();

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function (object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function (value) {
    return func(value);
  };
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function (value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function (arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function (value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = function () {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? 'Symbol(src)_1.' + uid : '';
}();

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

/** Built-in value references. */
var Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash(),
    'map': new (Map || ListCache)(),
    'string': new Hash()
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache();
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache();
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache) {
    var pairs = cache.__data__;
    if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return index && index == length ? object : undefined;
}

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  return objectToString.call(value);
}

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {boolean} [bitmask] The bitmask of comparison flags.
 *  The bitmask may be composed of the following flags:
 *     1 - Unordered comparison
 *     2 - Partial comparison
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, customizer, bitmask, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
}

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = arrayTag,
      othTag = arrayTag;

  if (!objIsArr) {
    objTag = getTag(object);
    objTag = objTag == argsTag ? objectTag : objTag;
  }
  if (!othIsArr) {
    othTag = getTag(other);
    othTag = othTag == argsTag ? objectTag : othTag;
  }
  var objIsObj = objTag == objectTag && !isHostObject(object),
      othIsObj = othTag == objectTag && !isHostObject(other),
      isSameTag = objTag == othTag;

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack());
    return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
  }
  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack());
      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack());
  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
}

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
}

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function (value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function (object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function (object) {
    var objValue = get(object, path);
    return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
  };
}

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function (object) {
    return baseGet(object, path);
  };
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function (collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while (fromRight ? index-- : ++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function (object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function (othValue, othIndex) {
        if (!seen.has(othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          return seen.add(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
  switch (tag) {
    case dataViewTag:
      if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == other + '';

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= UNORDERED_COMPARE_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      objProps = keys(object),
      objLength = objProps.length,
      othProps = keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
  getTag = function getTag(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = isKey(path, object) ? [path] : castPath(path);

  var result,
      index = -1,
      length = path.length;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result) {
    return result;
  }
  var length = object ? object.length : 0;
  return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;

  return value === proto;
}

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function (object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
  };
}

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoize(function (string) {
  string = toString(string);

  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function (match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
  });
  return result;
});

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = value + '';
  return result == '0' && 1 / value == -INFINITY ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return func + '';
    } catch (e) {}
  }
  return '';
}

/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map(collection, iteratee) {
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee, 3));
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || resolver && typeof resolver != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function memoized() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || value !== value && other !== other;
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = map;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("l262")(module)))

/***/ })

/******/ });
//# sourceMappingURL=ssr-bundle.js.map